<?xml version="1.0" encoding="UTF-8"?><?asciidoc-toc?><?asciidoc-numbered?><article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>RISC-V "V" ベクトル拡張</title>
<date>2021-06-13</date>
<author>
<personname>
<firstname>Version</firstname>
<surname>1.0-rc2-draft</surname>
</personname>
</author>
<authorinitials>V1</authorinitials>
</info>
<simpara>Contributors include: Alon Amid, Krste Asanovic, Allen Baum, Alex
Bradbury, Tony Brewer, Chris Celio, Aliaksei Chapyzhenka, Silviu
Chiricescu, Ken Dockser, Bob Dreyer, Roger Espasa, Sean Halle, John
Hauser, David Horner, Bruce Hoult, Bill Huffman, Nicholas Knight,
Constantine Korikov,
Ben Korpan, Hanna Kruppe, Yunsup Lee, Guy Lemieux, Grigorios Magklis,
Filip Moc, Rich Newell, Albert Ou, David Patterson, Colin Schmidt,
Alex Solomatnikov, Steve Wallach, Andrew Waterman, Jim Wilson.</simpara>
<section xml:id="_v1_0_rc1からの変更点">
<title>v1.0-rc1からの変更点</title>
<section xml:id="_現在まで変更なし">
<title>現在まで変更なし。</title>

</section>
</section>
<section xml:id="_イントロダクション">
<title>イントロダクション</title>
<simpara>このドキュメントは、RISC-Vベクトル拡張のバージョン1.0の第2リリース候補のドラフトであり、
パブリックレビューのためのものです。</simpara>
<simpara><emphasis role="strong">これはパブリックレビュー用の1.0の凍結版ではありません。</emphasis></simpara>
<simpara>注：最終的に承認され、リリース候補のタグが外されたバージョン1.0は、
RISC-Vインターナショナルの批准プロセスの一環として、パブリックレビューのために送り出されることを意図しています。
また、バージョン1.0は、上流のソフトウェアプロジェクトを含め、ツールチェーン、機能シミュレータ、
初期実装の開発を開始するのに十分な安定性があると考えられており、
批准中に重大な問題が発見された場合を除き、
大きな機能変更はないと予想されています。批准されると、仕様書のバージョンは2.0になります。</simpara>
<simpara>本仕様書ドラフトには、現在定義されているベクトル命令の全セットが含まれています。
<xref linkend="sec-vector-extensions"/>  セクションには、標準的なベクトル拡張機能と、
それぞれの拡張機能でサポートされる命令および要素幅が記載されています。</simpara>
</section>
<section xml:id="_実装により定義される定数パラメータ">
<title>実装により定義される定数パラメータ</title>
<simpara>ベクトル拡張をサポートする各hartには、2つのパラメータが定義されています。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>任意の演算で生成または消費できるベクター要素の最大サイズ(ビット) <emphasis>ELEN</emphasis> ≥ 8 で、これは2の累乗でなければなりません。</simpara>
</listitem>
<listitem>
<simpara>1つのベクトルレジスターのビット数 <emphasis>VLEN</emphasis> 、これは2の累乗でなければならず、2の累乗であり、2<superscript>16</superscript>以上であってはなりません。</simpara>
</listitem>
</orderedlist>
<simpara>標準的なベクトル拡張(<xref linkend="sec-vector-extensions"/> セクション)とアーキテクチャプロファイルは、 <emphasis>ELEN</emphasis> と <emphasis>VLEN</emphasis> にさらなる制約を設定することができます。</simpara>
<simpara>Note: VLENの上限により、ソフトウェアはインデックスが16ビットに収まることを前提に組み立てることができます
(LMUL=8およびSEW=8でVLEN=65,536の場合、最大のVLMAXは65,536になります)。
将来的にクトルレジスタあたり64Kib以上に拡張する場合は、
新しいコンフィグレーション命令が必要になりますが、
従来のコンフィグレーション命令を使用しているソフトウェアでは、
ベクトルの長さが大きくなることはありません。</simpara>
<simpara>ISAは、特定の制約の下で、VLENパラメータの値が異なるhart上でバイナリコードが実行されるポータブルな記述をサポートしていますが、
両方のhartが必要な要素型をサポートしていることが条件となります。</simpara>
<note>
<simpara>実装パラメータの違いを露呈するようなコードを書くことも可能です。</simpara>
</note>
<note>
<simpara>一般的に、ベクトルのステートがアクティブであるスレッドコンテキストは、
VLENまたはELENパラメータに違いのあるhart間で実行中にコンテキストを移動するとはできません。</simpara>
</note>
</section>
<section xml:id="_ベクトル拡張のプログラミングモデル">
<title>ベクトル拡張のプログラミングモデル</title>
<simpara>ベクトル拡張はRISC-VのベーススカラISAに対して、
32本のベクトルレジスタに加えて7つの非特権CSR(<literal>vstart</literal>, <literal>vxsat</literal>, <literal>vxrm</literal>, <literal>vcsr</literal>, <literal>vl</literal>, <literal>vlenb</literal>)</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>新しいベクトルCSR</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="12.5*"/>
<colspec colname="col_3" colwidth="12.5*"/>
<colspec colname="col_4" colwidth="62.5*"/>
<thead>
<row>
<entry align="left" valign="top">アドレス</entry>
<entry align="left" valign="top">特権</entry>
<entry align="left" valign="top">名前</entry>
<entry align="left" valign="top">説明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0x008</simpara></entry>
<entry align="left" valign="top"><simpara>URW</simpara></entry>
<entry align="left" valign="top"><simpara>vstart</simpara></entry>
<entry align="left" valign="top"><simpara>ベクトル操作開始位置</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0x009</simpara></entry>
<entry align="left" valign="top"><simpara>URW</simpara></entry>
<entry align="left" valign="top"><simpara>vxsat</simpara></entry>
<entry align="left" valign="top"><simpara>固定小数点飽和フラグ</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0x00A</simpara></entry>
<entry align="left" valign="top"><simpara>URW</simpara></entry>
<entry align="left" valign="top"><simpara>vxrm</simpara></entry>
<entry align="left" valign="top"><simpara>固定小数点丸めモード</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0x00F</simpara></entry>
<entry align="left" valign="top"><simpara>URW</simpara></entry>
<entry align="left" valign="top"><simpara>vcsr</simpara></entry>
<entry align="left" valign="top"><simpara>ベクトル制御・ステータスレジスタ</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0xC20</simpara></entry>
<entry align="left" valign="top"><simpara>URO</simpara></entry>
<entry align="left" valign="top"><simpara>vl</simpara></entry>
<entry align="left" valign="top"><simpara>ベクトル長</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0xC21</simpara></entry>
<entry align="left" valign="top"><simpara>URO</simpara></entry>
<entry align="left" valign="top"><simpara>vtype</simpara></entry>
<entry align="left" valign="top"><simpara>ベクトルデータ型レジスタ</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0xC22</simpara></entry>
<entry align="left" valign="top"><simpara>URO</simpara></entry>
<entry align="left" valign="top"><simpara>vlenb</simpara></entry>
<entry align="left" valign="top"><simpara>VLEN/8 (バイト単位でのベクトルレジスタ長)</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="_ベクトルレジスタ">
<title>ベクトルレジスタ</title>
<simpara>ベクトル拡張により、RISC-VベーススカラISAに対して
32本のアーキテクチャベクトルレジスタ`v0`-`v31`が追加される。</simpara>
<simpara>各ベクトルレジスタのサイズは固定長でVLENビットである。</simpara>
<note>
<simpara>Zfinx ("F in X") は現在議論が行われている、浮動小数点命令を
整数レジスタファイル上で実行する新しいISAオプションです。
Vector 1.0拡張はZfinxに対して互換性があります。</simpara>
</note>
</section>
<section xml:id="_mstatus_内のベクトルコンテキストステータス">
<title><literal>mstatus</literal> 内のベクトルコンテキストステータス</title>
<simpara>ベクトルコンテキストステータスフィールド <literal>VS</literal> は、
<literal>mstatus[10:9]</literal> に追加され、
<literal>sstatus[10:9]</literal> でシャドウイングされます。
これは、浮動小数点コンテキストステータスフィールドである <literal>FS</literal> と同様に定義されます。</simpara>
<simpara><literal>VS</literal> フィールドがOFFに設定されている場合は、
ベクトル命令を実行しようとしたり、ベクトルCSRにアクセスしようとすると、
不正命令例外が発生します。</simpara>
<simpara><literal>VS</literal> フィールドがInitialまたはCleanに設定されている場合、
ベクトルCSRを含むベクトルの状態を変更する命令を実行すると、<literal>VS</literal> がDirtyに変更されます。
また、実装では、ベクトルの状態が変化していなくても、
いつでも`VS` フィールドをInitialまたはCleanからDirtyに変更することができます。</simpara>
<note>
<simpara><literal>VS</literal> フィールドの正確な設定は最適化に繋がります。
ソフトウェアは通常、コンテキストスワップのオーバーヘッドを減らすためにVSを使用します。</simpara>
</note>
<simpara>実装では、書き込み可能な <literal>misa.v</literal> フィールドを持つことができます。
浮動小数点演算ユニットの処理方法と同様に、
<literal>misa.v</literal> がクリアされていても <literal>mstatus.vs</literal> フィールドが存在する場合があります。</simpara>
<note>
<simpara><literal>misa.v</literal> がクリアされているときに <literal>mstatus.vs</literal> フィールドへのアクセスを許可すると、
ベクトル操作のエミュレーションが可能になり、書き込み可能な <literal>misa.v</literal> を持つシステムでの <literal>mstatus.vs</literal> の処理が簡単になります。</simpara>
</note>
</section>
<section xml:id="_ベクトル型レジスタ_vtype">
<title>ベクトル型レジスタ <literal>vtype</literal></title>
<simpara>読み取り専用のXLEN幅を持つ <emphasis>ベクトル</emphasis> <emphasis>型</emphasis> CSR (<literal>vtype</literal>)は、
ベクトルレジスタファイルの内容を解釈するために使用されるデフォルトの型を提供し、
<literal>vset{i}vl{i}</literal> 命令によってのみ更新することができます。
ベクトル型は、各ベクトルレジスタの要素の構成や、複数のベクトルレジスタをどのようにグループ化するかを決定します。</simpara>
<note>
<simpara><literal>vset{i}vl{i}</literal> 命令による更新のみを許可することで、
<literal>vtype</literal> レジスタの状態の維持が容易になります。</simpara>
</note>
<simpara><literal>vtype</literal> レジスタには、 <literal>vill</literal> 、 <literal>vma</literal> 、 <literal>vta</literal> 、 <literal>vsew[2:0]</literal> 、 <literal>vlmul[2:0]</literal> の5つのフィールドがあります。</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 3, name: 'vlmul[2:0]'},
  {bits: 3, name: 'vsew[2:0]'},
  {bits: 1, name: 'vta'},
  {bits: 1, name: 'vma'},
  {bits: 23, name: 'reserved'},
  {bits: 1, name: 'vill'},
]}</programlisting>
<note>
<simpara>This diagram shows the layout for RV32 systems, whereas in
general <literal>vill</literal> should be at bit XLEN-1.</simpara>
</note>
<table colsep="1" frame="all" rowsep="1">
<title><literal>vtype</literal> register layout</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="62.5*"/>
<thead>
<row>
<entry align="right" valign="top">Bits</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="top"><simpara>XLEN-1</simpara></entry>
<entry align="left" valign="top"><simpara>vill</simpara></entry>
<entry align="left" valign="top"><simpara>Illegal value if set</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>XLEN-2:8</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>Reserved</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>vma</simpara></entry>
<entry align="left" valign="top"><simpara>Vector mask agnostic</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>vta</simpara></entry>
<entry align="left" valign="top"><simpara>Vector tail agnostic</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>5:3</simpara></entry>
<entry align="left" valign="top"><simpara>vsew[2:0]</simpara></entry>
<entry align="left" valign="top"><simpara>Selected element width (SEW) setting</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>2:0</simpara></entry>
<entry align="left" valign="top"><simpara>vlmul[2:0]</simpara></entry>
<entry align="left" valign="top"><simpara>Vector register group multiplier (LMUL) setting</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>ELEN=32 をサポートする小さな実装では、<literal>vtype</literal> には 7 ビットの状態しか必要ありません:
<literal>ma</literal> と <literal>ta</literal> に 2 ビット、<literal>vsew[1:0]</literal> に 2 ビット、
<literal>vlmul[2:0]</literal> に 3 ビットです。
<literal>vill</literal> で表される不正な値は、<literal>vsew[1:0]</literal> の不正な64ビットの組み合わせを使って内部的にエンコードすることができ、
`vill `を保持するための追加のストレージビットを必要としません。</simpara>
</note>
<note>
<simpara>標準ベクトルやカスタムベクトル拡張により、これらのフィールドが拡張され、
より多様なデータ型がサポートされるようになります。</simpara>
</note>
<note>
<simpara>64ビット命令エンコーディングの拡張により、
これらのフィールドを命令エンコーディング内で静的に指定できるようになることが予想されます。</simpara>
</note>
<section xml:id="_ベクトル選択要素幅_vsew20">
<title>ベクトル選択要素幅 <literal>vsew[2:0]</literal></title>
<simpara><literal>vsew</literal> の値は、動的な <emphasis>選択要素幅</emphasis> (SEW)を設定します。
デフォルトでは、ベクトルレジスターは、
VLEN/SEW要素に分割されているとみなされます。</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>vsew[2:0] (選択要素幅) エンコーディング</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="5.8823*"/>
<colspec colname="col_2" colwidth="5.8823*"/>
<colspec colname="col_3" colwidth="5.8823*"/>
<colspec colname="col_4" colwidth="5.8823*"/>
<colspec colname="col_5" colwidth="76.4708*"/>
<thead>
<row>
<entry align="left" nameend="col_3" namest="col_1" valign="top">vsew[2:0]</entry>
<entry align="left" valign="top">SEW</entry>
<entry align="left" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="right" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="right" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="right" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="right" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>128</simpara></entry>
<entry align="right" valign="top"><simpara><emphasis>予約</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>256</simpara></entry>
<entry align="right" valign="top"><simpara><emphasis>予約</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>512</simpara></entry>
<entry align="right" valign="top"><simpara><emphasis>予約</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1024</simpara></entry>
<entry align="right" valign="top"><simpara><emphasis>予約</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>表に示されているように、より大きなSEWをエンコードするために、
より大きな`vsew[2:0]<literal>エンコーディング (`100</literal>～<literal>111</literal>) が使用されることが予想されますが、
このエンコーディングは、現時点では正式には_予約_です。</simpara>
</note>
<table colsep="1" frame="all" rowsep="1">
<title>例: VLEN = 128 ビット</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="right" valign="top">SEW</entry>
<entry align="right" valign="top">ベクトルレジスタあたりの要素数</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="top"><simpara>64</simpara></entry>
<entry align="right" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>32</simpara></entry>
<entry align="right" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>16</simpara></entry>
<entry align="right" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>8</simpara></entry>
<entry align="right" valign="top"><simpara>16</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>サポートされる要素の幅はLMULによって異なりますが、
プロファイルはLMUL=1でサポートされなければならない最小のSEWを義務付けている場合があります。</simpara>
<note>
<simpara>一部の実装では、複数のベクトルレジスターのビットを組み合わせた場合にのみ、
大きなSEWをサポートする場合があります。
大きなSEWに依存しているソフトウェアは、コードを実行できる実装の数を増やすために、
最大のLMULを使用し、したがって最小のベクトルレジスターグループを使用するようにしてください。
また、<literal>vtype</literal> を設定した後に、<literal>vtype</literal> の <literal>vill</literal> ビットをチェックして、
その構成がサポートされているかどうかを確認し、
サポートされていない場合には、代替のコードパスを提供する必要があります。
また、プロファイルでは、各LMULの設定で最小のSEWを義務付けることもできます。</simpara>
</note>
</section>
<section xml:id="_vector_register_grouping_vlmul20">
<title>Vector Register Grouping (<literal>vlmul[2:0]</literal>)</title>
<simpara>Multiple vector registers can be grouped together, so that a single
vector instruction can operate on multiple vector registers.  The term
<emphasis>vector</emphasis> <emphasis>register</emphasis> <emphasis>group</emphasis> is used herein to refer to one or more
vector registers used as a single operand to a vector instruction.
Vector register groups allow double-width or larger elements to be
operated on with the same vector length as selected-width elements.
Vector register groups also provide greater execution efficiency for
longer application vectors.</simpara>
<simpara>The vector length multiplier, <emphasis>LMUL</emphasis>, when greater than 1, represents
the default number of vector registers that are combined to form a
vector register group.  Implementations must support LMUL integer values of 1,2,4,8.</simpara>
<simpara>LMUL can also be a fractional value, reducing the number of bits used
in a vector register.  LMUL can have fractional values 1/2, 1/4, 1/8.
Fractional LMUL is used to increase the number of usable architectural
registers when operating on mixed-width values, by not requiring that
larger-width vectors occupy multiple vector registers. Instead, wider
values can occupy a single vector register and narrower values can
occupy a fraction of a vector register.</simpara>
<simpara>Implementations must support fractional LMUL settings for LMUL ≥
SEW<subscript>LMUL1MIN</subscript>/SEW<subscript>LMUL1MAX</subscript>, where SEW<subscript>LMUL1MIN</subscript> is the narrowest
supported SEW value at LMUL=1 and SEW<subscript>LMUL1MAX</subscript> is the widest
supported SEW value at LMUL=1.  An attempt to set an unsupported SEW
and LMUL configuration sets the <literal>vill</literal> bit in <literal>vtype</literal>.</simpara>
<simpara>For a given supported fractional LMUL setting, implementations must support
SEW settings between SEW<subscript>LMUL1MIN</subscript> and LMUL * SEW<subscript>LMUL1MAX</subscript>, inclusive.</simpara>
<note>
<simpara>Requiring LMUL ≥ SEW<subscript>LMUL1MIN</subscript>/SEW<subscript>LMUL1MAX</subscript> allows software
operating on mixed-width elements to only use a single vector register
to hold the wider elements, with fractional
LMUL used to hold narrower elements.  When LMUL &lt;
SEW<subscript>LMUL1MIN</subscript>/SEW<subscript>LMUL1MAX</subscript>, there is no guarantee an implementation
would have enough bits in the fractional vector register to store at
least one element, as VLEN=SEW<subscript>LMUL1MAX</subscript> is a valid implementation
choice.</simpara>
</note>
<note>
<simpara>The constraint is written using SEW<subscript>LMUL1MAX</subscript> and not ELEN
because some systems might only support larger SEW values for LMUL&gt;1.
Note that in these cases, the constraint ensures that no more than a
single vector register is needed to hold the widest-supported element
that can be held in a single vector register, when code is also
performing operations on narrower widths.</simpara>
</note>
<simpara>The use of <literal>vtype</literal> encodings with LMUL &lt; SEW<subscript>LMUL1MIN</subscript>/SEW<subscript>LMUL1MAX</subscript> is
<emphasis>reserved</emphasis>, but implementations can set <literal>vill</literal> if they do not
support these configurations.</simpara>
<note>
<simpara>Requiring all implementations to set <literal>vill</literal> in this case would
prohibit future use of this case in an extension, so to allow for
a future definition of LMUL&lt;SEW<subscript>LMUL1MIN</subscript>/SEW<subscript>LMUL1MAX</subscript> behavior, we consider
the use of this case to be <emphasis>reserved</emphasis>.</simpara>
</note>
<note>
<simpara>It is recommended that assemblers provide a warning (not an
error) if a <literal>vsetvli</literal> instruction attempts to write an LMUL &lt; SEW<subscript>LMUL1MIN</subscript>/SEW<subscript>LMUL1MAX</subscript>.</simpara>
</note>
<simpara>LMUL is set by the signed <literal>vlmul</literal> field in <literal>vtype</literal> (LMUL =
2<superscript><literal>vlmul[2:0]</literal></superscript>).</simpara>
<simpara>The derived value VLMAX = LMUL*VLEN/SEW represents the maximum number
of elements that can be operated on with a single vector instruction
given the current SEW and LMUL settings as shown in the table below.</simpara>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="7">
<colspec colname="col_1" colwidth="5.8823*"/>
<colspec colname="col_2" colwidth="5.8823*"/>
<colspec colname="col_3" colwidth="5.8823*"/>
<colspec colname="col_4" colwidth="11.7647*"/>
<colspec colname="col_5" colwidth="11.7647*"/>
<colspec colname="col_6" colwidth="29.4117*"/>
<colspec colname="col_7" colwidth="29.412*"/>
<thead>
<row>
<entry align="left" nameend="col_3" namest="col_1" valign="top">vlmul[2:0]</entry>
<entry align="left" valign="top">LMUL</entry>
<entry align="left" valign="top">#groups</entry>
<entry align="left" valign="top">VLMAX</entry>
<entry align="left" valign="top">Registers grouped with register <emphasis>n</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>reserved</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>VLEN/SEW/8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v</literal> <emphasis>n</emphasis> (single register in group)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>VLEN/SEW/4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v</literal> <emphasis>n</emphasis> (single register in group)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>VLEN/SEW/2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v</literal> <emphasis>n</emphasis> (single register in group)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>VLEN/SEW</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v</literal> <emphasis>n</emphasis> (single register in group)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>2*VLEN/SEW</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v</literal> <emphasis>n</emphasis>, <literal>v</literal> <emphasis>n</emphasis>+1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4*VLEN/SEW</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v</literal> <emphasis>n</emphasis>, …​, <literal>v</literal> <emphasis>n</emphasis>+3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>8*VLEN/SEW</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v</literal> <emphasis>n</emphasis>, …​, <literal>v</literal> <emphasis>n</emphasis>+7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When LMUL=2, the vector register group contains vector register <literal>v</literal>
<emphasis>n</emphasis> and vector register <literal>v</literal> <emphasis>n</emphasis>+1, providing twice the vector
length in bits.  Instructions specifying an LMUL=2 vector register group
with an odd-numbered vector register are reserved.</simpara>
<simpara>When LMUL=4, the vector register group contains four vector registers,
and instructions specifying an LMUL=4 vector register group using vector
register numbers that are not multiples of four are reserved.</simpara>
<simpara>When LMUL=8, the vector register group contains eight vector
registers, and instructions specifying an LMUL=8 vector register group
using register numbers that are not multiples of eight are reserved.</simpara>
<simpara>Mask registers are always contained in a single vector register,
regardless of LMUL.</simpara>
</section>
<section xml:id="sec-agnostic">
<title>Vector Tail Agnostic and Vector Mask Agnostic <literal>vta</literal> and <literal>vma</literal></title>
<simpara>These two bits modify the behavior of destination tail elements and
destination inactive masked-off elements respectively during the
execution of vector instructions.  The tail and inactive sets contain
element positions that are not receiving new results during a vector
operation, as defined in Section <xref linkend="sec-inactive-defs"/>.</simpara>
<simpara>All systems must support all four options:</simpara>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="12.5*"/>
<colspec colname="col_3" colwidth="37.5*"/>
<colspec colname="col_4" colwidth="37.5*"/>
<thead>
<row>
<entry align="left" valign="top"><literal>vta</literal></entry>
<entry align="left" valign="top"><literal>vma</literal></entry>
<entry align="left" valign="top">Tail Elements</entry>
<entry align="left" valign="top">Inactive Elements</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>undisturbed</simpara></entry>
<entry align="left" valign="top"><simpara>undisturbed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>undisturbed</simpara></entry>
<entry align="left" valign="top"><simpara>agnostic</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>agnostic</simpara></entry>
<entry align="left" valign="top"><simpara>undisturbed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>agnostic</simpara></entry>
<entry align="left" valign="top"><simpara>agnostic</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When a set is marked undisturbed, the corresponding set of destination
elements in a vector register group retain the value they previously
held.   Mask destination values are always treated as tail-agnostic,
regardless of the setting of <literal>vta</literal>.</simpara>
<simpara>When a set is marked agnostic, the corresponding set of destination
elements in any vector destination operand can either retain the value
they previously held, or are overwritten with 1s.  Within a single vector
instruction, each destination element can be either left undisturbed
or overwritten with 1s, in any combination, and the pattern of
undisturbed or overwritten with 1s is not required to be deterministic
when the instruction is executed with the same inputs.  In addition,
except for mask load instructions, any element in the tail of a mask
result can also be written with the value the mask-producing operation
would have calculated with <literal>vl</literal>=VLMAX.</simpara>
<note>
<simpara>The agnostic policy was added to accommodate machines with vector
register renaming, and/or that have deeply temporal vector registers.
With an undisturbed policy, all elements would have to be read from
the old physical destination vector register to be copied into the new
physical destination vector register.  This causes an inefficiency
when these inactive or tail values are not required for subsequent
calculations.</simpara>
</note>
<note>
<simpara>Mask tails are always treated as agnostic to reduce complexity
of managing mask data, which can be written at bit granularity.  There
appears to be little software need to support tail-undisturbed for
mask register values.  Allowing mask-generating instructions to write
back the result of the instruction avoids the need for logic to mask
out the tail, except mask loads cannot write memory values to
destination mask tails as this would imply accessing memory past
software intent.</simpara>
</note>
<note>
<simpara>The value of all 1s instead of all 0s was chosen for the
overwrite value to discourage software developers from depending on
the value written.</simpara>
</note>
<note>
<simpara>A simple in-order implementation can ignore the settings and
simply execute all vector instructions using the undisturbed
policy. The <literal>vta</literal> and <literal>vma</literal> state bits must still be provided in
<literal>vtype</literal> for compatibility and to support thread migration.</simpara>
</note>
<note>
<simpara>An out-of-order implementation can choose to implement
tail-agnostic + mask-agnostic using tail-agnostic + mask-undisturbed
to reduce implementation complexity.</simpara>
</note>
<note>
<simpara>The definition of agnostic result policy is left loose to
accommodate migrating application threads between harts on a small
in-order core (which probably leaves agnostic regions undisturbed) and
harts on a larger out-of-order core with register renaming (which
probably overwrites agnostic elements with 1s).  As it might be
necessary to restart in the middle, we allow arbitrary mixing of
agnostic policies within a single vector instruction.  This allowed
mixing of policies also enables implementations that might change
policies for different granules of a vector register, for example,
using undisturbed within a granule that is actively operated on but
renaming to all 1s for granules in the tail.</simpara>
</note>
<simpara>The assembly syntax adds two flags to the <literal>vsetvli</literal> instruction:</simpara>
<screen> ta   # Tail agnostic
 tu   # Tail undisturbed
 ma   # Mask agnostic
 mu   # Mask undisturbed

 vsetvli t0, a0, e32, m4, ta, ma   # Tail agnostic, mask agnostic
 vsetvli t0, a0, e32, m4, tu, ma   # Tail undisturbed, mask agnostic
 vsetvli t0, a0, e32, m4, ta, mu   # Tail agnostic, mask undisturbed
 vsetvli t0, a0, e32, m4, tu, mu   # Tail undisturbed, mask undisturbed</screen>
<note>
<simpara>To maintain backward compatibility in the short term and reduce
software churn in the move to 0.9, when these flags are not specified
on a <literal>vsetvli</literal>, they should default to
mask-undisturbed/tail-undisturbed.  The use of <literal>vsetvli</literal> without these
flags should be deprecated, however, such that the specifying a flag
setting becomes mandatory.  If anything, the default should be
tail-agnostic/mask-agnostic, so software has to specify when it cares
about the non-participating elements, but given the historical meaning
of the instruction prior to introduction of these flags, it is safest
to always require them in future assembly code.</simpara>
</note>
</section>
<section xml:id="_vector_type_illegal_vill">
<title>Vector Type Illegal <literal>vill</literal></title>
<simpara>The <literal>vill</literal> bit is used to encode that a previous <literal>vset{i}vl{i}</literal>
instruction attempted to write an unsupported value to <literal>vtype</literal>.</simpara>
<note>
<simpara>The <literal>vill</literal> bit is held in bit XLEN-1 of the CSR to support
checking for illegal values with a branch on the sign bit.</simpara>
</note>
<simpara>If the <literal>vill</literal> bit is set, then any attempt to execute a vector instruction
that depends upon <literal>vtype</literal> will raise an illegal-instruction exception.</simpara>
<note>
<simpara><literal>vset{i}vl{i}</literal> and whole-register loads, stores, and moves do not depend
upon <literal>vtype</literal>.</simpara>
</note>
<simpara>When the <literal>vill</literal> bit is set, the other XLEN-1 bits in <literal>vtype</literal> shall be
zero.</simpara>
</section>
</section>
<section xml:id="_vector_length_register_vl">
<title>Vector Length Register <literal>vl</literal></title>
<simpara>The <emphasis>XLEN</emphasis>-bit-wide read-only <literal>vl</literal> CSR can only be updated by the
<literal>vset{i}vl{i}</literal> instructions, and the <emphasis>fault-only-first</emphasis> vector load
instruction variants.</simpara>
<simpara>The <literal>vl</literal> register holds an unsigned integer specifying the number of
elements to be updated with results from a vector instruction, as
further detailed in Section <xref linkend="sec-inactive-defs"/>.</simpara>
<note>
<simpara>The number of bits implemented in <literal>vl</literal> depends on the
implementation’s maximum vector length of the smallest supported
type. The smallest vector implementation with VLEN=32 and supporting
SEW=8 would need at least six bits in <literal>vl</literal> to hold the values 0-32
(VLEN=32, with LMUL=8 and SEW=8, yields VLMAX=32).</simpara>
</note>
</section>
<section xml:id="_vector_byte_length_vlenb">
<title>Vector Byte Length <literal>vlenb</literal></title>
<simpara>The <emphasis>XLEN</emphasis>-bit-wide read-only CSR <literal>vlenb</literal> holds the value VLEN/8,
i.e., the vector register length in bytes.</simpara>
<note>
<simpara>The value in <literal>vlenb</literal> is a design-time constant in any
implementation.</simpara>
</note>
<note>
<simpara>Without this CSR, several instructions are needed to calculate
VLEN in bytes, and the code has to disturb current <literal>vl</literal> and <literal>vtype</literal>
settings which require them to be saved and restored.</simpara>
</note>
</section>
<section xml:id="_vector_start_index_csr_vstart">
<title>Vector Start Index CSR <literal>vstart</literal></title>
<simpara>The <literal>vstart</literal> read-write CSR specifies the index of the first element
to be executed by a vector instruction, as described in Section
<xref linkend="sec-inactive-defs"/>.</simpara>
<simpara>Normally, <literal>vstart</literal> is only written by hardware on a trap on a vector
instruction, with the <literal>vstart</literal> value representing the element on which
the trap was taken (either a synchronous exception or an asynchronous
interrupt), and at which execution should resume after a resumable
trap is handled.</simpara>
<simpara>All vector instructions are defined to begin execution with the
element number given in the <literal>vstart</literal> CSR, leaving earlier elements in
the destination vector undisturbed, and to reset the <literal>vstart</literal> CSR to
zero at the end of execution.</simpara>
<note>
<simpara>All vector instructions, including <literal>vset{i}vl{i}</literal>, reset the <literal>vstart</literal>
CSR to zero.</simpara>
</note>
<simpara><literal>vstart</literal> is not modified by vector instructions that raise illegal-instruction
exceptions.</simpara>
<simpara>The <literal>vstart</literal> CSR is defined to have only enough writable bits to hold
the largest element index (one less than the maximum VLMAX).</simpara>
<note>
<simpara>The maximum vector length is obtained with the largest LMUL
setting (8) and the smallest SEW setting (8), so VLMAX_max = 8*VLEN/8
= VLEN.  For example, for VLEN=256, <literal>vstart</literal> would have 8 bits to
represent indices from 0 through 255.</simpara>
</note>
<simpara>The use of <literal>vstart</literal> values greater than the largest element index for
the current SEW setting is reserved.</simpara>
<note>
<simpara>It is recommended that implementations trap if <literal>vstart</literal> is out
of bounds.  It is not required to trap, as a possible future use of
upper <literal>vstart</literal> bits is to store imprecise trap information.</simpara>
</note>
<simpara>The <literal>vstart</literal> CSR is writable by unprivileged code, but non-zero
<literal>vstart</literal> values may cause vector instructions to run substantially
slower on some implementations, so <literal>vstart</literal> should not be used by
application programmers.  A few vector instructions cannot be
executed with a non-zero <literal>vstart</literal> value and will raise an illegal
instruction exception as defined below.</simpara>
<note>
<simpara>Making <literal>vstart</literal> visible to unprivileged code supports user-level
threading libraries.</simpara>
</note>
<simpara>Implementations are permitted to raise illegal instruction exceptions when
attempting to execute a vector instruction with a value of <literal>vstart</literal> that the
implementation can never produce when executing that same instruction with
the same <literal>vtype</literal> setting.</simpara>
<note>
<simpara>For example, some implementations will never take interrupts during
execution of a vector arithmetic instruction, instead waiting until the
instruction completes to take the interrupt.  Such implementations are
permitted to raise an illegal instruction exception when attempting to execute
a vector arithmetic instruction when <literal>vstart</literal> is nonzero.</simpara>
</note>
<note>
<simpara>When migrating a software thread between two harts with
different microarchitectures, the <literal>vstart</literal> value might not be
supported by the new hart microarchitecture.  The runtime on the
receiving hart might then have to emulate instruction execution to a
supported vstart element position.  Alternatively, migration events
can be constrained to only occur at mutually supported <literal>vstart</literal>
locations.</simpara>
</note>
</section>
<section xml:id="_vector_fixed_point_rounding_mode_register_vxrm">
<title>Vector Fixed-Point Rounding Mode Register <literal>vxrm</literal></title>
<simpara>The vector fixed-point rounding-mode register holds a two-bit
read-write rounding-mode field.  The vector fixed-point rounding-mode
is given a separate CSR address to allow independent access, but is
also reflected as a field in <literal>vcsr</literal>.</simpara>
<simpara>The fixed-point rounding algorithm is specified as follows.
Suppose the pre-rounding result is <literal>v</literal>, and <literal>d</literal> bits of that result are to be
rounded off.
Then the rounded result is <literal>(v &gt;&gt; d) + r</literal>, where <literal>r</literal> depends on the rounding
mode as specified in the following table.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>vxrm encoding</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="4.7619*"/>
<colspec colname="col_2" colwidth="4.7619*"/>
<colspec colname="col_3" colwidth="19.0476*"/>
<colspec colname="col_4" colwidth="47.619*"/>
<colspec colname="col_5" colwidth="23.8096*"/>
<thead>
<row>
<entry align="left" nameend="col_2" namest="col_1" valign="top"><literal>vxrm[1:0]</literal></entry>
<entry align="left" valign="top">Abbreviation</entry>
<entry align="left" valign="top">Rounding Mode</entry>
<entry align="left" valign="top">Rounding increment, <literal>r</literal></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>rnu</simpara></entry>
<entry align="left" valign="top"><simpara>round-to-nearest-up (add +0.5 LSB)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v[d-1]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>rne</simpara></entry>
<entry align="left" valign="top"><simpara>round-to-nearest-even</simpara></entry>
<entry align="left" valign="top"><simpara><literal>v[d-1] &amp; (v[d-2:0]≠0 | v[d])</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>rdn</simpara></entry>
<entry align="left" valign="top"><simpara>round-down (truncate)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>rod</simpara></entry>
<entry align="left" valign="top"><simpara>round-to-odd (OR bits into LSB, aka "jam")</simpara></entry>
<entry align="left" valign="top"><simpara><literal>!v[d] &amp; v[d-1:0]≠0</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The rounding functions:</simpara>
<screen>roundoff_unsigned(v, d) = (unsigned(v) &gt;&gt; d) + r
roundoff_signed(v, d) = (signed(v) &gt;&gt; d) + r</screen>
<simpara>are used to represent this operation in the instruction descriptions below.</simpara>
<simpara><literal>vxrm[XLEN-1:2]</literal> should be written as zeros.</simpara>
<note>
<simpara>A new rounding mode can be set while saving the original
rounding mode using a single <literal>csrwi</literal> instruction.</simpara>
</note>
</section>
<section xml:id="_vector_fixed_point_saturation_flag_vxsat">
<title>Vector Fixed-Point Saturation Flag <literal>vxsat</literal></title>
<simpara>The <literal>vxsat</literal> CSR holds a single read-write bit that indicates if a
fixed-point instruction has had to saturate an output value to fit
into a destination format.</simpara>
<simpara>The <literal>vxsat</literal> bit is mirrored in <literal>vcsr</literal>.</simpara>
</section>
<section xml:id="_vector_control_and_status_register_vcsr">
<title>Vector Control and Status Register <literal>vcsr</literal></title>
<simpara>The <literal>vxrm</literal> and <literal>vxsat</literal> separate CSRs can also be accessed via fields
in the vector control and status CSR, <literal>vcsr</literal>.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>vcsr layout</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="62.5*"/>
<thead>
<row>
<entry align="right" valign="top">Bits</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="top"><simpara>2:1</simpara></entry>
<entry align="left" valign="top"><simpara>vxrm[1:0]</simpara></entry>
<entry align="left" valign="top"><simpara>Fixed-point rounding mode</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vxsat</simpara></entry>
<entry align="left" valign="top"><simpara>Fixed-point accrued saturation flag</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="_state_of_vector_extension_at_reset">
<title>State of Vector Extension at Reset</title>
<simpara>The vector extension must have a consistent state at reset.  In
particular, <literal>vtype</literal> and <literal>vl</literal> must have values that can be read and
then restored with a single <literal>vsetvl</literal> instruction.</simpara>
<note>
<simpara>It is recommended that at reset, <literal>vtype.vill</literal> is set, the
remaining bits in <literal>vtype</literal> are zero, and <literal>vl</literal> is set to zero.</simpara>
</note>
<simpara>The <literal>vstart</literal>, <literal>vxrm</literal>, <literal>vxsat</literal> CSRs can have arbitrary values at reset.</simpara>
<note>
<simpara>Any use of the vector unit will require an initial <literal>vset{i}vl{i}</literal>,
which will reset <literal>vstart</literal>.  The <literal>vxrm</literal> and <literal>vxsat</literal> fields should be
reset explicitly in software before use.</simpara>
</note>
<simpara>The vector registers can have arbitrary values at reset.</simpara>
</section>
</section>
<section xml:id="_mapping_of_vector_elements_to_vector_register_state">
<title>Mapping of Vector Elements to Vector Register State</title>
<simpara>The following diagrams illustrate how different width elements are
packed into the bytes of a vector register depending on the current
SEW and LMUL settings, as well as implementation VLEN.  Elements are
packed into each vector register with the least-significant byte in
the lowest-numbered bits.</simpara>
<section xml:id="_mapping_for_lmul_1">
<title>Mapping for LMUL = 1</title>
<simpara>When LMUL=1, elements are simply packed in order from the
least-significant to most-significant bits of the vector register.</simpara>
<note>
<simpara>To increase readability, vector register layouts are drawn with
bytes ordered from right to left with increasing byte address.  Bits
within an element are numbered in a little-endian format with
increasing bit index from right to left corresponding to increasing
magnitude.</simpara>
</note>
<screen>LMUL=1 examples.

The element index is given in hexadecimal and is shown placed at the
least-significant byte of the stored element.


 VLEN=32b

 Byte         3 2 1 0

 SEW=8b       3 2 1 0
 SEW=16b        1   0
 SEW=32b            0

 VLEN=64b

 Byte        7 6 5 4 3 2 1 0

 SEW=8b      7 6 5 4 3 2 1 0
 SEW=16b       3   2   1   0
 SEW=32b           1       0
 SEW=64b                   0

 VLEN=128b

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b      F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b       7   6   5   4   3   2   1   0
 SEW=32b           3       2       1       0
 SEW=64b                   1               0
 SEW=128b                                  0

 VLEN=256b

 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b   1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b     F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0
 SEW=32b         7       6       5       4       3       2       1       0
 SEW=64b                 3               2               1               0
 SEW=128b                                1                               0</screen>
</section>
<section xml:id="_mapping_for_lmul_1_2">
<title>Mapping for LMUL &lt; 1</title>
<simpara>When LMUL &lt; 1, only the first LMUL*VLEN/SEW elements in the vector
register are used.  The remaining space in the vector register is
treated as part of the tail, and hence must obey the vta setting.</simpara>
<screen> Example, VLEN=128b, LMUL=1/4

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b      - - - - - - - - - - - - 3 2 1 0
 SEW=16b       -   -   -   -   -   -   1   0
 SEW=32b           -       -       -       0</screen>
</section>
<section xml:id="_mapping_for_lmul_1_3">
<title>Mapping for LMUL &gt; 1</title>
<simpara>When vector registers are grouped, the elements of the vector register
group are striped across the constituent vector registers.  The
elements are packed contiguously in element order in each vector
register in the group, moving to the next highest-numbered vector
register in the group once each vector register is filled.</simpara>
<screen> LMUL &gt; 1 examples

 VLEN=32b, SEW=8b, LMUL=2

 Byte         3 2 1 0
 v2*n         3 2 1 0
 v2*n+1       7 6 5 4

 VLEN=32b, SEW=16b, LMUL=2

 Byte         3 2 1 0
 v2*n           1   0
 v2*n+1         3   2

 VLEN=32b, SEW=16b, LMUL=4

 Byte         3 2 1 0
 v4*n           1   0
 v4*n+1         3   2
 v4*n+2         5   4
 v4*n+3         7   6

 VLEN=32b, SEW=32b, LMUL=4

 Byte         3 2 1 0
 v4*n               0
 v4*n+1             1
 v4*n+2             2
 v4*n+3             3

 VLEN=64b, SEW=32b, LMUL=2

 Byte         7 6 5 4 3 2 1 0
 v2*n               1       0
 v2*n+1             3       2

 VLEN=64b, SEW=32b, LMUL=4

 Byte         7 6 5 4 3 2 1 0
 v4*n               1       0
 v4*n+1             3       2
 v4*n+2             5       4
 v4*n+3             7       6

 VLEN=128b, SEW=32b, LMUL=2

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0
 v2*n              3       2       1       0
 v2*n+1            7       6       5       4

 VLEN=128b, SEW=32b, LMUL=4

 Byte          F E D C B A 9 8 7 6 5 4 3 2 1 0
 v4*n                3       2       1       0
 v4*n+1              7       6       5       4
 v4*n+2              B       A       9       8
 v4*n+3              F       E       D       C</screen>
</section>
<section xml:id="_mapping_across_mixed_width_operations">
<title>Mapping across Mixed-Width Operations</title>
<simpara>The vector ISA is designed to support mixed-width operations without
requiring explicit additional rearrangement instructions.  The
recommended software strategy when operating on vectors of different
precision values is to modify <literal>vtype</literal> dynamically to keep SEW/LMUL
constant (and hence VLMAX constant).</simpara>
<simpara>The following example shows four different packed element widths (8b,
16b, 32b, 64b) in a VLEN=128b implementation.  The vector register
grouping factor (LMUL) is increased by the relative element size such
that each group can hold the same number of vector elements (VLMAX=8
in this example) to simplify stripmining code.</simpara>
<screen>Example VLEN=128b, with SEW/LMUL=16

Byte      F E D C B A 9 8 7 6 5 4 3 2 1 0
vn        - - - - - - - - 7 6 5 4 3 2 1 0  SEW=8b, LMUL=1/2

vn          7   6   5   4   3   2   1   0  SEW=16b, LMUL=1

v2*n            3       2       1       0  SEW=32b, LMUL=2
v2*n+1          7       6       5       4

v4*n                    1               0  SEW=64b, LMUL=4
v4*n+1                  3               2
v4*n+2                  5               4
v4*n+3                  7               6</screen>
<simpara>The following table shows each possible constant SEW/LMUL operating
point for loops with mixed-width operations.  Each column represents a
constant SEW/LMUL operating point.  Entries in table are the LMUL
values that yield that column’s SEW/LMUL value for the datawidth on
that row.  In each column, an LMUL setting for a datawidth indicates
that it can be aligned with the other datawidths in the same column
that also have an LMUL setting, such that all have the same VLMAX.</simpara>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="15">
<colspec colname="col_1" colwidth="6.6666*"/>
<colspec colname="col_2" colwidth="6.6666*"/>
<colspec colname="col_3" colwidth="6.6666*"/>
<colspec colname="col_4" colwidth="6.6666*"/>
<colspec colname="col_5" colwidth="6.6666*"/>
<colspec colname="col_6" colwidth="6.6666*"/>
<colspec colname="col_7" colwidth="6.6666*"/>
<colspec colname="col_8" colwidth="6.6666*"/>
<colspec colname="col_9" colwidth="6.6666*"/>
<colspec colname="col_10" colwidth="6.6666*"/>
<colspec colname="col_11" colwidth="6.6666*"/>
<colspec colname="col_12" colwidth="6.6666*"/>
<colspec colname="col_13" colwidth="6.6666*"/>
<colspec colname="col_14" colwidth="6.6666*"/>
<colspec colname="col_15" colwidth="6.6676*"/>
<thead>
<row>
<entry align="left" valign="top">SEW/LMUL</entry>
<entry align="left" valign="top">1</entry>
<entry align="left" valign="top">2</entry>
<entry align="left" valign="top">4</entry>
<entry align="left" valign="top">8</entry>
<entry align="left" valign="top">16</entry>
<entry align="left" valign="top">32</entry>
<entry align="left" valign="top">64</entry>
<entry align="left" valign="top">128</entry>
<entry align="left" valign="top">256</entry>
<entry align="left" valign="top">512</entry>
<entry align="left" valign="top">1024</entry>
<entry align="left" valign="top">2048</entry>
<entry align="left" valign="top">4096</entry>
<entry align="left" valign="top">8192</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>SEW=   8</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>SEW=  16</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>SEW=  32</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>SEW=  64</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>SEW= 128</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>SEW= 256</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>SEW= 512</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>SEW=1024</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1/2</simpara></entry>
<entry align="left" valign="top"><simpara>1/4</simpara></entry>
<entry align="left" valign="top"><simpara>1/8</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Larger LMUL settings can also used to simply increase vector length to
reduce instruction fetch and dispatch overheads in cases where fewer
vector register groups are needed.</simpara>
<note>
<simpara>The SEW/LMUL values of 2048 and greater are shown in the table
for completeness but they do not add a useful operating point as they
use less than the full register capacity and do not enable more
architectural registers.</simpara>
</note>
</section>
<section xml:id="_mapping_for_lmul_1_and_elen_vlen">
<title>Mapping for LMUL &gt; 1 and ELEN &gt; VLEN</title>
<simpara>If vector registers are grouped to support larger SEW, with ELEN &gt;
VLEN, the vector registers in the group are concatenated to form a
single array of bytes, with the lowest-numbered register in the group
holding the lowest-addressed bytes from the memory layout.</simpara>
<screen> LMUL &gt; 1 ELEN&gt;VLEN, examples

 VLEN=32b, SEW=64b, LMUL=2

 Byte         3 2 1 0
 v2*n               0
 v2*n+1

 VLEN=32b, SEW=64b, LMUL=4

 Byte         3 2 1 0
 v4*n               0
 v4*n+1
 v4*n+2             1
 v4*n+3

 VLEN=32b, SEW=64b, LMUL=8

 Byte         3 2 1 0
 v8*n               0
 v8*n+1
 v8*n+2             1
 v8*n+3
 v8*n+4             2
 v8*n+5
 v8*n+6             3
 v8*n+7</screen>
</section>
<section xml:id="sec-mask-register-layout">
<title>Mask Register Layout</title>
<simpara>A vector mask occupies only one vector register regardless of SEW and
LMUL.  Each element is allocated a single mask bit in a mask vector
register.</simpara>
<note>
<simpara>Earlier designs (pre-0.9) had a varying number of bits per mask
value (MLEN).  In the 0.9 design, MLEN=1.</simpara>
</note>
<section xml:id="_mask_element_locations">
<title>Mask Element Locations</title>
<simpara>The mask bit for element <emphasis>i</emphasis> is located in bit <emphasis>i</emphasis> of the mask
register, independent of SEW or LMUL.</simpara>
<screen> VLEN=32b

          Byte    3   2   1   0
 LMUL=1,SEW=8b
                  3   2   1   0  Element
                [03][02][01][00] Mask bit position in decimal

 LMUL=2,SEW=16b
                      1       0
                    [01]    [00]
                      3       2
                    [03]    [02]

 LMUL=4,SEW=32b               0
                            [00]
                              1
                            [01]
                              2
                            [02]
                              3
                            [03]</screen>
<screen> LMUL=2,SEW=8b
                  3   2   1   0
                [03][02][01][00]
                  7   6   5   4
                [07][06][05][04]

 LMUL=8,SEW=32b
                              0
                            [00]
                              1
                            [01]
                              2
                            [02]
                              3
                            [03]
                              4
                            [04]
                              5
                            [05]
                              6
                            [06]
                              7
                            [07]

 LMUL=8,SEW=8b
                  3   2   1   0
                [03][02][01][00]
                  7   6   5   4
                [07][06][05][04]
                  B   A   9   8
                [11][10][09][08]
                  F   E   D   C
                [15][14][13][12]
                 13  12  11  10
                [19][18][17][16]
                 17  16  15  14
                [23][22][21][20]
                 1B  1A  19  18
                [27][26][25][24]
                 1F  1E  1D  1C
                [31][30][29][28]</screen>
</section>
</section>
</section>
<section xml:id="_vector_instruction_formats">
<title>Vector Instruction Formats</title>
<simpara>The instructions in the vector extension fit under two existing major
opcodes (LOAD-FP and STORE-FP) and one new major opcode (OP-V).</simpara>
<simpara>Vector loads and stores are encoded within the scalar floating-point
load and store major opcodes (LOAD-FP/STORE-FP).  The vector load and
store encodings repurpose a portion of the standard scalar
floating-point load/store 12-bit immediate field to provide further
vector instruction encoding, with bit 25 holding the standard vector
mask bit (see <xref linkend="sec-vector-mask-encoding"/>).</simpara>
<simpara>Format for Vector Load Instructions under LOAD-FP major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x7, attr: 'VL* unit-stride'},
  {bits: 5, name: 'vd', attr: 'destination of load', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'lumop'},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x7, attr: 'VLS* strided'},
  {bits: 5, name: 'vd', attr: 'destination of load', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'rs2', attr: 'stride', type: 4},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x7, attr: 'VLX* indexed'},
  {bits: 5, name: 'vd', attr: 'destination of load', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'vs2', attr: 'address offsets', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<simpara>Format for Vector Store Instructions under STORE-FP major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x27, attr: 'VS* unit-stride'},
  {bits: 5, name: 'vs3', attr: 'store data', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'sumop'},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x27, attr: 'VSS* strided'},
  {bits: 5, name: 'vs3', attr: 'store data', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'rs2', attr: 'stride', type: 4},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x27, attr: 'VSX* indexed'},
  {bits: 5, name: 'vs3', attr: 'store data', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'vs2', attr: 'address offsets', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<simpara>Formats for Vector Arithmetic Instructions under OP-V major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPIVV'},
  {bits: 5, name: 'vd', type: 2},
  {bits: 3, name: 0},
  {bits: 5, name: 'vs1', type: 2},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPFVV'},
  {bits: 5, name: 'vd / rd', type: 7},
  {bits: 3, name: 1},
  {bits: 5, name: 'vs1', type: 2},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPMVV'},
  {bits: 5, name: 'vd / rd', type: 7},
  {bits: 3, name: 2},
  {bits: 5, name: 'vs1', type: 2},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: ['OPIVI']},
  {bits: 5, name: 'vd', type: 2},
  {bits: 3, name: 3},
  {bits: 5, name: 'simm5', type: 5},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPIVX'},
  {bits: 5, name: 'vd', type: 2},
  {bits: 3, name: 4},
  {bits: 5, name: 'rs1', type: 4},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPFVF'},
  {bits: 5, name: 'vd', type: 2},
  {bits: 3, name: 5},
  {bits: 5, name: 'rs1', type: 4},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPMVX'},
  {bits: 5, name: 'vd / rd', type: 7},
  {bits: 3, name: 6},
  {bits: 5, name: 'rs1', type: 4},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<simpara>Formats for Vector Configuration Instructions under OP-V major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7,  name: 0x57, attr: 'vsetvli'},
  {bits: 5,  name: 'rd', type: 4},
  {bits: 3,  name: 7},
  {bits: 5,  name: 'rs1', type: 4},
  {bits: 11, name: 'zimm[10:0]', type: 5},
  {bits: 1,  name: '0'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7,  name: 0x57, attr: 'vsetivli'},
  {bits: 5,  name: 'rd', type: 4},
  {bits: 3,  name: 7},
  {bits: 5,  name: 'uimm[4:0]', type: 5},
  {bits: 10, name: 'zimm[9:0]', type: 5},
  {bits: 1, name: '1'},
  {bits: 1,  name: '1'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7,  name: 0x57, attr: 'vsetvl'},
  {bits: 5,  name: 'rd', type: 4},
  {bits: 3,  name: 7},
  {bits: 5,  name: 'rs1', type: 4},
  {bits: 5,  name: 'rs2', type: 4},
  {bits: 6,  name: 0x1000},
  {bits: 1,  name: 1},
]}</programlisting>
<simpara>Vector instructions can have scalar or vector source operands and
produce scalar or vector results, and most vector instructions can be
performed either unconditionally or conditionally under a mask.</simpara>
<simpara>Vector loads and stores move bit patterns between vector register
elements and memory.  Vector arithmetic instructions operate on values
held in vector register elements.</simpara>
<section xml:id="_scalar_operands">
<title>Scalar Operands</title>
<simpara>Scalar operands can be immediates, or taken from the <literal>x</literal> registers,
the <literal>f</literal> registers, or element 0 of a vector register.  Scalar results
are written to an <literal>x</literal> or <literal>f</literal> register or to element 0 of a vector
register.  Any vector register can be used to hold a scalar regardless
of the current LMUL setting.</simpara>
<note>
<simpara>In a change from v0.6, the floating-point registers no longer
overlay the vector registers and scalars can now come from the integer
or floating-point registers.  Not overlaying the <literal>f</literal> registers reduces
vector register pressure, avoids interactions with the standard
calling convention, simplifies high-performance scalar floating-point
design, and provides compatibility with the Zfinx ISA option.
Overlaying <literal>f</literal> with <literal>v</literal> would provide the advantage of lowering the
number of state bits in some implementations, but complicates
high-performance designs and would prevent compatibility with the
Zfinx ISA option.</simpara>
</note>
</section>
<section xml:id="_vector_operands">
<title>Vector Operands</title>
<simpara>Each vector operand has an <emphasis>effective</emphasis> <emphasis>element</emphasis> <emphasis>width</emphasis> (EEW) and an
<emphasis>effective</emphasis> LMUL (EMUL) that is used to determine the size and
location of all the elements within a vector register group.  By
default, for most operands of most instructions, EEW=SEW and
EMUL=LMUL.</simpara>
<simpara>Some vector instructions have source and destination vector operands
with the same number of elements but different widths, so that EEW and
EMUL differ from SEW and LMUL respectively but EEW/EMUL = SEW/LMUL.
For example, most widening arithmetic instructions have a source group
with EEW=SEW and EMUL=LMUL but destination group with EEW=2*SEW and
EMUL=2*LMUL.  Narrowing instructions have a source operand that has
EEW=2*SEW and EMUL=2*LMUL but destination where EEW=SEW and EMUL=LMUL.</simpara>
<simpara>Vector operands or results may occupy one or more vector registers
depending on EMUL, but are always specified using the lowest-numbered
vector register in the group.  Using other than the lowest-numbered
vector register to specify a vector register group is a reserved
encoding.</simpara>
<simpara>A destination vector register group can overlap a source vector register
group only if one of the following holds:</simpara>
<itemizedlist>
<listitem>
<simpara>The destination EEW equals the source EEW.</simpara>
</listitem>
<listitem>
<simpara>The destination EEW is smaller than the source EEW and the overlap is in
the lowest-numbered part of the source register group (e.g., when LMUL=1,
<literal>vnsrl.wi v0, v0, 3</literal> is legal, but a destination of <literal>v1</literal> is not).</simpara>
</listitem>
<listitem>
<simpara>The destination EEW is greater than the source EEW, the source EMUL is
at least 1, and the overlap is in the highest-numbered part of the
destination register group (e.g., when LMUL=8, <literal>vzext.vf4 v0, v6</literal> is legal,
but a source of <literal>v0</literal>, <literal>v2</literal>, or <literal>v4</literal> is not).</simpara>
</listitem>
</itemizedlist>
<simpara>For the purpose of register group overlap constraints, mask elements have
EEW=1.</simpara>
<simpara>The largest vector register group used by an instruction can not be
greater than 8 vector registers (i.e., EMUL≤8), and if a vector
instruction would require greater than 8 vector registers in a group,
the instruction encoding is reserved.  For example, a widening
operation that produces a widened vector register group result when
LMUL=8 is reserved as this would imply a result EMUL=16.</simpara>
<simpara>Widened scalar values, e.g., results from widening reduction
operations, are held in the first element of a vector register and
have EMUL=1.</simpara>
<note>
<simpara>Current reduction operations are defined to hold input and
output values in a single vector register, with implicit EMUL of 1, so
cannot accommodate using a vector register group to hold a wide scalar
reduction result.  This would require an independent parameter to give
the EMUL for the scalar reduction element.</simpara>
</note>
</section>
<section xml:id="_vector_masking">
<title>Vector Masking</title>
<simpara>Masking is supported on many vector instructions.  Element operations
that are masked off (inactive) never generate exceptions.  The
destination vector register elements corresponding to masked-off
elements are handled with either a mask-undisturbed or mask-agnostic
policy depending on the setting of the <literal>vma</literal> bit in <literal>vtype</literal> (Section
<xref linkend="sec-agnostic"/>).</simpara>
<simpara>The mask value used to control execution of a masked vector
instruction is always supplied by vector register <literal>v0</literal>.</simpara>
<note>
<simpara>Future vector extensions may provide longer instruction
encodings with space for a full mask register specifier.</simpara>
</note>
<simpara>The destination vector register group for a masked vector instruction
cannot overlap the source mask register (<literal>v0</literal>), unless the destination
vector register is being written with a mask value (e.g., comparisons)
or the scalar result of a reduction.  These instruction encodings are
reserved.</simpara>
<note>
<simpara>This constraint supports restart with a non-zero <literal>vstart</literal> value.</simpara>
</note>
<note>
<simpara>Some masked instructions that target <literal>v0</literal> which were legal in
v0.8 are illegal with the new MLEN=1 mask layout for v1.0. For
example, <literal>vadd.vv v0, v1, v2, v0.m</literal> is now always illegal; previously,
it was legal for LMUL=1.</simpara>
</note>
<simpara>Other vector registers can be used to hold working mask values, and
mask vector logical operations are provided to perform predicate
calculations. <anchor xml:id="sec-mask-vector-logical" xreflabel="[sec-mask-vector-logical]"/></simpara>
<simpara>As specified in Section <xref linkend="sec-agnostic"/>, mask destination values are
always treated as tail-agnostic, regardless of the setting of <literal>vta</literal>.</simpara>
<section xml:id="sec-vector-mask-encoding">
<title>Mask Encoding</title>
<simpara>Where available, masking is encoded in a single-bit <literal>vm</literal> field in the
 instruction (<literal>inst[25]</literal>).</simpara>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="6.25*"/>
<colspec colname="col_2" colwidth="93.75*"/>
<thead>
<row>
<entry align="left" valign="top">vm</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vector result, only where v0.mask[i] = 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>unmasked</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>In earlier proposals, <literal>vm</literal> was a two-bit field <literal>vm[1:0]</literal> that
provided both true and complement masking using <literal>v0</literal> as well as
encoding scalar operations.</simpara>
</note>
<simpara>Vector masking is represented in assembler code as another vector
operand, with <literal>.t</literal> indicating if operation occurs when <literal>v0.mask[i]</literal> is
<literal>1</literal>.  If no masking operand is specified, unmasked vector execution
(<literal>vm=1</literal>) is assumed.</simpara>
<screen>    vop.v*    v1, v2, v3, v0.t  # enabled where v0.mask[i]=1, m=0
    vop.v*    v1, v2, v3        # unmasked vector operation, m=1</screen>
<note>
<simpara>Even though current vector extensions only support one vector
mask register <literal>v0</literal> and only the true form of predication, the assembly
syntax writes it out in full to be compatible with future extensions
that might add a mask register specifier and supporting both true and
complement masking. The <literal>.t</literal> suffix on the masking operand also helps
to visually encode the use of a mask.</simpara>
</note>
<note>
<simpara>The <literal>.mask</literal> suffix is not part of the assembly syntax.
We only append it in contexts where a mask vector is subscripted,
e.g., <literal>v0.mask[i]</literal>.</simpara>
</note>
</section>
</section>
<section xml:id="sec-inactive-defs">
<title>Prestart, Active, Inactive, Body, and Tail Element Definitions</title>
<simpara>The destination element indices operated on during a vector
instruction’s execution can be divided into three disjoint subsets.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>prestart</emphasis> elements are those whose element index is less than the
initial value in the <literal>vstart</literal> register.  The prestart elements do not
raise exceptions and do not update the destination vector register.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>body</emphasis> elements are those whose element index is greater than or equal
to the initial value in the <literal>vstart</literal> register, and less than the current
vector length setting in <literal>vl</literal>. The body can be split into two disjoint subsets:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>active</emphasis> elements during a vector instruction’s execution are the
elements within the body and where the current mask is enabled at that element
position.  The active elements can raise exceptions and update the destination
vector register group.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>inactive</emphasis> elements are the elements within the body
but where the current mask is disabled at that element
position.  The inactive elements do not raise exceptions and do not
update any destination vector register group unless masked agnostic is
specified (<literal>vtype.vma</literal>=1), in which case inactive elements may be
overwritten with 1s.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The <emphasis>tail</emphasis> elements during a vector instruction’s execution are the
elements past the current vector length setting specified in <literal>vl</literal>.
The tail elements do not raise exceptions, and do not update any
destination vector register group unless tail agnostic is specified
(<literal>vtype.vta</literal>=1), in which case tail elements may be overwritten with
1s, or with the result of the instruction in the case of
mask-producing instructions except for mask loads.  When LMUL &lt; 1, the
tail includes the elements past VLMAX that are held in the same vector
register.</simpara>
</listitem>
</itemizedlist>
<screen>    for element index x
    prestart(x) = (0 &lt;= x &lt; vstart)
    body(x)     = (vstart &lt;= x &lt; vl)
    tail(x)     = (vl &lt;= x &lt; max(VLMAX,VLEN/SEW))
    mask(x)     = unmasked || v0.mask[x] == 1
    active(x)   = body(x) &amp;&amp; mask(x)
    inactive(x) = body(x) &amp;&amp; !mask(x)</screen>
<simpara>When <literal>vstart</literal> ≥ <literal>vl</literal>, there are no body elements, and no elements
are updated in any destination vector register group, including that
no tail elements are updated with agnostic values.</simpara>
<note>
<simpara>As a consequence, when <literal>vl</literal>=0, no elements, including agnostic
elements, are updated in the destination vector register group
regardless of <literal>vstart</literal>.</simpara>
</note>
<simpara>Instructions that write an <literal>x</literal> register or <literal>f</literal> register
do so even when <literal>vstart</literal> ≥ <literal>vl</literal>, including when <literal>vl</literal>=0.</simpara>
<note>
<simpara>Some instructions such as <literal>vslidedown</literal> and <literal>vrgather</literal> may read
indices past <literal>vl</literal> or even VLMAX in source vector register groups.  The
general policy is to return the value 0 when the index is greater than
VLMAX in the source vector register group.</simpara>
</note>
</section>
</section>
<section xml:id="sec-vector-config">
<title>Configuration-Setting Instructions (<literal>vsetvli</literal>/<literal>vsetivl</literal>/<literal>vsetvl</literal>)</title>
<simpara>One of the common approaches to handling a large number of elements is
"stripmining" where each iteration of a loop handles some number of elements,
and the iterations continue until all elements have been processed. The RISC-V
vector specification provides direct, portable support for this approach.
The application specifies the total number of elements to be processed (the application vector length or AVL) as a
candidate value for <literal>vl</literal>, and the hardware responds via a general-purpose
register with the (frequently smaller) number of elements that the hardware
will handle per iteration (stored in <literal>vl</literal>), based on the microarchitectural
implementation and the <literal>vtype</literal> setting. A straightforward loop structure,
shown in <xref linkend="example-stripmine-sew"/>, depicts the ease with which the code keeps
track of the remaining number of elements and the amount per iteration handled
by hardware.</simpara>
<simpara>A set of instructions is provided to allow rapid configuration of the
values in <literal>vl</literal> and <literal>vtype</literal> to match application needs.  The
<literal>vset{i}vl{i}</literal> instructions set the <literal>vtype</literal> and <literal>vl</literal> CSRs based on
their arguments, and write the new value of <literal>vl</literal> into <literal>rd</literal>.</simpara>
<screen> vsetvli rd, rs1, vtypei   # rd = new vl, rs1 = AVL, vtypei = new vtype setting
 vsetivli rd, uimm, vtypei # rd = new vl, uimm = AVL, vtypei = new vtype setting
 vsetvl  rd, rs1, rs2      # rd = new vl, rs1 = AVL, rs2 = new vtype value</screen>
<simpara>Formats for Vector Configuration Instructions under OP-V major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7,  name: 0x57, attr: 'vsetvli'},
  {bits: 5,  name: 'rd', type: 4},
  {bits: 3,  name: 7},
  {bits: 5,  name: 'rs1', type: 4},
  {bits: 11, name: 'zimm[10:0]', type: 5},
  {bits: 1,  name: '0'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7,  name: 0x57, attr: 'vsetivli'},
  {bits: 5,  name: 'rd', type: 4},
  {bits: 3,  name: 7},
  {bits: 5,  name: 'uimm[4:0]', type: 5},
  {bits: 10, name: 'zimm[9:0]', type: 5},
  {bits: 1, name: '1'},
  {bits: 1,  name: '1'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7,  name: 0x57, attr: 'vsetvl'},
  {bits: 5,  name: 'rd', type: 4},
  {bits: 3,  name: 7},
  {bits: 5,  name: 'rs1', type: 4},
  {bits: 5,  name: 'rs2', type: 4},
  {bits: 6,  name: 0x1000},
  {bits: 1,  name: 1},
]}</programlisting>
<section xml:id="_vtype_encoding">
<title><literal>vtype</literal> encoding</title>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 3, name: 'vlmul[2:0]'},
  {bits: 3, name: 'vsew[2:0]'},
  {bits: 1, name: 'vta'},
  {bits: 1, name: 'vma'},
  {bits: 23, name: 'reserved'},
  {bits: 1, name: 'vill'},
]}</programlisting>
<note>
<simpara>This diagram shows the layout for RV32 systems, whereas in
general <literal>vill</literal> should be at bit XLEN-1.</simpara>
</note>
<table colsep="1" frame="all" rowsep="1">
<title><literal>vtype</literal> register layout</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="62.5*"/>
<thead>
<row>
<entry align="right" valign="top">Bits</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="top"><simpara>XLEN-1</simpara></entry>
<entry align="left" valign="top"><simpara>vill</simpara></entry>
<entry align="left" valign="top"><simpara>Illegal value if set</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>XLEN-2:8</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>Reserved</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>vma</simpara></entry>
<entry align="left" valign="top"><simpara>Vector mask agnostic</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>vta</simpara></entry>
<entry align="left" valign="top"><simpara>Vector tail agnostic</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>5:3</simpara></entry>
<entry align="left" valign="top"><simpara>vsew[2:0]</simpara></entry>
<entry align="left" valign="top"><simpara>Selected element width (SEW) setting</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>2:0</simpara></entry>
<entry align="left" valign="top"><simpara>vlmul[2:0]</simpara></entry>
<entry align="left" valign="top"><simpara>Vector register group multiplier (LMUL) setting</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The new <literal>vtype</literal> setting is encoded in the immediate fields of
<literal>vsetvli</literal> and <literal>vsetivli</literal>,  and in the <literal>rs2</literal> register for <literal>vsetvl</literal>.</simpara>
<screen> Suggested assembler names used for vset{i}vli vtypei immediate

 e8    # SEW=8b
 e16   # SEW=16b
 e32   # SEW=32b
 e64   # SEW=64b
 e128  # SEW=128b
 e256  # SEW=256b
 e512  # SEW=512b
 e1024 # SEW=1024b

 mf8  # LMUL=1/8
 mf4  # LMUL=1/4
 mf2  # LMUL=1/2
 m1   # LMUL=1, assumed if m setting absent
 m2   # LMUL=2
 m4   # LMUL=4
 m8   # LMUL=8

Examples:
    vsetvli t0, a0, e8          # SEW= 8, LMUL=1
    vsetvli t0, a0, e8, m2      # SEW= 8, LMUL=2
    vsetvli t0, a0, e32, mf2    # SEW=32, LMUL=1/2</screen>
<simpara>The <literal>vsetvl</literal> variant operates similarly to <literal>vsetvli</literal> except that it
takes a <literal>vtype</literal> value from <literal>rs2</literal> and can be used for context restore.</simpara>
<simpara>If the <literal>vtype</literal> setting is not supported by the implementation, then
the <literal>vill</literal> bit is set in <literal>vtype</literal>, the remaining bits in <literal>vtype</literal> are
set to zero, and the <literal>vl</literal> register is also set to zero.</simpara>
<note>
<simpara>Earlier drafts required a trap when setting <literal>vtype</literal> to an
illegal value.  However, this would have added the first
data-dependent trap on a CSR write to the ISA.  Implementations may
choose to trap when illegal values are written to <literal>vtype</literal> instead of
setting <literal>vill</literal>, to allow emulation to support new configurations for
forward-compatibility.  The current scheme supports light-weight
runtime interrogation of the supported vector unit configurations by
checking if <literal>vill</literal> is clear for a given setting.</simpara>
</note>
</section>
<section xml:id="_avl_encoding">
<title>AVL encoding</title>
<simpara>The new vector
length setting is based on AVL, which for <literal>vsetvli</literal> and <literal>vsetvl</literal> is encoded in the <literal>rs1</literal> and <literal>rd</literal>
fields as follows:</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>AVL used in <literal>vsetvli</literal> and <literal>vsetvl</literal> instructions</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="8.3333*"/>
<colspec colname="col_2" colwidth="8.3333*"/>
<colspec colname="col_3" colwidth="41.6666*"/>
<colspec colname="col_4" colwidth="41.6668*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>rd</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>rs1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>AVL value</simpara></entry>
<entry align="left" valign="top"><simpara>Effect on <literal>vl</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>!x0</simpara></entry>
<entry align="left" valign="top"><simpara>Value in <literal>x[rs1]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Normal stripmining</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>!x0</simpara></entry>
<entry align="left" valign="top"><simpara>x0</simpara></entry>
<entry align="left" valign="top"><simpara>~0</simpara></entry>
<entry align="left" valign="top"><simpara>Set <literal>vl</literal> to VLMAX</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>x0</simpara></entry>
<entry align="left" valign="top"><simpara>x0</simpara></entry>
<entry align="left" valign="top"><simpara>Value in <literal>vl</literal> register</simpara></entry>
<entry align="left" valign="top"><simpara>Keep existing <literal>vl</literal> (of course, <literal>vtype</literal> may change)</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>When <literal>rs1</literal> is not <literal>x0</literal>, the AVL is an unsigned integer held in the <literal>x</literal>
register specified by <literal>rs1</literal>, and the new <literal>vl</literal> value is also written to
the <literal>x</literal> register specified by <literal>rd</literal>.</simpara>
<simpara>When <literal>rs1=x0</literal> but <literal>rd!=x0</literal>, the maximum unsigned integer value (<literal>~0</literal>)
is used as the AVL, and the resulting VLMAX is written to <literal>vl</literal> and
also to the <literal>x</literal> register specified by <literal>rd</literal>.</simpara>
<simpara>When <literal>rs1=x0</literal> and <literal>rd=x0</literal>, the instruction operates as if the current
vector length in <literal>vl</literal> is used as the AVL, and the resulting value is
written to <literal>vl</literal>, but not to a destination register.  This form can
only be used when VLMAX and hence <literal>vl</literal> is not actually changed by the
new SEW/LMUL ratio.  Use of the instruction with a new SEW/LMUL ratio
that would result in a change of VLMAX is reserved.  Implementations
may set <literal>vill</literal> in this case.</simpara>
<note>
<simpara>This last form of the instructions allows the <literal>vtype</literal> register to
be changed while maintaining the current <literal>vl</literal>, provided VLMAX is not
reduced.  This design was chosen to ensure <literal>vl</literal> would always hold a
legal value for current <literal>vtype</literal> setting.  The current <literal>vl</literal> value can
be read from the <literal>vl</literal> CSR.  The <literal>vl</literal> value could be reduced by this
instruction if the new SEW/LMUL ratio causes VLMAX to shrink, and so
this case has been reserved as it is not clear this is a generally
useful operation, and implementations can otherwise assume <literal>vl</literal> is not
changed by this instruction to optimize their microarchitecture.</simpara>
</note>
<simpara>For the <literal>vsetivli</literal> instruction, the AVL is encoded as a 5-bit
zero-extended immediate (0—​31) in the <literal>rs1</literal> field.</simpara>
<note>
<simpara>The encoding of AVL for <literal>vsetivli</literal> is the same as for regular
CSR immediate values.</simpara>
</note>
<note>
<simpara>The <literal>vsetivli</literal> instruction provides more compact code when the
dimensions of vectors are small, and known to fit inside the vector
registers, so do not need stripmining overhead.</simpara>
</note>
</section>
<section xml:id="_constraints_on_setting_vl">
<title>Constraints on Setting <literal>vl</literal></title>
<simpara>The <literal>vset{i}vl{i}</literal> instructions first set VLMAX according to the <literal>vtype</literal>
argument, then set <literal>vl</literal> obeying the following constraints:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>vl = AVL</literal> if <literal>AVL ≤ VLMAX</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ceil(AVL / 2) ≤ vl ≤ VLMAX</literal> if <literal>AVL &lt; (2 * VLMAX)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>vl = VLMAX</literal> if <literal>AVL ≥ (2 * VLMAX)</literal></simpara>
</listitem>
<listitem>
<simpara>Deterministic on any given implementation for same input AVL and VLMAX values</simpara>
</listitem>
<listitem>
<simpara>These specific properties follow from the prior rules:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>vl = 0</literal> if  <literal>AVL = 0</literal></simpara>
</listitem>
<listitem>
<simpara><literal>vl &gt; 0</literal> if <literal>AVL &gt; 0</literal></simpara>
</listitem>
<listitem>
<simpara><literal>vl ≤ VLMAX</literal></simpara>
</listitem>
<listitem>
<simpara><literal>vl ≤ AVL</literal></simpara>
</listitem>
<listitem>
<simpara>a value read from <literal>vl</literal> when used as the AVL argument to <literal>vset{i}vl{i}</literal> results in the same
value in <literal>vl</literal>, provided the resultant VLMAX equals the value of VLMAX at the time that <literal>vl</literal> was read</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<note>
<simpara>The <literal>vl</literal> setting rules are designed to be sufficiently strict to
preserve <literal>vl</literal> behavior across register spills and context swaps for
<literal>AVL ≤ VLMAX</literal>, yet flexible enough to enable implementations to improve
vector lane utilization for <literal>AVL &gt; VLMAX</literal>.</simpara>
<simpara>For example, this permits an implementation to set <literal>vl = ceil(AVL / 2)</literal>
for <literal>VLMAX &lt; AVL &lt; 2*VLMAX</literal> in order to evenly distribute work over the
last two iterations of a stripmine loop.
Requirement 2 ensures that the first stripmine iteration of reduction
loops uses the largest vector length of all iterations, even in the case
of <literal>AVL &lt; 2*VLMAX</literal>.
This allows software to avoid needing to explicitly calculate a running
maximum of vector lengths observed during a stripmined loop.
Requirement 2 also allows an implementation to set vl to VLMAX for <literal>VLMAX &lt; AVL &lt; 2*VLMAX</literal></simpara>
</note>
</section>
<section xml:id="example-stripmine-sew">
<title>Example of stripmining and changes to SEW</title>
<simpara>The SEW and LMUL settings can be changed dynamically to provide high
throughput on mixed-width operations in a single loop.</simpara>
<screen># Example: Load 16-bit values, widen multiply to 32b, shift 32b result
# right by 3, store 32b values.
# On entry:
#  a0 holds the total number of elements to process
#  a1 holds the address of the source array
#  a2 holds the address of the destination array

loop:
    vsetvli a3, a0, e16, m4, ta, ma  # vtype = 16-bit integer vectors;
                                     # also update a3 with vl (# of elements this iteration)
    vle16.v v4, (a1)        # Get 16b vector
    slli t1, a3, 1          # Multiply # elements this iteration by 2 bytes/source element
    add a1, a1, t1          # Bump pointer
    vwmul.vx v8, v4, x10    # Widening multiply into 32b in &lt;v8--v15&gt;

    vsetvli x0, x0, e32, m8, ta, ma  # Operate on 32b values
    vsrl.vi v8, v8, 3
    vse32.v v8, (a2)        # Store vector of 32b elements
    slli t1, a3, 2          # Multiply # elements this iteration by 4 bytes/destination element
    add a2, a2, t1          # Bump pointer
    sub a0, a0, a3          # Decrement count by vl
    bnez a0, loop           # Any more?</screen>
</section>
</section>
<section xml:id="sec-vector-memory">
<title>Vector Loads and Stores</title>
<simpara>Vector loads and stores move values between vector registers and
memory.  Vector loads and stores are masked and do not raise
exceptions on inactive elements.  Masked vector loads do not update
inactive elements in the destination vector register group, unless
masked agnostic is specified (<literal>vtype.vma</literal>=1).  Masked vector stores
only update active memory elements.  All vector loads and stores may
generate and accept a non-zero <literal>vstart</literal> value.</simpara>
<section xml:id="_vector_loadstore_instruction_encoding">
<title>Vector Load/Store Instruction Encoding</title>
<simpara>Vector loads and stores are encoded within the scalar floating-point
load and store major opcodes (LOAD-FP/STORE-FP).  The vector load and
store encodings repurpose a portion of the standard scalar
floating-point load/store 12-bit immediate field to provide further
vector instruction encoding, with bit 25 holding the standard vector
mask bit (see <xref linkend="sec-vector-mask-encoding"/>).</simpara>
<simpara>Format for Vector Load Instructions under LOAD-FP major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x7, attr: 'VL* unit-stride'},
  {bits: 5, name: 'vd', attr: 'destination of load', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'lumop'},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x7, attr: 'VLS* strided'},
  {bits: 5, name: 'vd', attr: 'destination of load', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'rs2', attr: 'stride', type: 4},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x7, attr: 'VLX* indexed'},
  {bits: 5, name: 'vd', attr: 'destination of load', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'vs2', attr: 'address offsets', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<simpara>Format for Vector Store Instructions under STORE-FP major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x27, attr: 'VS* unit-stride'},
  {bits: 5, name: 'vs3', attr: 'store data', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'sumop'},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x27, attr: 'VSS* strided'},
  {bits: 5, name: 'vs3', attr: 'store data', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'rs2', attr: 'stride', type: 4},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x27, attr: 'VSX* indexed'},
  {bits: 5, name: 'vs3', attr: 'store data', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 'vs2', attr: 'address offsets', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 2, name: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>rs1[4:0]</simpara></entry>
<entry align="left" valign="top"><simpara>specifies x register holding base address</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>rs2[4:0]</simpara></entry>
<entry align="left" valign="top"><simpara>specifies x register holding stride</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vs2[4:0]</simpara></entry>
<entry align="left" valign="top"><simpara>specifies v register holding address offsets</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vs3[4:0]</simpara></entry>
<entry align="left" valign="top"><simpara>specifies v register holding store data</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vd[4:0]</simpara></entry>
<entry align="left" valign="top"><simpara>specifies v register destination of load</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vm</simpara></entry>
<entry align="left" valign="top"><simpara>specifies whether vector masking is enabled (0 = mask enabled, 1 = mask disabled)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>width[2:0]</simpara></entry>
<entry align="left" valign="top"><simpara>specifies size of memory elements, and distinguishes from FP scalar</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>mew</simpara></entry>
<entry align="left" valign="top"><simpara>extended memory element width. See <xref linkend="sec-vector-loadstore-width-encoding"/></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>mop[1:0]</simpara></entry>
<entry align="left" valign="top"><simpara>specifies memory addressing mode</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>nf[2:0]</simpara></entry>
<entry align="left" valign="top"><simpara>specifies the number of fields in each segment, for segment load/stores</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>lumop[4:0]/sumop[4:0]</simpara></entry>
<entry align="left" valign="top"><simpara>are additional fields encoding variants of unit-stride instructions</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Vector memory unit-stride and constant-stride operations directly
encode EEW of the data to be transferred statically in the instruction
to reduce the number of <literal>vtype</literal> changes when accessing memory in a
mixed-width routine.  Indexed operations use the explicit EEW encoding
in the instruction to set the size of the indices used, and use
SEW/LMUL to specify the data width.</simpara>
</section>
<section xml:id="_vector_loadstore_addressing_modes">
<title>Vector Load/Store Addressing Modes</title>
<simpara>The vector extension supports unit-stride, strided, and
indexed (scatter/gather) addressing modes.  Vector load/store base
registers and strides are taken from the GPR <literal>x</literal> registers.</simpara>
<simpara>The base effective address for all vector accesses is given by the
contents of the <literal>x</literal> register named in <literal>rs1</literal>.</simpara>
<simpara>Vector unit-stride operations access elements stored contiguously in
memory starting from the base effective address.</simpara>
<simpara>Vector constant-strided operations access the first memory element at the base
effective address, and then access subsequent elements at address
increments given by the byte offset contained in the <literal>x</literal> register
specified by <literal>rs2</literal>.</simpara>
<simpara>Vector indexed operations add the contents of each element of the
vector offset operand specified by <literal>vs2</literal> to the base effective address
to give the effective address of each element.  The data vector
register group has EEW=SEW, EMUL=LMUL, while the offset vector
register group has EEW encoding in the instruction and
EMUL=(EEW/SEW)*LMUL.</simpara>
<simpara>The vector offset operand is treated as a vector of byte-address
offsets.</simpara>
<note>
<simpara>The indexed operations can also be used to access fields within
a vector of objects, where the <literal>vs2</literal> vector holds pointers to the base
of the objects and the scalar <literal>x</literal> register holds the offset of the
member field in each object.  Supporting this case is why the indexed
operations were not defined to scale the element indices by the data
EEW.</simpara>
</note>
<simpara>If the vector offset elements are narrower than XLEN, they are
zero-extended to XLEN before adding to the base effective address.  If
the vector offset elements are wider than XLEN, the least-significant
XLEN bits are used in the address calculation.  An implementation can
raise an illegal instruction exception if the EEW is not supported for
offset elements.</simpara>
<note>
<simpara>A profile may place an upper limit on the maximum supported index
EEW (e.g., only up to XLEN) smaller than ELEN.</simpara>
</note>
<simpara>The vector addressing modes are encoded using the 2-bit <literal>mop[1:0]</literal>
field.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>encoding for loads</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="6.6666*"/>
<colspec colname="col_2" colwidth="6.6666*"/>
<colspec colname="col_3" colwidth="46.6666*"/>
<colspec colname="col_4" colwidth="40.0002*"/>
<thead>
<row>
<entry align="left" nameend="col_2" namest="col_1" valign="top">mop [1:0]</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Opcodes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride</simpara></entry>
<entry align="left" valign="top"><simpara>VLE&lt;EEW&gt;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>indexed-unordered</simpara></entry>
<entry align="left" valign="top"><simpara>VLUXEI&lt;EEW&gt;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>strided</simpara></entry>
<entry align="left" valign="top"><simpara>VLSE&lt;EEW&gt;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>indexed-ordered</simpara></entry>
<entry align="left" valign="top"><simpara>VLOXEI&lt;EEW&gt;</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>encoding for stores</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="6.6666*"/>
<colspec colname="col_2" colwidth="6.6666*"/>
<colspec colname="col_3" colwidth="46.6666*"/>
<colspec colname="col_4" colwidth="40.0002*"/>
<thead>
<row>
<entry align="left" nameend="col_2" namest="col_1" valign="top">mop [1:0]</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Opcodes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride</simpara></entry>
<entry align="left" valign="top"><simpara>VSE&lt;EEW&gt;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>indexed-unordered</simpara></entry>
<entry align="left" valign="top"><simpara>VSUXEI&lt;EEW&gt;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>strided</simpara></entry>
<entry align="left" valign="top"><simpara>VSSE&lt;EEW&gt;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>indexed-ordered</simpara></entry>
<entry align="left" valign="top"><simpara>VSOXEI&lt;EEW&gt;</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Vector unit-stride and constant-stride memory accesses do not
guarantee ordering between individual element accesses.  The vector
indexed load and store memory operations have two forms, ordered and
unordered.  The indexed-ordered variants preserve element ordering on
memory accesses.</simpara>
<simpara>For unordered instructions (<literal>mop</literal>!=11) there is no guarantee on
element access order.  If the accesses are to a strongly ordered IO
region, the element accesses can be initiated in any order.</simpara>
<note>
<simpara>To provide ordered vector accesses to a strongly ordered IO
region, the ordered indexed instructions should be used.</simpara>
</note>
<simpara>For implementations with precise vector traps, exceptions on
indexed-unordered stores must also be precise.</simpara>
<simpara>Additional unit-stride vector addressing modes are encoded using the
5-bit <literal>lumop</literal> and <literal>sumop</literal> fields in the unit-stride load and store
instruction encodings respectively.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>lumop</title>
<tgroup cols="6">
<colspec colname="col_1" colwidth="6.25*"/>
<colspec colname="col_2" colwidth="6.25*"/>
<colspec colname="col_3" colwidth="6.25*"/>
<colspec colname="col_4" colwidth="6.25*"/>
<colspec colname="col_5" colwidth="6.25*"/>
<colspec colname="col_6" colwidth="68.75*"/>
<thead>
<row>
<entry align="left" nameend="col_5" namest="col_1" valign="top">lumop[4:0]</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride load</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride, whole register load</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride, mask load, EEW=8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride fault-only-first</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>other encodings reserved</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>sumop</title>
<tgroup cols="6">
<colspec colname="col_1" colwidth="6.25*"/>
<colspec colname="col_2" colwidth="6.25*"/>
<colspec colname="col_3" colwidth="6.25*"/>
<colspec colname="col_4" colwidth="6.25*"/>
<colspec colname="col_5" colwidth="6.25*"/>
<colspec colname="col_6" colwidth="68.75*"/>
<thead>
<row>
<entry align="left" nameend="col_5" namest="col_1" valign="top">sumop[4:0]</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride store</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride, whole register store</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>unit-stride, mask store, EEW=8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>other encodings reserved</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The <literal>nf[2:0]</literal> field encodes the number of fields in each segment.  For
regular vector loads and stores, <literal>nf</literal>=0, indicating that a single
value is moved between a vector register group and memory at each
element position.  Larger values in the <literal>nf</literal> field are used to access
multiple contiguous fields within a segment as described below in
Section <xref linkend="sec-aos"/>.</simpara>
<note>
<simpara>The <literal>nf</literal> field for segment load/stores has replaced the use of
the same bits for an address offset field.  The offset can be replaced
with a single scalar integer calculation, while segment load/stores
add more powerful primitives to move items to and from memory.</simpara>
</note>
<simpara>The <literal>nf[2:0]</literal> field also encodes the number of whole vector registers
to transfer for the whole vector register load/store instructions.</simpara>
</section>
<section xml:id="sec-vector-loadstore-width-encoding">
<title>Vector Load/Store Width Encoding</title>
<simpara>Vector loads and stores have an EEW encoded directly in the
instruction.  The corresponding EMUL is calculated as EMUL =
(EEW/SEW)*LMUL. If the EMUL would be out of range (EMUL&gt;8 or
EMUL&lt;1/8), the instruction encoding is reserved.  The vector register
groups must have legal register specifiers for the selected EMUL;
the instruction encoding is otherwise considered reserved.</simpara>
<simpara>Vector unit-stride and constant-stride use the EEW/EMUL encoded in the
instruction for the data values, while vector indexed loads and stores
use the EEW/EMUL encoded in the instruction for the index values and
the SEW/LMUL encoded in <literal>vtype</literal> for the data values.</simpara>
<simpara>Vector loads and stores are encoded using width values that are not
claimed by the standard scalar floating-point loads and stores.</simpara>
<simpara>The <literal>mew</literal> bit (<literal>inst[28]</literal>) is expected to be used to encode expanded
memory sizes of 128 bits and above, but these encodings are <emphasis>reserved</emphasis>
at this point.</simpara>
<simpara>Vector loads and stores for EEWs of all supported SEW settings must be
provided in an implementation.  Vector load/store encodings for
unsupported EEW widths are reserved.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>Width encoding for vector loads and stores.</title>
<tgroup cols="10">
<colspec colname="col_1" colwidth="21.7391*"/>
<colspec colname="col_2" colwidth="4.3478*"/>
<colspec colname="col_3" colwidth="4.3478*"/>
<colspec colname="col_4" colwidth="4.3478*"/>
<colspec colname="col_5" colwidth="4.3478*"/>
<colspec colname="col_6" colwidth="13.0434*"/>
<colspec colname="col_7" colwidth="13.0434*"/>
<colspec colname="col_8" colwidth="13.0434*"/>
<colspec colname="col_9" colwidth="13.0434*"/>
<colspec colname="col_10" colwidth="8.6961*"/>
<thead>
<row>
<entry align="left" valign="top"/>
<entry align="left" valign="top">mew</entry>
<entry align="left" nameend="col_5" namest="col_3" valign="top">width [2:0]</entry>
<entry align="left" valign="top">Mem bits</entry>
<entry align="left" valign="top">Data Reg bits</entry>
<entry align="right" valign="top">Index bits</entry>
<entry align="right" valign="top">Opcodes</entry>
<entry align="right" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Standard scalar FP</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>16</simpara></entry>
<entry align="right" valign="top"><simpara>FLEN</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>FLH/FSH</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Standard scalar FP</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>32</simpara></entry>
<entry align="right" valign="top"><simpara>FLEN</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>FLW/FSW</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Standard scalar FP</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>64</simpara></entry>
<entry align="right" valign="top"><simpara>FLEN</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>FLD/FSD</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Standard scalar FP</simpara></entry>
<entry align="left" valign="top"><simpara>x</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>128</simpara></entry>
<entry align="right" valign="top"><simpara>FLEN</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>FLQ/FSQ</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 8b element</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>8</simpara></entry>
<entry align="right" valign="top"><simpara>8</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>VLxE8/VSxE8</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 16b element</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>16</simpara></entry>
<entry align="right" valign="top"><simpara>16</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>VLxE16/VSxE16</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 32b element</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>32</simpara></entry>
<entry align="right" valign="top"><simpara>32</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>VLxE32/VSxE32</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 64b element</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>64</simpara></entry>
<entry align="right" valign="top"><simpara>64</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>VLxE64/VSxE64</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 128b element</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>128</simpara></entry>
<entry align="right" valign="top"><simpara>128</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>VLxE128/VSxE128</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Reserved</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 256b element</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>256</simpara></entry>
<entry align="right" valign="top"><simpara>256</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>VLxE256/VSxE256</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Reserved</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 512b element</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>512</simpara></entry>
<entry align="right" valign="top"><simpara>512</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>VLxE512/VSxE512</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Reserved</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 1024b element</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>1024</simpara></entry>
<entry align="right" valign="top"><simpara>1024</simpara></entry>
<entry align="right" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>VLxE1024/VSxE1024</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Reserved</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 8b index</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>SEW</simpara></entry>
<entry align="right" valign="top"><simpara>SEW</simpara></entry>
<entry align="right" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>VLxEI8/VSxEI8</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 16b index</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>SEW</simpara></entry>
<entry align="right" valign="top"><simpara>SEW</simpara></entry>
<entry align="right" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>VLxEI16/VSxEI16</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 32b index</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>SEW</simpara></entry>
<entry align="right" valign="top"><simpara>SEW</simpara></entry>
<entry align="right" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>VLxEI32/VSxEI32</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Vector 64b index</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>SEW</simpara></entry>
<entry align="right" valign="top"><simpara>SEW</simpara></entry>
<entry align="right" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>VLxEI64/VSxEI64</simpara></entry>
<entry align="left" valign="top"/>
</row>
</tbody>
</tgroup>
</table>
<simpara>Mem bits is the size of each element accessed in memory.</simpara>
<simpara>Data reg bits is the size of each data element accessed in register.</simpara>
<simpara>Index bits is the size of each index accessed in register.</simpara>
<simpara>Data and index bit EEW encodings larger than 64b are currently reserved.</simpara>
<note>
<simpara>RV128 will require data and index EEW of 128.</simpara>
</note>
</section>
<section xml:id="_vector_unit_stride_instructions">
<title>Vector Unit-Stride Instructions</title>
<screen>    # Vector unit-stride loads and stores

    # vd destination, rs1 base address, vm is mask encoding (v0.t or &lt;missing&gt;)
    vle8.v    vd, (rs1), vm  #    8-bit unit-stride load
    vle16.v   vd, (rs1), vm  #   16-bit unit-stride load
    vle32.v   vd, (rs1), vm  #   32-bit unit-stride load
    vle64.v   vd, (rs1), vm  #   64-bit unit-stride load
    # vle128.v  vd, (rs1), vm  #  128-bit unit-stride load. Reserved
    # vle256.v  vd, (rs1), vm  #  256-bit unit-stride load. Reserved
    # vle512.v  vd, (rs1), vm  #  512-bit unit-stride load. Reserved
    # vle1024.v vd, (rs1), vm  # 1024-bit unit-stride load. Reserved

    # vs3 store data, rs1 base address, vm is mask encoding (v0.t or &lt;missing&gt;)
    vse8.v    vs3, (rs1), vm  #    8-bit unit-stride store
    vse16.v   vs3, (rs1), vm  #   16-bit unit-stride store
    vse32.v   vs3, (rs1), vm  #   32-bit unit-stride store
    vse64.v   vs3, (rs1), vm  #   64-bit unit-stride store
    # vse128.v  vs3, (rs1), vm  #  128-bit unit-stride store. Reserved
    # vse256.v  vs3, (rs1), vm  #  256-bit unit-stride store. Reserved
    # vse512.v  vs3, (rs1), vm  #  512-bit unit-stride store. Reserved
    # vse1024.v vs3, (rs1), vm  # 1024-bit unit-stride store. Reserved</screen>
<simpara>An additional unit-stride load and store is provided to support
transferring mask values to/from memory.  These operate the
same as unmasked byte loads or stores (EEW=8), except that the effective
vector length is <literal>evl</literal>=ceil(<literal>vl</literal>/8) (i.e. EMUL=1), and the destination register is
always written with a tail-agnostic policy.</simpara>
<screen>    # Vector unit-stride mask load
    vlm.v vd, (rs1)   #  Load byte vector of length ceil(vl/8)

    # Vector unit-stride mask store
    vsm.v vs3, (rs1)  #  Store byte vector of length ceil(vl/8)</screen>
<simpara><literal>vlm.v</literal> and <literal>vsm.v</literal> are encoded with <literal>width[2:0]</literal>=0, like
<literal>vle8.v</literal> and <literal>vse8.v</literal>; they are distinguished by different
<literal>lumop</literal> and <literal>sumop</literal> encodings.  Since <literal>vlm.v</literal> and <literal>vsm.v</literal> operate as byte loads and stores,
<literal>vstart</literal> is in units of bytes for these instructions.</simpara>
<note>
<simpara>The previous assembler mnemonics <literal>vle1.v</literal> and <literal>vse1.v</literal> were
confusing as length was handled different for these instructions
versus other element load/store instructions.  To avoid software
churn, these older assembly mnemonics are being retained as aliases.</simpara>
</note>
<note>
<simpara>The primary motivation to provide mask load and store is to
support machines that internally rearrange data to reduce
cross-datapath wiring.  However, this also provides a convenient
mechanism to access packed bit vectors in memory as mask registers,
and reduces the cost of mask spill/fill by reducing need to change
<literal>vl</literal>.</simpara>
</note>
</section>
<section xml:id="_vector_strided_instructions">
<title>Vector Strided Instructions</title>
<screen>    # Vector strided loads and stores

    # vd destination, rs1 base address, rs2 byte stride
    vlse8.v    vd, (rs1), rs2, vm  #    8-bit strided load
    vlse16.v   vd, (rs1), rs2, vm  #   16-bit strided load
    vlse32.v   vd, (rs1), rs2, vm  #   32-bit strided load
    vlse64.v   vd, (rs1), rs2, vm  #   64-bit strided load
    # vlse128.v  vd, (rs1), rs2, vm  #  128-bit strided load. Reserved
    # vlse256.v  vd, (rs1), rs2, vm  #  256-bit strided load. Reserved
    # vlse512.v  vd, (rs1), rs2, vm  #  512-bit strided load. Reserved
    # vlse1024.v vd, (rs1), rs2, vm  # 1024-bit strided load. Reserved

    # vs3 store data, rs1 base address, rs2 byte stride
    vsse8.v    vs3, (rs1), rs2, vm  #    8-bit strided store
    vsse16.v   vs3, (rs1), rs2, vm  #   16-bit strided store
    vsse32.v   vs3, (rs1), rs2, vm  #   32-bit strided store
    vsse64.v   vs3, (rs1), rs2, vm  #   64-bit strided store
    # vsse128.v  vs3, (rs1), rs2, vm  #  128-bit strided store. Reserved
    # vsse256.v  vs3, (rs1), rs2, vm  #  256-bit strided store. Reserved
    # vsse512.v  vs3, (rs1), rs2, vm  #  512-bit strided store. Reserved
    # vsse1024.v vs3, (rs1), rs2, vm  # 1024-bit strided store. Reserved</screen>
<simpara>Negative and zero strides are supported.</simpara>
<simpara>Element accesses within a strided instruction are unordered with
respect to each other.</simpara>
<simpara>When <literal>rs2</literal>=<literal>x0</literal>, then an implementation is allowed, but not required,
to perform fewer memory operations than the number of active elements,
and may perform different numbers of memory operations across
different dynamic executions of the same static instruction.</simpara>
<note>
<simpara>Compilers must be aware to not use the <literal>x0</literal> form for rs2 when
the immediate stride is <literal>0</literal> if the intent to is to require all memory
accesses are performed.</simpara>
</note>
<simpara>When <literal>rs2!=x0</literal> and the value of <literal>x[rs2]=0</literal>, the implementation must
perform one memory access for each active element (but these accesses
will not be ordered).</simpara>
<note>
<simpara>When repeating ordered vector accesses to the same memory
address are required, then an ordered indexed operation can be used.</simpara>
</note>
</section>
<section xml:id="_vector_indexed_instructions">
<title>Vector Indexed Instructions</title>
<screen>    # Vector indexed loads and stores

    # Vector indexed-ordered load instructions
    # vd destination, rs1 base address, vs2 indices
    vluxei8.v    vd, (rs1), vs2, vm  # unordered  8-bit indexed load of SEW data
    vluxei16.v   vd, (rs1), vs2, vm  # unordered 16-bit indexed load of SEW data
    vluxei32.v   vd, (rs1), vs2, vm  # unordered 32-bit indexed load of SEW data
    vluxei64.v   vd, (rs1), vs2, vm  # unordered 64-bit indexed load of SEW data

    # Vector indexed-ordered load instructions
    # vd destination, rs1 base address, vs2 indices
    vloxei8.v    vd, (rs1), vs2, vm  # ordered  8-bit indexed load of SEW data
    vloxei16.v   vd, (rs1), vs2, vm  # ordered 16-bit indexed load of SEW data
    vloxei32.v   vd, (rs1), vs2, vm  # ordered 32-bit indexed load of SEW data
    vloxei64.v   vd, (rs1), vs2, vm  # ordered 64-bit indexed load of SEW data

    # Vector indexed-unordered store instructions
    # vs3 store data, rs1 base address, vs2 indices
    vsuxei8.v   vs3, (rs1), vs2, vm # unordered  8-bit indexed store of SEW data
    vsuxei16.v  vs3, (rs1), vs2, vm # unordered 16-bit indexed store of SEW data
    vsuxei32.v  vs3, (rs1), vs2, vm # unordered 32-bit indexed store of SEW data
    vsuxei64.v  vs3, (rs1), vs2, vm # unordered 64-bit indexed store of SEW data

    # Vector indexed-ordered store instructions
    # vs3 store data, rs1 base address, vs2 indices
    vsoxei8.v    vs3, (rs1), vs2, vm  # ordered  8-bit indexed store of SEW data
    vsoxei16.v   vs3, (rs1), vs2, vm  # ordered 16-bit indexed store of SEW data
    vsoxei32.v   vs3, (rs1), vs2, vm  # ordered 32-bit indexed store of SEW data
    vsoxei64.v   vs3, (rs1), vs2, vm  # ordered 64-bit indexed store of SEW data</screen>
<note>
<simpara>The assembler syntax for indexed loads and stores uses
<literal>ei</literal><emphasis>x</emphasis> instead of <literal>e</literal><emphasis>x</emphasis> to indicate the statically encoded EEW
is of the index not the data.</simpara>
</note>
<note>
<simpara>The indexed operations mnemonics have a "U" or "O" to
distinguish between unordered and ordered, while the other vector
addressing modes have no character. While this is perhaps a little
less consistent, this approach minimizes disruption to existing
software, as VSXEI previously meant "ordered" - and the opcode can be
retained as an alias during transition to help reduce software churn.</simpara>
</note>
</section>
<section xml:id="_unit_stride_fault_only_first_loads">
<title>Unit-stride Fault-Only-First Loads</title>
<simpara>The unit-stride fault-only-first load instructions are used to
vectorize loops with data-dependent exit conditions ("while" loops).
These instructions execute as a regular load except that they will
only take a trap caused by a synchronous exception on element 0.  If
element 0 raises an exception, <literal>vl</literal> is not modified, and the trap is
taken.  If an element &gt; 0 raises an exception, the corresponding trap
is not taken, and the vector length <literal>vl</literal> is reduced to the index of
the element that would have raised an exception.</simpara>
<simpara>Load instructions may overwrite active destination vector register
group elements past the element index at which the trap is reported.
Similarly, fault-only-first load instructions may update destination
elements past the element that causes trimming of the vector length
(but not past the original vector length).  The values of these
spurious updates do not have to correspond to the values in memory at
the addressed memory locations.  Non-idempotent memory locations can
only be accessed when it is known the corresponding element load
operation will not be restarted due to a trap or vector length
trimming.</simpara>
<screen>    # Vector unit-stride fault-only-first loads

    # vd destination, rs1 base address, vm is mask encoding (v0.t or &lt;missing&gt;)
    vle8ff.v    vd, (rs1), vm  #    8-bit unit-stride fault-only-first load
    vle16ff.v   vd, (rs1), vm  #   16-bit unit-stride fault-only-first load
    vle32ff.v   vd, (rs1), vm  #   32-bit unit-stride fault-only-first load
    vle64ff.v   vd, (rs1), vm  #   64-bit unit-stride fault-only-first load
    # vle128ff.v  vd, (rs1), vm  #  128-bit unit-stride fault-only-first load. Reserved
    # vle256ff.v  vd, (rs1), vm  #  256-bit unit-stride fault-only-first load. Reserved
    # vle512ff.v  vd, (rs1), vm  #  512-bit unit-stride fault-only-first load. Reserved
    # vle1024ff.v vd, (rs1), vm  # 1024-bit unit-stride fault-only-first load. Reserved</screen>
<screen>strlen example using unit-stride fault-only-first instruction

# size_t strlen(const char *str)
# a0 holds *str

strlen:
    mv a3, a0             # Save start
loop:
    vsetvli a1, x0, e8, m8, ta, ma  # Vector of bytes of maximum length
    vle8ff.v v8, (a3)      # Load bytes
    csrr a1, vl           # Get bytes read
    vmseq.vi v0, v8, 0    # Set v0[i] where v8[i] = 0
    vfirst.m a2, v0       # Find first set bit
    add a3, a3, a1        # Bump pointer
    bltz a2, loop         # Not found?

    add a0, a0, a1        # Sum start + bump
    add a3, a3, a2        # Add index
    sub a0, a3, a0        # Subtract start address+bump

    ret</screen>
<note>
<simpara>There is a security concern with fault-on-first loads, as they
can be used to probe for valid effective addresses.  Strided and
scatter/gather fault-only-first instructions are not provided due to
lack of encoding space, and they can also represent a larger security
hole, allowing software to easily check multiple random pages for
accessibility without experiencing a trap. The unit-stride versions
only allow probing a region immediately contiguous to a known region,
and so do not appreciably impact security.  It is possible that
security mitigations can be implemented to allow fault-only-first
variants of non-contiguous accesses in future vector extensions.</simpara>
</note>
<simpara>Even when an exception is not raised, implementations are permitted to process
fewer than <literal>vl</literal> elements and reduce <literal>vl</literal> accordingly, but if <literal>vstart</literal>=0 and
<literal>vl</literal>&gt;0, then at least one element must be processed.</simpara>
<simpara>When the fault-only-first instruction takes a trap due to an
interrupt, implementations should not reduce <literal>vl</literal> and should instead
set a <literal>vstart</literal> value.</simpara>
<note>
<simpara>When the fault-only-first instruction would trigger a debug
data-watchpoint trap on an element after the first, implementations
should not reduce <literal>vl</literal> but instead should trigger the debug trap as
otherwise the event might be lost.</simpara>
</note>
</section>
<section xml:id="sec-aos">
<title>Vector Load/Store Segment Instructions</title>
<simpara>This instruction subset is given the ISA string name <literal>Zvlsseg</literal>.</simpara>
<simpara>The vector load/store segment instructions move multiple contiguous
fields in memory to and from consecutively numbered vector registers.</simpara>
<note>
<simpara>These operations support operations on "array-of-structures"
datatypes by unpacking each field in a structure into separate vector
registers.</simpara>
</note>
<simpara>The three-bit <literal>nf</literal> field in the vector instruction encoding is an
unsigned integer that contains one less than the number of fields per
segment, <emphasis>NFIELDS</emphasis>.</simpara>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="6.25*"/>
<colspec colname="col_2" colwidth="6.25*"/>
<colspec colname="col_3" colwidth="6.25*"/>
<colspec colname="col_4" colwidth="81.25*"/>
<thead>
<row>
<entry align="left" nameend="col_3" namest="col_1" valign="top">nf[2:0]</entry>
<entry align="left" valign="top">NFIELDS</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The EMUL setting must be such that EMUL * NFIELDS ≤ 8, otherwise
the instruction encoding is reserved.</simpara>
<note>
<simpara>The product EMUL * NFIELDS represents the number of underlying
vector registers that will be touched by a segmented load or store
instruction.  This constraint makes this total no larger than 1/4 of
the architectural register file, and the same as for regular
operations with EMUL=8.</simpara>
</note>
<simpara>Each field will be held in successively numbered vector register
groups.  When EMUL&gt;1, each field will occupy a vector register group
held in multiple successively numbered vector registers, and the
vector register group for each field must follow the usual vector
register alignment constraints (e.g., when EMUL=2 and NFIELDS=4, each
field’s vector register group must start at an even vector register,
but does not have to start at a multiple of 8 vector register number).</simpara>
<simpara>If the vector register numbers accessed by the segment load or store
would increment past 31, then the instruction encoding is reserved.</simpara>
<note>
<simpara>This constraint is to help allow for forward-compatibility with
a possible future longer instruction encoding that has more
addressable vector registers.</simpara>
</note>
<simpara>The <literal>vl</literal> register gives the number of structures to move, which is
equal to the number of elements transferred to each vector register
group.  Masking is also applied at the level of whole structures.</simpara>
<simpara>For segment loads and stores, the individual memory accesses used to
access fields within each segment are unordered with respect to each
other even for ordered indexed segment loads and stores.</simpara>
<simpara>If a trap is taken, <literal>vstart</literal> is in units of structures.
If a trap occurs partway through accessing a structure, it is
implementation-defined whether a subset of the structure access is performed.</simpara>
<section xml:id="_vector_unit_stride_segment_loads_and_stores">
<title>Vector Unit-Stride Segment Loads and Stores</title>
<simpara>The vector unit-stride load and store segment instructions move packed
contiguous segments ("array-of-structures") into multiple destination
vector register groups.</simpara>
<note>
<simpara>For structures with heterogeneous-sized fields, software can
later unpack structure fields from a segment using additional
instructions after the segment load brings data into the vector
registers.</simpara>
</note>
<simpara>The assembler prefixes <literal>vlseg</literal>/<literal>vsseg</literal> are used for unit-stride
segment loads and stores respectively.</simpara>
<screen>    # Format
    vlseg&lt;nf&gt;e&lt;eew&gt;.v vd, (rs1), vm       # Unit-stride segment load template
    vsseg&lt;nf&gt;e&lt;eew&gt;.v vs3, (rs1), vm       # Unit-stride segment store template

    # Examples
    vlseg8e8.v vd, (rs1), vm   # Load eight vector registers with eight byte fields.

    vsseg3e32.v vs3, (rs1), vm  # Store packed vector of 3*4-byte segments from vs3,vs3+1,vs3+2 to memory</screen>
<simpara>For loads, the <literal>vd</literal> register will hold the first field loaded from the
segment.  For stores, the <literal>vs3</literal> register is read to provide the first
field to be stored in each segment.</simpara>
<screen>    # Example 1
    # Memory structure holds packed RGB pixels (24-bit data structure, 8bpp)
    vsetvli a1, t0, e8, ta, ma
    vlseg3e8.v v8, (a0), vm
    # v8 holds the red pixels
    # v9 holds the green pixels
    # v10 holds the blue pixels

    # Example 2
    # Memory structure holds complex values, 32b for real and 32b for imaginary
    vsetvli a1, t0, e32, ta, ma
    vlseg2e32.v v8, (a0), vm
    # v8 holds real
    # v9 holds imaginary</screen>
<simpara>There are also fault-only-first versions of the unit-stride instructions.</simpara>
<screen>    # Template for vector fault-only-first unit-stride segment loads.
    vlseg&lt;nf&gt;e&lt;eew&gt;ff.v vd, (rs1),  vm          # Unit-stride fault-only-first segment loads</screen>
<simpara>For fault-only-first segment loads, if an exception is detected partway
through accessing a segment, regardless of whether the element index is zero,
it is implementation-defined whether a subset of the segment is loaded.</simpara>
<simpara>These instructions may overwrite destination vector register group
elements past the point at which a trap is reported or past the point
at which vector length is trimmed.</simpara>
</section>
<section xml:id="_vector_strided_segment_loads_and_stores">
<title>Vector Strided Segment Loads and Stores</title>
<simpara>Vector strided segment loads and stores move contiguous segments where
each segment is separated by the byte-stride offset given in the <literal>rs2</literal>
GPR argument.</simpara>
<note>
<simpara>Negative and zero strides are supported.</simpara>
</note>
<screen>    # Format
    vlsseg&lt;nf&gt;e&lt;eew&gt;.v vd, (rs1), rs2, vm          # Strided segment loads
    vssseg&lt;nf&gt;e&lt;eew&gt;.v vs3, (rs1), rs2, vm         # Strided segment stores

    # Examples
    vsetvli a1, t0, e8, ta, ma
    vlsseg3e8.v v4, (x5), x6   # Load bytes at addresses x5+i*x6   into v4[i],
                              #  and bytes at addresses x5+i*x6+1 into v5[i],
                              #  and bytes at addresses x5+i*x6+2 into v6[i].

    # Examples
    vsetvli a1, t0, e32, ta, ma
    vssseg2e32.v v2, (x5), x6   # Store words from v2[i] to address x5+i*x6
                                #   and words from v3[i] to address x5+i*x6+4</screen>
<simpara>Accesses to the fields within each segment can occur in any order,
including the case where the byte stride is such that segments overlap
in memory.</simpara>
</section>
<section xml:id="_vector_indexed_segment_loads_and_stores">
<title>Vector Indexed Segment Loads and Stores</title>
<simpara>Vector indexed segment loads and stores move contiguous segments where
each segment is located at an address given by adding the scalar base
address in the <literal>rs1</literal> field to byte offsets in vector register <literal>vs2</literal>.
Both ordered and unordered forms are provided, where the ordered forms
access segments in element order.  However, even for the ordered form,
accesses to the fields within an individual segment are not ordered
with respect to each other.</simpara>
<simpara>The data vector register group has EEW=SEW, EMUL=LMUL, while the index
vector register group has EEW encoded in the instruction with
EMUL=(EEW/SEW)*LMUL.</simpara>
<screen>    # Format
    vluxseg&lt;nf&gt;ei&lt;eew&gt;.v vd, (rs1), vs2, vm   # Indexed-unordered segment loads
    vloxseg&lt;nf&gt;ei&lt;eew&gt;.v vd, (rs1), vs2, vm   # Indexed-ordered segment loads
    vsuxseg&lt;nf&gt;ei&lt;eew&gt;.v vs3, (rs1), vs2, vm  # Indexed-unordered segment stores
    vsoxseg&lt;nf&gt;ei&lt;eew&gt;.v vs3, (rs1), vs2, vm  # Indexed-ordered segment stores

    # Examples
    vsetvli a1, t0, e8, ta, ma
    vluxseg3ei32.v v4, (x5), v3   # Load bytes at addresses x5+v3[i]   into v4[i],
                              #  and bytes at addresses x5+v3[i]+1 into v5[i],
                              #  and bytes at addresses x5+v3[i]+2 into v6[i].

    # Examples
    vsetvli a1, t0, e32, ta, ma
    vsuxseg2ei32.v v2, (x5), v5   # Store words from v2[i] to address x5+v5[i]
                              #   and words from v3[i] to address x5+v5[i]+4</screen>
<simpara>For vector indexed segment loads, the destination vector register
groups cannot overlap the source vector register group (specified by
<literal>vs2</literal>), else the instruction encoding is reserved.</simpara>
<note>
<simpara>This constraint supports restart of indexed segment loads
that raise exceptions partway through loading a structure.</simpara>
</note>
</section>
</section>
<section xml:id="_vector_loadstore_whole_register_instructions">
<title>Vector Load/Store Whole Register Instructions</title>
<simpara>Format for Vector Load Whole Register Instructions under LOAD-FP major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x07, attr: 'VL*R*'},
  {bits: 5, name: 'vd', attr: 'destination of load', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 8, attr: 'lumop'},
  {bits: 1, name: 1, attr: 'vm'},
  {bits: 2, name: 0x10000, attr: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x27, attr: 'VS*R*'},
  {bits: 5, name: 'vs3', attr: 'store data', type: 2},
  {bits: 3, name: 0x1000},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 8, attr: 'sumop'},
  {bits: 1, name: 1, attr: 'vm'},
  {bits: 2, name: 0x100, attr: 'mop'},
  {bits: 1, name: 0x100, attr: 'mew'},
  {bits: 3, name: 'nf'},
]}</programlisting>
<simpara>These instructions load and store whole vector register groups.</simpara>
<note>
<simpara>These instructions are intended to be used to save and restore
vector registers when the type or length of the current contents of
the vector register is not known, or where modifying <literal>vl</literal> and <literal>vtype</literal>
would be costly. Examples include compiler register spills, vector
function calls where values are passed in vector registers, interrupt
handlers, and OS context switches.  Software can determine the number
of bytes transferred by reading the <literal>vlenb</literal> register.</simpara>
</note>
<simpara>The load instructions have an EEW encoded in the <literal>mew</literal> and <literal>width</literal>
fields following the pattern of regular unit-stride loads.</simpara>
<note>
<simpara>Because in-register byte layouts are identical to in-memory byte
layouts, the same data is written to the destination register group
regardless of EEW.
Hence, it would have sufficed to provide only EEW=8 variants.
The full set of EEW variants is provided so that the encoded EEW can be used
as a hint to indicate the destination register group will next be accessed
with this EEW, which aids implementations that rearrange data internally.</simpara>
</note>
<simpara>The vector whole register store instructions are encoded similar to
unmasked unit-stride store of elements with EEW=8.</simpara>
<simpara>The <literal>nf</literal> field encodes how many vector registers to load and store.
The encoded number of registers must be a power of 2 and the vector
register numbers must be aligned as with a vector register group,
otherwise the instruction encoding is reserved.  The <literal>nf</literal> field
encodes the number of vector registers to transfer, numbered
successively after the base.  Only <literal>nf</literal> values of 1, 2, 4, 8 are
supported, with other values reserved.  When multiple registers are
transferred, the lowest-numbered vector register is held in the
lowest-numbered memory addresses and successive vector register
numbers are placed contiguously in memory.</simpara>
<simpara>The instructions operate with an effective vector length,
<literal>evl</literal>=<literal>nf</literal>*VLEN/EEW, regardless of current settings in <literal>vtype</literal> and
<literal>vl</literal>.  The usual property that no elements are written if <literal>vstart</literal>
≥ <literal>vl</literal> does not apply to these instructions.  Instead, no elements
are written if <literal>vstart</literal> ≥ <literal>evl</literal>.</simpara>
<simpara>The instructions operate similarly to unmasked unit-stride load and
store instructions of elements, with the base address passed in the
scalar <literal>x</literal> register specified by <literal>rs1</literal>.</simpara>
<simpara>Implementations are allowed to raise a misaligned address exception on
whole register loads and stores if the base address is not naturally
aligned to the larger of the size of the encoded EEW in bytes (EEW/8)
or the implementation’s smallest supported SEW size in bytes
(SEW<subscript>MIN</subscript>/8).</simpara>
<note>
<simpara>Allowing misaligned exceptions to be raised based on
non-alignment to encoded EEW simplifies the implementation of these
instructions.  Some subset implementations might not support smaller
SEW widths, so are allowed to report misaligned exceptions for the
smallest supported SEW even if larger than encoded EEW.  An extreme
implementation might have SEW<subscript>MIN</subscript>&gt;XLEN for example.  Software
environments can mandate the minimum alignment requirements to support
an ABI.</simpara>
</note>
<screen>   # Format of whole register load and store instructions.
   vl1r.v v3, (a0)       # Pseudoinstruction equal to vl1re8.v

   vl1re8.v    v3, (a0)  # Load v3 with VLEN/8 bytes held at address in a0
   vl1re16.v   v3, (a0)  # Load v3 with VLEN/16 halfwords held at address in a0
   vl1re32.v   v3, (a0)  # Load v3 with VLEN/32 words held at address in a0
   vl1re64.v   v3, (a0)  # Load v3 with VLEN/64 doublewords held at address in a0
   # vl1re128.v  v3, (a0)
   # vl1re256.v  v3, (a0)
   # vl1re512.v  v3, (a0)
   # vl1re1024.v v3, (a0)

   vl2r.v v2, (a0)       # Pseudoinstruction equal to vl2re8.v v2, (a0)

   vl2re8.v    v2, (a0)  # Load v2-v3 with 2*VLEN/8 bytes from address in a0
   vl2re16.v   v2, (a0)  # Load v2-v3 with 2*VLEN/16 halfwords held at address in a0
   vl2re32.v   v2, (a0)  # Load v2-v3 with 2*VLEN/32 words held at address in a0
   vl2re64.v   v2, (a0)  # Load v2-v3 with 2*VLEN/64 doublewords held at address in a0
   # vl2re128.v  v2, (a0)
   # vl2re256.v  v2, (a0)
   # vl2re512.v  v2, (a0)
   # vl2re1024.v v2, (a0)

   vl4r.v v4, (a0)       # Pseudoinstruction equal to vl4re8.v

   vl4re8.v    v4, (a0)  # Load v4-v7 with 4*VLEN/8 bytes from address in a0
   vl4re16.v   v4, (a0)
   vl4re32.v   v4, (a0)
   vl4re64.v   v4, (a0)
   # vl4re128.v  v4, (a0)
   # vl4re256.v  v4, (a0)
   # vl4re512.v  v4, (a0)
   # vl4re1024.v v4, (a0)

   vl8r.v v8, (a0)       # Pseudoinstruction equal to vl8re8.v

   vl8re8.v    v8, (a0)  # Load v8-v15 with 8*VLEN/8 bytes from address in a0
   vl8re16.v   v8, (a0)
   vl8re32.v   v8, (a0)
   vl8re64.v   v8, (a0)
   # vl8re128.v  v8, (a0)
   # vl8re256.v  v8, (a0)
   # vl8re512.v  v8, (a0)
   # vl8re1024.v v8, (a0)

   vs1r.v v3, (a1)      # Store v3 to address in a1
   vs2r.v v2, (a1)      # Store v2-v3 to address in a1
   vs4r.v v4, (a1)      # Store v4-v7 to address in a1
   vs8r.v v8, (a1)      # Store v8-v15 to address in a1</screen>
<note>
<simpara>Implementations should raise illegal instruction exceptions on
<literal>vl&lt;nf&gt;r</literal> instructions for EEW values that are not supported.</simpara>
</note>
<note>
<simpara>We have considered adding a whole register mask load
instruction (<literal>vl1re1.v vd, (rs1)</literal>) as a mask hint but this is not currently on
PoR.</simpara>
</note>
</section>
</section>
<section xml:id="_vector_memory_alignment_constraints">
<title>Vector Memory Alignment Constraints</title>
<simpara>If an element accessed by a vector memory instruction is not naturally
aligned to the size of the element, either the element is transferred
successfully or an address misaligned exception is raised on that
element.</simpara>
<simpara>Support for misaligned vector memory accesses is independent of an
implementation’s support for misaligned scalar memory accesses.</simpara>
<note>
<simpara>An implementation may have neither, one, or both scalar and
vector memory accesses support some or all misaligned accesses in
hardware.  A separate PMA should be defined to determine if vector
misaligned accesses are supported in the associated address range.</simpara>
</note>
<simpara>Vector misaligned memory accesses follow the same rules for atomicity
as scalar misaligned memory accesses.</simpara>
</section>
<section xml:id="_vector_memory_consistency_model">
<title>Vector Memory Consistency Model</title>
<simpara>Vector memory instructions appear to execute in program order on the
local hart.</simpara>
<simpara>Vector memory instructions follow RVWMO at the instruction level.</simpara>
<simpara>Except for vector indexed-ordered loads and stores, element operations
are unordered within the instruction.</simpara>
<simpara>Vector indexed-ordered loads and stores read and write elements
from/to memory in element order respectively.</simpara>
<note>
<simpara>More formal definitions required.</simpara>
</note>
<simpara>Instructions affected by the vector length register <literal>vl</literal> have a control
dependency on <literal>vl</literal>, rather than a data dependency.
Similarly, masked vector instructions have a control dependency on the source
mask register, rather than a data dependency.</simpara>
<note>
<simpara>Treating the vector length and mask as control rather than data
typically matches the semantics of the corresponding scalar code, where branch
instructions ordinarily would have been used.
Treating the mask as control allows masked vector load instructions to access
memory before the mask value is known, without the need for
a misspeculation-recovery mechanism.</simpara>
</note>
</section>
<section xml:id="_vector_arithmetic_instruction_formats">
<title>Vector Arithmetic Instruction Formats</title>
<simpara>The vector arithmetic instructions use a new major opcode (OP-V =
1010111<subscript>2</subscript>) which neighbors OP-FP.  The three-bit <literal>funct3</literal> field is
used to define sub-categories of vector instructions.</simpara>
<simpara>Formats for Vector Arithmetic Instructions under OP-V major opcode</simpara>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPIVV'},
  {bits: 5, name: 'vd', type: 2},
  {bits: 3, name: 0},
  {bits: 5, name: 'vs1', type: 2},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPFVV'},
  {bits: 5, name: 'vd / rd', type: 7},
  {bits: 3, name: 1},
  {bits: 5, name: 'vs1', type: 2},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPMVV'},
  {bits: 5, name: 'vd / rd', type: 7},
  {bits: 3, name: 2},
  {bits: 5, name: 'vs1', type: 2},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: ['OPIVI']},
  {bits: 5, name: 'vd', type: 2},
  {bits: 3, name: 3},
  {bits: 5, name: 'simm5', type: 5},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPIVX'},
  {bits: 5, name: 'vd', type: 2},
  {bits: 3, name: 4},
  {bits: 5, name: 'rs1', type: 4},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPFVF'},
  {bits: 5, name: 'vd', type: 2},
  {bits: 3, name: 5},
  {bits: 5, name: 'rs1', type: 4},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<programlisting language="wavedrom" linenumbering="unnumbered">{reg: [
  {bits: 7, name: 0x57, attr: 'OPMVX'},
  {bits: 5, name: 'vd / rd', type: 7},
  {bits: 3, name: 6},
  {bits: 5, name: 'rs1', type: 4},
  {bits: 5, name: 'vs2', type: 2},
  {bits: 1, name: 'vm'},
  {bits: 6, name: 'funct6'},
]}</programlisting>
<section xml:id="sec-arithmetic-encoding">
<title>Vector Arithmetic Instruction encoding</title>
<simpara>The <literal>funct3</literal> field encodes the operand type and source locations.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>funct3</title>
<tgroup cols="6">
<colspec colname="col_1" colwidth="6.25*"/>
<colspec colname="col_2" colwidth="6.25*"/>
<colspec colname="col_3" colwidth="6.25*"/>
<colspec colname="col_4" colwidth="18.75*"/>
<colspec colname="col_5" colwidth="31.25*"/>
<colspec colname="col_6" colwidth="31.25*"/>
<thead>
<row>
<entry align="left" nameend="col_3" namest="col_1" valign="top">funct3[2:0]</entry>
<entry align="left" valign="top">Category</entry>
<entry align="left" valign="top">Operands</entry>
<entry align="left" valign="top">Type of scalar operand</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>OPIVV</simpara></entry>
<entry align="left" valign="top"><simpara>vector-vector</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>OPFVV</simpara></entry>
<entry align="left" valign="top"><simpara>vector-vector</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>OPMVV</simpara></entry>
<entry align="left" valign="top"><simpara>vector-vector</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>OPIVI</simpara></entry>
<entry align="left" valign="top"><simpara>vector-immediate</simpara></entry>
<entry align="left" valign="top"><simpara><literal>imm[4:0]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>OPIVX</simpara></entry>
<entry align="left" valign="top"><simpara>vector-scalar</simpara></entry>
<entry align="left" valign="top"><simpara>GPR <literal>x</literal> register <literal>rs1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>OPFVF</simpara></entry>
<entry align="left" valign="top"><simpara>vector-scalar</simpara></entry>
<entry align="left" valign="top"><simpara>FP <literal>f</literal> register <literal>rs1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>OPMVX</simpara></entry>
<entry align="left" valign="top"><simpara>vector-scalar</simpara></entry>
<entry align="left" valign="top"><simpara>GPR <literal>x</literal> register <literal>rs1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>OPCFG</simpara></entry>
<entry align="left" valign="top"><simpara>scalars-imms</simpara></entry>
<entry align="left" valign="top"><simpara>GPR <literal>x</literal> register <literal>rs1</literal> &amp; <literal>rs2</literal>/<literal>imm</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Integer operations are performed using unsigned or two’s-complement
signed integer arithmetic depending on the opcode.</simpara>
<note>
<simpara>In this discussion, fixed-point operations are
considered to be integer operations.</simpara>
</note>
<simpara>All standard vector floating-point arithmetic operations follow the
IEEE-754/2008 standard.  All vector floating-point operations use the
dynamic rounding mode in the <literal>frm</literal> register.  Use of the <literal>frm</literal> field
when it contains an invalid rounding mode by any vector floating-point
instruction, even those that do not depend on the rounding mode, or
when <literal>vl</literal>=0, or when <literal>vstart</literal> ≥ <literal>vl</literal>, is reserved.</simpara>
<note>
<simpara>All vector floating-point code will rely on a valid value in
<literal>frm</literal>.  Implementations can make all vector FP instructions report
exceptions when the rounding mode is invalid to simplify control
logic.</simpara>
</note>
<simpara>Vector-vector operations take two vectors of operands from vector
register groups specified by <literal>vs2</literal> and <literal>vs1</literal> respectively.</simpara>
<simpara>Vector-scalar operations can have three possible forms, but in all
cases take one vector of operands from a vector register group
specified by <literal>vs2</literal> and a second scalar source operand from one of
three alternative sources.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>For integer operations, the scalar can be a 5-bit immediate encoded
in the <literal>rs1</literal> field.  The value is sign-extended to SEW bits, unless
otherwise specified.  . For integer operations, the scalar can be
taken from the scalar <literal>x</literal> register specified by <literal>rs1</literal>.  If XLEN&gt;SEW,
the least-significant SEW bits of the <literal>x</literal> register are used, unless
otherwise specified.  If XLEN&lt;SEW, the value from the <literal>x</literal> register is
sign-extended to SEW bits.  For floating-point operations, the
scalar can be taken from a scalar <literal>f</literal> register.  If FLEN &gt; SEW, the
value in the <literal>f</literal> registers is checked for a valid NaN-boxed value, in
which case the least-significant SEW bits of the <literal>f</literal> register are
used, else the canonical NaN value is used.  Vector instructions where
any floating-point vector operand’s EEW is not a supported
floating-point type width (which includes when FLEN &lt; SEW) are
reserved.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Some instructions <emphasis>zero</emphasis>-extend the 5-bit immediate, and denote this
by naming the immediate <literal>uimm</literal> in the assembly syntax.</simpara>
</note>
<note>
<simpara>The proposed Zfinx variants will take the floating-point scalar
argument from the <literal>x</literal> registers.</simpara>
</note>
<simpara>Vector arithmetic instructions are masked under control of the <literal>vm</literal>
field.</simpara>
<screen># Assembly syntax pattern for vector binary arithmetic instructions

# Operations returning vector results, masked by vm (v0.t, &lt;nothing&gt;)
vop.vv  vd, vs2, vs1, vm  # integer vector-vector      vd[i] = vs2[i] op vs1[i]
vop.vx  vd, vs2, rs1, vm  # integer vector-scalar      vd[i] = vs2[i] op x[rs1]
vop.vi  vd, vs2, imm, vm  # integer vector-immediate   vd[i] = vs2[i] op imm

vfop.vv  vd, vs2, vs1, vm # FP vector-vector operation vd[i] = vs2[i] fop vs1[i]
vfop.vf  vd, vs2, rs1, vm # FP vector-scalar operation vd[i] = vs2[i] fop f[rs1]</screen>
<note>
<simpara>In the encoding, <literal>vs2</literal> is the first operand, while <literal>rs1/imm</literal>
is the second operand. This is the opposite to the standard scalar
ordering.  This arrangement retains the existing encoding conventions
that instructions that read only one scalar register, read it from
<literal>rs1</literal>, and that 5-bit immediates are sourced from the <literal>rs1</literal> field.</simpara>
</note>
<screen># Assembly syntax pattern for vector ternary arithmetic instructions (multiply-add)

# Integer operations overwriting sum input
vop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vs2[i] + vd[i]
vop.vx vd, rs1, vs2, vm  # vd[i] = x[rs1] * vs2[i] + vd[i]

# Integer operations overwriting product input
vop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vd[i] + vs2[i]
vop.vx vd, rs1, vs2, vm  # vd[i] = x[rs1] * vd[i] + vs2[i]

# Floating-point operations overwriting sum input
vfop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vs2[i] + vd[i]
vfop.vf vd, rs1, vs2, vm  # vd[i] = f[rs1] * vs2[i] + vd[i]

# Floating-point operations overwriting product input
vfop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vd[i] + vs2[i]
vfop.vf vd, rs1, vs2, vm  # vd[i] = f[rs1] * vd[i] + vs2[i]</screen>
<note>
<simpara>For ternary multiply-add operations, the assembler syntax always
places the destination vector register first, followed by either <literal>rs1</literal>
or <literal>vs1</literal>, then <literal>vs2</literal>.  This ordering provides a more natural reading
of the assembler for these ternary operations, as the multiply
operands are always next to each other.</simpara>
</note>
</section>
<section xml:id="sec-widening">
<title>Widening Vector Arithmetic Instructions</title>
<simpara>A few vector arithmetic instructions are defined to be <emphasis>widening</emphasis>
operations where the destination vector register group has EEW=2*SEW and
EMUL=2*LMUL.</simpara>
<simpara>The first vector register group operand can be either single or
double-width. These are generally written with a <literal>vw*</literal> prefix on the
opcode or <literal>vfw*</literal> for vector floating-point operations.</simpara>
<screen>Assembly syntax pattern for vector widening arithmetic instructions

# Double-width result, two single-width sources: 2*SEW = SEW op SEW
vwop.vv  vd, vs2, vs1, vm  # integer vector-vector      vd[i] = vs2[i] op vs1[i]
vwop.vx  vd, vs2, rs1, vm  # integer vector-scalar      vd[i] = vs2[i] op x[rs1]

# Double-width result, first source double-width, second source single-width: 2*SEW = 2*SEW op SEW
vwop.wv  vd, vs2, vs1, vm  # integer vector-vector      vd[i] = vs2[i] op vs1[i]
vwop.wx  vd, vs2, rs1, vm  # integer vector-scalar      vd[i] = vs2[i] op x[rs1]</screen>
<note>
<simpara>Originally, a <literal>w</literal> suffix was used on opcode, but this could be
confused with the use of a <literal>w</literal> suffix to mean word-sized operations in
doubleword integers, so the <literal>w</literal> was moved to prefix.</simpara>
</note>
<note>
<simpara>The floating-point widening operations were changed to <literal>vfw*</literal>
from <literal>vwf*</literal> to be more consistent with any scalar widening
floating-point operations that will be written as <literal>fw*</literal>.</simpara>
</note>
<note>
<simpara>For integer multiply-add, another possible widening option
increases the size of the accumulator to EEW=4*SEW (i.e., 4*SEW +=
SEW*SEW).  These would be distinguished by a <literal>vq*</literal> prefix on the
opcode, for quad-widening.  These are not included at this time, but
are a possible addition in a future extension.</simpara>
</note>
<simpara>For all widening instructions, the destination EEW and EMUL values
must be a supported configuration, otherwise the instruction encoding
is reserved.</simpara>
<simpara>The destination vector register group must be specified using a vector
register number that is valid for the destination’s EMUL, otherwise the
instruction encoding is reserved.</simpara>
<note>
<simpara>This constraint is necessary to support restart with non-zero
<literal>vstart</literal>.</simpara>
</note>
<note>
<simpara>For the <literal>vw&lt;op&gt;.wv vd, vs2, vs1</literal> format instructions, it is legal
for vd to equal vs2.</simpara>
</note>
</section>
<section xml:id="sec-narrowing">
<title>Narrowing Vector Arithmetic Instructions</title>
<simpara>A few instructions are provided to convert double-width source vectors
into single-width destination vectors.  These instructions convert a
vector register group with EEW/EMUL=2*SEW/2*LMUL to a vector register
group with the current SEW/LMUL setting.</simpara>
<simpara>If EEW &gt; ELEN or EMUL &gt; 8, the instruction encoding is reserved.</simpara>
<note>
<simpara>An alternative design decision would have been to treat SEW/LMUL
as defining the size of the source vector register group.  The choice
here is motivated by the belief the chosen approach will require fewer
<literal>vtype</literal> changes.</simpara>
</note>
<simpara>The source and destination vector register groups have to be specified
with a vector register number that is legal for the source and
destination EMUL values respectively, otherwise the instruction
encoding is reserved.</simpara>
<simpara>Where there is a second source vector register group (specified by
<literal>vs1</literal>), this has the same (narrower) width as the result (i.e.,
EEW=SEW).</simpara>
<note>
<simpara>It is safe to overwrite a second source vector register group
with the same EEW and EMUL as the result.</simpara>
</note>
<simpara>A <literal>vn*</literal> prefix on the opcode is used to distinguish these instructions
in the assembler, or a <literal>vfn*</literal> prefix for narrowing floating-point
opcodes.  The double-width source vector register group is signified
by a <literal>w</literal> in the source operand suffix (e.g., <literal>vnsra.wv</literal>)</simpara>
<note>
<simpara>Comparison operations that set a mask register are also
implicitly a narrowing operation.</simpara>
</note>
</section>
</section>
<section xml:id="sec-vector-integer">
<title>Vector Integer Arithmetic Instructions</title>
<simpara>A set of vector integer arithmetic instructions is provided.</simpara>
<section xml:id="_vector_single_width_integer_add_and_subtract">
<title>Vector Single-Width Integer Add and Subtract</title>
<simpara>Vector integer add and subtract are provided.  Reverse-subtract
instructions are also provided for the vector-scalar forms.</simpara>
<screen># Integer adds.
vadd.vv vd, vs2, vs1, vm   # Vector-vector
vadd.vx vd, vs2, rs1, vm   # vector-scalar
vadd.vi vd, vs2, imm, vm   # vector-immediate

# Integer subtract
vsub.vv vd, vs2, vs1, vm   # Vector-vector
vsub.vx vd, vs2, rs1, vm   # vector-scalar

# Integer reverse subtract
vrsub.vx vd, vs2, rs1, vm   # vd[i] = x[rs1] - vs2[i]
vrsub.vi vd, vs2, imm, vm   # vd[i] = imm - vs2[i]</screen>
<note>
<simpara>A vector of integer values can be negated using a
reverse-subtract instruction with a scalar operand of <literal>x0</literal>. Can define
assembly pseudoinstruction <literal>vneg.v vd,vs</literal> = <literal>vrsub.vx vd,vs,x0</literal>.</simpara>
</note>
</section>
<section xml:id="_vector_widening_integer_addsubtract">
<title>Vector Widening Integer Add/Subtract</title>
<simpara>The widening add/subtract instructions are provided in both signed and
unsigned variants, depending on whether the narrower source operands
are first sign- or zero-extended before forming the double-width sum.</simpara>
<screen># Widening unsigned integer add/subtract, 2*SEW = SEW +/- SEW
vwaddu.vv  vd, vs2, vs1, vm  # vector-vector
vwaddu.vx  vd, vs2, rs1, vm  # vector-scalar
vwsubu.vv  vd, vs2, vs1, vm  # vector-vector
vwsubu.vx  vd, vs2, rs1, vm  # vector-scalar

# Widening signed integer add/subtract, 2*SEW = SEW +/- SEW
vwadd.vv  vd, vs2, vs1, vm  # vector-vector
vwadd.vx  vd, vs2, rs1, vm  # vector-scalar
vwsub.vv  vd, vs2, vs1, vm  # vector-vector
vwsub.vx  vd, vs2, rs1, vm  # vector-scalar

# Widening unsigned integer add/subtract, 2*SEW = 2*SEW +/- SEW
vwaddu.wv  vd, vs2, vs1, vm  # vector-vector
vwaddu.wx  vd, vs2, rs1, vm  # vector-scalar
vwsubu.wv  vd, vs2, vs1, vm  # vector-vector
vwsubu.wx  vd, vs2, rs1, vm  # vector-scalar

# Widening signed integer add/subtract, 2*SEW = 2*SEW +/- SEW
vwadd.wv  vd, vs2, vs1, vm  # vector-vector
vwadd.wx  vd, vs2, rs1, vm  # vector-scalar
vwsub.wv  vd, vs2, vs1, vm  # vector-vector
vwsub.wx  vd, vs2, rs1, vm  # vector-scalar</screen>
<note>
<simpara>An integer value can be doubled in width using the widening add
instructions with a scalar operand of <literal>x0</literal>.  Can define assembly
pseudoinstructions <literal>vwcvt.x.x.v vd,vs,vm = vwadd.vx vd,vs,x0,vm</literal> and
<literal>vwcvtu.x.x.v vd,vs,vm = vwaddu.vx vd,vs,x0,vm</literal>.</simpara>
</note>
</section>
<section xml:id="_vector_integer_extension">
<title>Vector Integer Extension</title>
<simpara>The vector integer extension instructions zero- or sign-extend a
source vector integer operand with EEW less than SEW to fill SEW-sized
elements in the destination.  The EEW of the source is 1/2, 1/4, or
1/8 of SEW, while EMUL of the source is (EEW/SEW)*LMUL.  The
destination has EEW equal to SEW and EMUL equal to LMUL.</simpara>
<screen>vzext.vf2 vd, vs2, vm  # Zero-extend SEW/2 source to SEW destination
vsext.vf2 vd, vs2, vm  # Sign-extend SEW/2 source to SEW destination
vzext.vf4 vd, vs2, vm  # Zero-extend SEW/4 source to SEW destination
vsext.vf4 vd, vs2, vm  # Sign-extend SEW/4 source to SEW destination
vzext.vf8 vd, vs2, vm  # Zero-extend SEW/8 source to SEW destination
vsext.vf8 vd, vs2, vm  # Sign-extend SEW/8 source to SEW destination</screen>
<simpara>If the source EEW is not a supported width, or source EMUL would be
below the minimum legal LMUL, the instruction encoding is reserved.</simpara>
</section>
<section xml:id="_vector_integer_add_with_carry_subtract_with_borrow_instructions">
<title>Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions</title>
<simpara>To support multi-word integer arithmetic, instructions that operate on
a carry bit are provided.  For each operation (add or subtract), two
instructions are provided: one to provide the result (SEW width), and
the second to generate the carry output (single bit encoded as a mask
boolean).</simpara>
<simpara>The carry inputs and outputs are represented using the mask register
layout as described in Section <xref linkend="sec-mask-register-layout"/>.  Due to
encoding constraints, the carry input must come from the implicit <literal>v0</literal>
register, but carry outputs can be written to any vector register that
respects the source/destination overlap restrictions.</simpara>
<simpara><literal>vadc</literal> and <literal>vsbc</literal> add or subtract the source operands and the carry-in or
borrow-in, and write the result to vector register <literal>vd</literal>.
These instructions are encoded as masked instructions (<literal>vm=0</literal>), but they operate
on and write back all body elements.
Encodings corresponding to the unmasked versions (<literal>vm=1</literal>) are reserved.</simpara>
<simpara><literal>vmadc</literal> and <literal>vmsbc</literal> add or subtract the source operands, optionally
add the carry-in or subtract the borrow-in if masked (<literal>vm=0</literal>), and
write the result back to mask register <literal>vd</literal>.  If unmasked (<literal>vm=1</literal>),
there is no carry-in or borrow-in.  These instructions operate on and
write back all body elements, even if masked.  Because these
instructions produce a mask value, they always operate with a
tail-agnostic policy.</simpara>
<screen> # Produce sum with carry.

 # vd[i] = vs2[i] + vs1[i] + v0.mask[i]
 vadc.vvm   vd, vs2, vs1, v0  # Vector-vector

 # vd[i] = vs2[i] + x[rs1] + v0.mask[i]
 vadc.vxm   vd, vs2, rs1, v0  # Vector-scalar

 # vd[i] = vs2[i] + imm + v0.mask[i]
 vadc.vim   vd, vs2, imm, v0  # Vector-immediate

 # Produce carry out in mask register format

 # vd.mask[i] = carry_out(vs2[i] + vs1[i] + v0.mask[i])
 vmadc.vvm   vd, vs2, vs1, v0  # Vector-vector

 # vd.mask[i] = carry_out(vs2[i] + x[rs1] + v0.mask[i])
 vmadc.vxm   vd, vs2, rs1, v0  # Vector-scalar

 # vd.mask[i] = carry_out(vs2[i] + imm + v0.mask[i])
 vmadc.vim   vd, vs2, imm, v0  # Vector-immediate

 # vd.mask[i] = carry_out(vs2[i] + vs1[i])
 vmadc.vv    vd, vs2, vs1      # Vector-vector, no carry-in

 # vd.mask[i] = carry_out(vs2[i] + x[rs1])
 vmadc.vx    vd, vs2, rs1      # Vector-scalar, no carry-in

 # vd.mask[i] = carry_out(vs2[i] + imm)
 vmadc.vi    vd, vs2, imm      # Vector-immediate, no carry-in</screen>
<simpara>Because implementing a carry propagation requires executing two
instructions with unchanged inputs, destructive accumulations will
require an additional move to obtain correct results.</simpara>
<screen>  # Example multi-word arithmetic sequence, accumulating into v4
  vmadc.vvm v1, v4, v8, v0  # Get carry into temp register v1
  vadc.vvm v4, v4, v8, v0   # Calc new sum
  vmmv.m v0, v1             # Move temp carry into v0 for next word</screen>
<simpara>The subtract with borrow instruction <literal>vsbc</literal> performs the equivalent
function to support long word arithmetic for subtraction.  There are
no subtract with immediate instructions.</simpara>
<screen> # Produce difference with borrow.

 # vd[i] = vs2[i] - vs1[i] - v0.mask[i]
 vsbc.vvm   vd, vs2, vs1, v0  # Vector-vector

 # vd[i] = vs2[i] - x[rs1] - v0.mask[i]
 vsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar

 # Produce borrow out in mask register format

 # vd.mask[i] = borrow_out(vs2[i] - vs1[i] - v0.mask[i])
 vmsbc.vvm   vd, vs2, vs1, v0  # Vector-vector

 # vd.mask[i] = borrow_out(vs2[i] - x[rs1] - v0.mask[i])
 vmsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar

 # vd.mask[i] = borrow_out(vs2[i] - vs1[i])
 vmsbc.vv    vd, vs2, vs1      # Vector-vector, no borrow-in

 # vd.mask[i] = borrow_out(vs2[i] - x[rs1])
 vmsbc.vx    vd, vs2, rs1      # Vector-scalar, no borrow-in</screen>
<simpara>For <literal>vmsbc</literal>, the borrow is defined to be 1 iff the difference, prior to
truncation, is negative.</simpara>
<simpara>For <literal>vadc</literal> and <literal>vsbc</literal>, the instruction encoding is reserved if the
destination vector register is <literal>v0</literal>.</simpara>
<note>
<simpara>This constraint corresponds to the constraint on masked vector
operations that overwrite the mask register.</simpara>
</note>
</section>
<section xml:id="_vector_bitwise_logical_instructions">
<title>Vector Bitwise Logical Instructions</title>
<screen># Bitwise logical operations.
vand.vv vd, vs2, vs1, vm   # Vector-vector
vand.vx vd, vs2, rs1, vm   # vector-scalar
vand.vi vd, vs2, imm, vm   # vector-immediate

vor.vv vd, vs2, vs1, vm    # Vector-vector
vor.vx vd, vs2, rs1, vm    # vector-scalar
vor.vi vd, vs2, imm, vm    # vector-immediate

vxor.vv vd, vs2, vs1, vm    # Vector-vector
vxor.vx vd, vs2, rs1, vm    # vector-scalar
vxor.vi vd, vs2, imm, vm    # vector-immediate</screen>
<note>
<simpara>With an immediate of -1, scalar-immediate forms of the <literal>vxor</literal>
instruction provide a bitwise NOT operation.  This can be provided as
an assembler pseudoinstruction <literal>vnot.v</literal>.</simpara>
</note>
</section>
<section xml:id="_vector_single_width_bit_shift_instructions">
<title>Vector Single-Width Bit Shift Instructions</title>
<simpara>A full complement of vector shift instructions are provided, including
logical shift left, and logical (zero-extending) and arithmetic
(sign-extending) shift right.  The data to be shifted is in the vector
register group specified by <literal>vs2</literal> and the shift amount can be a vector
register group <literal>vs1</literal>, a scalar integer register <literal>rs1</literal>, or an
immediate.  The low lg2(SEW) bits of the vector or scalar shift-amount
value are used, and shift-amount immediates are zero-extended.</simpara>
<screen># Bit shift operations
vsll.vv vd, vs2, vs1, vm   # Vector-vector
vsll.vx vd, vs2, rs1, vm   # vector-scalar
vsll.vi vd, vs2, uimm, vm   # vector-immediate

vsrl.vv vd, vs2, vs1, vm   # Vector-vector
vsrl.vx vd, vs2, rs1, vm   # vector-scalar
vsrl.vi vd, vs2, uimm, vm   # vector-immediate

vsra.vv vd, vs2, vs1, vm   # Vector-vector
vsra.vx vd, vs2, rs1, vm   # vector-scalar
vsra.vi vd, vs2, uimm, vm   # vector-immediate</screen>
</section>
<section xml:id="_vector_narrowing_integer_right_shift_instructions">
<title>Vector Narrowing Integer Right Shift Instructions</title>
<simpara>The narrowing right shifts extract a smaller field from a wider
operand and have both zero-extending (<literal>srl</literal>) and sign-extending
(<literal>sra</literal>) forms.  The shift amount can come from a vector or a scalar
<literal>x</literal> register or a 5-bit immediate.  The low lg2(2*SEW) bits of the
vector or scalar shift-amount value are used (e.g., the low 6 bits for
a SEW=64-bit to SEW=32-bit narrowing operation).  The immediate forms
zero-extend their shift-amount immediate operand.</simpara>
<screen> # Narrowing shift right logical, SEW = (2*SEW) &gt;&gt; SEW
 vnsrl.wv vd, vs2, vs1, vm   # vector-vector
 vnsrl.wx vd, vs2, rs1, vm   # vector-scalar
 vnsrl.wi vd, vs2, uimm, vm   # vector-immediate

 # Narrowing shift right arithmetic, SEW = (2*SEW) &gt;&gt; SEW
 vnsra.wv vd, vs2, vs1, vm   # vector-vector
 vnsra.wx vd, vs2, rs1, vm   # vector-scalar
 vnsra.wi vd, vs2, uimm, vm   # vector-immediate</screen>
<note>
<simpara>It could be useful to add support for <literal>n4</literal> variants, where the
destination is 1/4 width of source.</simpara>
</note>
<note>
<simpara>An integer value can be halved in width using the narrowing integer
shift instructions with a scalar operand of x0. Can define assembly
pseudoinstructions <literal>vncvt.x.x.w vd,vs,vm</literal> = <literal>vnsrl.wx vd,vs,x0,vm</literal>.</simpara>
</note>
</section>
<section xml:id="_vector_integer_comparison_instructions">
<title>Vector Integer Comparison Instructions</title>
<simpara>The following integer compare instructions write 1 to the destination
mask register element if the comparison evaluates to true, and 0
otherwise.  The destination mask vector is always held in a single
vector register, with a layout of elements as described in Section
<xref linkend="sec-mask-register-layout"/>.  The destination mask vector register
may be the same as the source vector mask register (<literal>v0</literal>).</simpara>
<screen># Set if equal
vmseq.vv vd, vs2, vs1, vm  # Vector-vector
vmseq.vx vd, vs2, rs1, vm  # vector-scalar
vmseq.vi vd, vs2, imm, vm  # vector-immediate

# Set if not equal
vmsne.vv vd, vs2, vs1, vm  # Vector-vector
vmsne.vx vd, vs2, rs1, vm  # vector-scalar
vmsne.vi vd, vs2, imm, vm  # vector-immediate

# Set if less than, unsigned
vmsltu.vv vd, vs2, vs1, vm  # Vector-vector
vmsltu.vx vd, vs2, rs1, vm  # Vector-scalar

# Set if less than, signed
vmslt.vv vd, vs2, vs1, vm  # Vector-vector
vmslt.vx vd, vs2, rs1, vm  # vector-scalar

# Set if less than or equal, unsigned
vmsleu.vv vd, vs2, vs1, vm   # Vector-vector
vmsleu.vx vd, vs2, rs1, vm   # vector-scalar
vmsleu.vi vd, vs2, imm, vm   # Vector-immediate

# Set if less than or equal, signed
vmsle.vv vd, vs2, vs1, vm  # Vector-vector
vmsle.vx vd, vs2, rs1, vm  # vector-scalar
vmsle.vi vd, vs2, imm, vm  # vector-immediate

# Set if greater than, unsigned
vmsgtu.vx vd, vs2, rs1, vm   # Vector-scalar
vmsgtu.vi vd, vs2, imm, vm   # Vector-immediate

# Set if greater than, signed
vmsgt.vx vd, vs2, rs1, vm    # Vector-scalar
vmsgt.vi vd, vs2, imm, vm    # Vector-immediate

# Following two instructions are not provided directly
# Set if greater than or equal, unsigned
# vmsgeu.vx vd, vs2, rs1, vm    # Vector-scalar
# Set if greater than or equal, signed
# vmsge.vx vd, vs2, rs1, vm    # Vector-scalar</screen>
<simpara>The following table indicates how all comparisons are implemented in
native machine code.</simpara>
<screen>Comparison      Assembler Mapping             Assembler Pseudoinstruction

va &lt; vb         vmslt{u}.vv vd, va, vb, vm
va &lt;= vb        vmsle{u}.vv vd, va, vb, vm
va &gt; vb         vmslt{u}.vv vd, vb, va, vm    vmsgt{u}.vv vd, va, vb, vm
va &gt;= vb        vmsle{u}.vv vd, vb, va, vm    vmsge{u}.vv vd, va, vb, vm

va &lt; x          vmslt{u}.vx vd, va, x, vm
va &lt;= x         vmsle{u}.vx vd, va, x, vm
va &gt; x          vmsgt{u}.vx vd, va, x, vm
va &gt;= x         see below

va &lt; i          vmsle{u}.vi vd, va, i-1, vm    vmslt{u}.vi vd, va, i, vm
va &lt;= i         vmsle{u}.vi vd, va, i, vm
va &gt; i          vmsgt{u}.vi vd, va, i, vm
va &gt;= i         vmsgt{u}.vi vd, va, i-1, vm    vmsge{u}.vi vd, va, i, vm

va, vb vector register groups
x      scalar integer register
i      immediate</screen>
<note>
<simpara>The immediate forms of <literal>vmslt{u}.vi</literal> are not provided as the
immediate value can be decreased by 1 and the <literal>vmsle{u}.vi</literal> variants
used instead.  The <literal>vmsle.vi</literal> range is -16 to 15, resulting in an
effective <literal>vmslt.vi</literal> range of -15 to 16.  The <literal>vmsleu.vi</literal> range is 0
to 15 giving an effective <literal>vmsltu.vi</literal> range of 1 to 16 (Note,
<literal>vmsltu.vi</literal> with immediate 0 is not useful as it is always
false). Because the 5-bit vector immediates are always sign-extended,
<literal>vmsleu.vi</literal> also supports unsigned immediate values in the range
<literal>2<superscript>SEW</superscript>-16</literal> to <literal>2<superscript>SEW</superscript>-1</literal>, allowing corresponding <literal>vmsltu.vi</literal>
comparisons against unsigned immediates in the range <literal>2<superscript>SEW</superscript>-15</literal> to
<literal>2<superscript>SEW</superscript></literal>.  Note that <literal>vlsltu.vi</literal> with immediate <literal>2<superscript>SEW</superscript></literal> is not useful
as it is always true.</simpara>
</note>
<simpara>Similarly, <literal>vmsge{u}.vi</literal> is not provided and the comparison is
implemented using <literal>vmsgt{u}.vi</literal> with the immediate decremented by one.
The resulting effective <literal>vmsge.vi</literal> range is -15 to 16, and the
resulting effective <literal>vmsgeu.vi</literal> range is 1 to 16 (Note, <literal>vmsgeu.vi</literal> with
immediate 0 is not useful as it is always true).</simpara>
<note>
<simpara>The <literal>vmsgt</literal> forms for register scalar and immediates are provided
to allow a single comparison instruction to provide the correct
polarity of mask value without using additional mask logical
instructions.</simpara>
</note>
<simpara>To reduce encoding space, the <literal>vmsge{u}.vx</literal> form is not directly
provided, and so the <literal>va ≥ x</literal> case requires special treatment.</simpara>
<note>
<simpara>The <literal>vmsge{u}.vx</literal> could potentially be encoded in a
non-orthogonal way under the unused OPIVI variant of <literal>vmslt{u}</literal>.  These
would be the only instructions in OPIVI that use a scalar `x`register
however.  Alternatively, a further two funct6 encodings could be used,
but these would have a different operand format (writes to mask
register) than others in the same group of 8 funct6 encodings.  The
current PoR is to omit these instructions and to synthesize where
needed as described below.</simpara>
</note>
<simpara>The <literal>vmsge{u}.vx</literal> operation can be synthesized by reducing the
value of <literal>x</literal> by 1 and using the <literal>vmsgt{u}.vx</literal> instruction, when it is
known that this will not underflow the representation in <literal>x</literal>.</simpara>
<screen>Sequences to synthesize `vmsge{u}.vx` instruction

va &gt;= x,  x &gt; minimum

   addi t0, x, -1; vmsgt{u}.vx vd, va, t0, vm</screen>
<simpara>The above sequence will usually be the most efficient implementation,
but assembler pseudoinstructions can be provided for cases where the
range of <literal>x</literal> is unknown.</simpara>
<screen>unmasked va &gt;= x

  pseudoinstruction: vmsge{u}.vx vd, va, x
  expansion: vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd

masked va &gt;= x, vd != v0

  pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t
  expansion: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0

masked va &gt;= x, vd == v0

  pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t, vt
  expansion: vmslt{u}.vx vt, va, x;  vmandnot.mm vd, vd, vt

masked va &gt;= x, any vd

  pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t, vt
  expansion: vmslt{u}.vx vt, va, x;  vmandnot.mm vt, v0, vt;  vmandnot.mm vd, vd, v0;  vmor.mm vd, vt, vd

  The vt argument to the pseudoinstruction must name a temporary vector register that is
  not same as vd and which will be clobbered by the pseudoinstruction</screen>
<simpara>Comparisons effectively AND in the mask under a mask-undisturbed policy e.g,</simpara>
<screen>    # (a &lt; b) &amp;&amp; (b &lt; c) in two instructions when mask-undisturbed
    vmslt.vv    v0, va, vb        # All body elements written
    vmslt.vv    v0, vb, vc, v0.t  # Only update at set mask</screen>
<simpara>Comparisons write mask registers, and so always operate under a
tail-agnostic policy.</simpara>
</section>
<section xml:id="_vector_integer_minmax_instructions">
<title>Vector Integer Min/Max Instructions</title>
<simpara>Signed and unsigned integer minimum and maximum instructions are
supported.</simpara>
<screen># Unsigned minimum
vminu.vv vd, vs2, vs1, vm   # Vector-vector
vminu.vx vd, vs2, rs1, vm   # vector-scalar

# Signed minimum
vmin.vv vd, vs2, vs1, vm   # Vector-vector
vmin.vx vd, vs2, rs1, vm   # vector-scalar

# Unsigned maximum
vmaxu.vv vd, vs2, vs1, vm   # Vector-vector
vmaxu.vx vd, vs2, rs1, vm   # vector-scalar

# Signed maximum
vmax.vv vd, vs2, vs1, vm   # Vector-vector
vmax.vx vd, vs2, rs1, vm   # vector-scalar</screen>
</section>
<section xml:id="_vector_single_width_integer_multiply_instructions">
<title>Vector Single-Width Integer Multiply Instructions</title>
<simpara>The single-width multiply instructions perform a SEW-bit*SEW-bit
multiply and return an SEW-bit-wide result.  The <literal><emphasis role="strong">mulh</emphasis></literal> versions
write the high word of the product to the destination register.</simpara>
<screen># Signed multiply, returning low bits of product
vmul.vv vd, vs2, vs1, vm   # Vector-vector
vmul.vx vd, vs2, rs1, vm   # vector-scalar

# Signed multiply, returning high bits of product
vmulh.vv vd, vs2, vs1, vm   # Vector-vector
vmulh.vx vd, vs2, rs1, vm   # vector-scalar

# Unsigned multiply, returning high bits of product
vmulhu.vv vd, vs2, vs1, vm   # Vector-vector
vmulhu.vx vd, vs2, rs1, vm   # vector-scalar

# Signed(vs2)-Unsigned multiply, returning high bits of product
vmulhsu.vv vd, vs2, vs1, vm   # Vector-vector
vmulhsu.vx vd, vs2, rs1, vm   # vector-scalar</screen>
<note>
<simpara>There is no <literal>vmulhus</literal> opcode to return high half of
unsigned-vector * signed-scalar product.</simpara>
</note>
<note>
<simpara>The current <literal>vmulh*</literal> opcodes perform simple fractional
multiplies, but with no option to scale, round, and/or saturate the
result.  A possible extension can consider variants of <literal>vmulh</literal>,
<literal>vmulhu</literal>, <literal>vmulhsu</literal> that use the <literal>vxrm</literal> rounding mode when discarding
low half of product.  There is no possibility of overflow in these
cases.</simpara>
</note>
</section>
<section xml:id="_vector_integer_divide_instructions">
<title>Vector Integer Divide Instructions</title>
<simpara>The divide and remainder instructions are equivalent to the RISC-V
standard scalar integer multiply/divides, with the same results for
extreme inputs.</simpara>
<screen>    # Unsigned divide.
    vdivu.vv vd, vs2, vs1, vm   # Vector-vector
    vdivu.vx vd, vs2, rs1, vm   # vector-scalar

    # Signed divide
    vdiv.vv vd, vs2, vs1, vm   # Vector-vector
    vdiv.vx vd, vs2, rs1, vm   # vector-scalar

    # Unsigned remainder
    vremu.vv vd, vs2, vs1, vm   # Vector-vector
    vremu.vx vd, vs2, rs1, vm   # vector-scalar

    # Signed remainder
    vrem.vv vd, vs2, vs1, vm   # Vector-vector
    vrem.vx vd, vs2, rs1, vm   # vector-scalar</screen>
<note>
<simpara>The decision to include integer divide and remainder was
contentious. The argument in favor is that without a standard
instruction, software would have to pick some algorithm to perform the
operation, which would likely perform poorly on some
microarchitectures versus others.</simpara>
</note>
<note>
<simpara>There is no instruction to perform a "scalar divide by vector"
operation.</simpara>
</note>
</section>
<section xml:id="_vector_widening_integer_multiply_instructions">
<title>Vector Widening Integer Multiply Instructions</title>
<simpara>The widening integer multiply instructions return the full 2*SEW-bit
product from an SEW-bit*SEW-bit multiply.</simpara>
<screen># Widening signed-integer multiply
vwmul.vv  vd, vs2, vs1, vm # vector-vector
vwmul.vx  vd, vs2, rs1, vm # vector-scalar

# Widening unsigned-integer multiply
vwmulu.vv vd, vs2, vs1, vm # vector-vector
vwmulu.vx vd, vs2, rs1, vm # vector-scalar

# Widening signed-unsigned integer multiply
vwmulsu.vv vd, vs2, vs1, vm # vector-vector
vwmulsu.vx vd, vs2, rs1, vm # vector-scalar</screen>
</section>
<section xml:id="_vector_single_width_integer_multiply_add_instructions">
<title>Vector Single-Width Integer Multiply-Add Instructions</title>
<simpara>The integer multiply-add instructions are destructive and are provided
in two forms, one that overwrites the addend or minuend
(<literal>vmacc</literal>, <literal>vnmsac</literal>) and one that overwrites the first multiplicand
(<literal>vmadd</literal>, <literal>vnmsub</literal>).</simpara>
<simpara>The low half of the product is added or subtracted from the third operand.</simpara>
<note>
<simpara><literal>sac</literal> is intended to be read as "subtract from accumulator". The
opcode is <literal>vnmsac</literal> to match the (unfortunately counterintuitive)
floating-point <literal>fnmsub</literal> instruction definition.  Similarly for the
<literal>vnmsub</literal> opcode.</simpara>
</note>
<screen># Integer multiply-add, overwrite addend
vmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vmacc.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]

# Integer multiply-sub, overwrite minuend
vnmsac.vv vd, vs1, vs2, vm    # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
vnmsac.vx vd, rs1, vs2, vm    # vd[i] = -(x[rs1] * vs2[i]) + vd[i]

# Integer multiply-add, overwrite multiplicand
vmadd.vv vd, vs1, vs2, vm    # vd[i] = (vs1[i] * vd[i]) + vs2[i]
vmadd.vx vd, rs1, vs2, vm    # vd[i] = (x[rs1] * vd[i]) + vs2[i]

# Integer multiply-sub, overwrite multiplicand
vnmsub.vv vd, vs1, vs2, vm    # vd[i] = -(vs1[i] * vd[i]) + vs2[i]
vnmsub.vx vd, rs1, vs2, vm    # vd[i] = -(x[rs1] * vd[i]) + vs2[i]</screen>
</section>
<section xml:id="_vector_widening_integer_multiply_add_instructions">
<title>Vector Widening Integer Multiply-Add Instructions</title>
<simpara>The widening integer multiply-add instructions add the full 2*SEW-bit
product from a SEW-bit*SEW-bit multiply to a 2*SEW-bit value and
produce a 2*SEW-bit result.  All combinations of signed and unsigned
multiply operands are supported.</simpara>
<screen># Widening unsigned-integer multiply-add, overwrite addend
vwmaccu.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vwmaccu.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]

# Widening signed-integer multiply-add, overwrite addend
vwmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vwmacc.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]

# Widening signed-unsigned-integer multiply-add, overwrite addend
vwmaccsu.vv vd, vs1, vs2, vm  # vd[i] = +(signed(vs1[i]) * unsigned(vs2[i])) + vd[i]
vwmaccsu.vx vd, rs1, vs2, vm  # vd[i] = +(signed(x[rs1]) * unsigned(vs2[i])) + vd[i]

# Widening unsigned-signed-integer multiply-add, overwrite addend
vwmaccus.vx vd, rs1, vs2, vm  # vd[i] = +(unsigned(x[rs1]) * signed(vs2[i])) + vd[i]</screen>
</section>
<section xml:id="_vector_integer_merge_instructions">
<title>Vector Integer Merge Instructions</title>
<simpara>The vector integer merge instructions combine two source operands
based on a mask.  Unlike regular arithmetic instructions, the
merge operates on all body elements (i.e., the set of elements from
<literal>vstart</literal> up to the current vector length in <literal>vl</literal>).</simpara>
<simpara>The <literal>vmerge</literal> instructions are encoded as masked instructions (<literal>vm=0</literal>).
The instructions combine two
sources as follows.  At elements where the mask value is zero, the
first operand is copied to the destination element, otherwise the
second operand is copied to the destination element.  The first
operand is always a vector register group specified by <literal>vs2</literal>.  The
second operand is a vector register group specified by <literal>vs1</literal> or a
scalar <literal>x</literal> register specified by <literal>rs1</literal> or a 5-bit sign-extended
immediate.</simpara>
<screen>vmerge.vvm vd, vs2, vs1, v0  # vd[i] = v0.mask[i] ? vs1[i] : vs2[i]
vmerge.vxm vd, vs2, rs1, v0  # vd[i] = v0.mask[i] ? x[rs1] : vs2[i]
vmerge.vim vd, vs2, imm, v0  # vd[i] = v0.mask[i] ? imm    : vs2[i]</screen>
</section>
<section xml:id="_vector_integer_move_instructions">
<title>Vector Integer Move Instructions</title>
<simpara>The vector integer move instructions copy a source operand to a vector
register group.
The <literal>vmv.v.v</literal> variant copies a vector register group, whereas the <literal>vmv.v.x</literal>
and <literal>vmv.v.i</literal> variants <emphasis>splat</emphasis> a scalar register or immediate to all active
elements of the destination vector register group.
These instructions are encoded as unmasked instructions (<literal>vm=1</literal>).
The first operand specifier (<literal>vs2</literal>) must contain <literal>v0</literal>, and any other vector
register number in <literal>vs2</literal> is <emphasis>reserved</emphasis>.</simpara>
<screen>vmv.v.v vd, vs1 # vd[i] = vs1[i]
vmv.v.x vd, rs1 # vd[i] = x[rs1]
vmv.v.i vd, imm # vd[i] = imm</screen>
<note>
<simpara>Mask values can be widened into SEW-width elements using a
sequence <literal>vmv.v.i vd, 0; vmerge.vim vd, vd, 1, v0</literal>.</simpara>
</note>
<note>
<simpara>The vector integer move instructions share the encoding with the vector
merge instructions, but with <literal>vm=1</literal> and <literal>vs2=v0</literal>.</simpara>
</note>
<simpara>The form <literal>vmv.v.v vd, vd</literal>, which leaves body elements unchanged,
is used as a hint to indicate that the register will next be used
with an EEW equal to SEW.</simpara>
<note>
<simpara>Implementations that internally reorganize data according to EEW
can shuffle the internal representation according to SEW.
Implementations that do not internally reorganize data can dynamically
elide this instruction, and treat as a NOP.</simpara>
</note>
</section>
</section>
<section xml:id="sec-vector-fixed-point">
<title>Vector Fixed-Point Arithmetic Instructions</title>
<simpara>The preceding set of integer arithmetic instructions is extended to support
fixed-point arithmetic.</simpara>
<simpara>A fixed-point number is a two’s-complement signed or unsigned integer
interpreted as the numerator in a fraction with an implicit denominator.
The fixed-point instructions are intended to be applied to the numerators;
it is the responsibility of software to manage the denominators.
An N-bit element can hold two’s-complement signed integers in the
range -2<superscript>N-1</superscript>…​+2<superscript>N-1</superscript>-1, and unsigned integers in the range 0
…​ +2<superscript>N</superscript>-1.  The fixed-point instructions help preserve precision in
narrow operands by supporting scaling and rounding, and can handle
overflow by saturating results into the destination format range.</simpara>
<note>
<simpara>The widening integer operations described above can also be used
to avoid overflow.</simpara>
</note>
<section xml:id="_vector_single_width_saturating_add_and_subtract">
<title>Vector Single-Width Saturating Add and Subtract</title>
<simpara>Saturating forms of integer add and subtract are provided, for both
signed and unsigned integers.  If the result would overflow the
destination, the result is replaced with the closest representable
value, and the <literal>vxsat</literal> bit is set.</simpara>
<screen># Saturating adds of unsigned integers.
vsaddu.vv vd, vs2, vs1, vm   # Vector-vector
vsaddu.vx vd, vs2, rs1, vm   # vector-scalar
vsaddu.vi vd, vs2, imm, vm   # vector-immediate

# Saturating adds of signed integers.
vsadd.vv vd, vs2, vs1, vm   # Vector-vector
vsadd.vx vd, vs2, rs1, vm   # vector-scalar
vsadd.vi vd, vs2, imm, vm   # vector-immediate

# Saturating subtract of unsigned integers.
vssubu.vv vd, vs2, vs1, vm   # Vector-vector
vssubu.vx vd, vs2, rs1, vm   # vector-scalar

# Saturating subtract of signed integers.
vssub.vv vd, vs2, vs1, vm   # Vector-vector
vssub.vx vd, vs2, rs1, vm   # vector-scalar</screen>
</section>
<section xml:id="_vector_single_width_averaging_add_and_subtract">
<title>Vector Single-Width Averaging Add and Subtract</title>
<simpara>The averaging add and subtract instructions right shift the result by
one bit and round off the result according to the setting in <literal>vxrm</literal>.
Both unsigned and signed versions are provided.
For <literal>vaaddu</literal> and <literal>vaadd</literal> there can be no overflow in the result.
For <literal>vasub</literal> and <literal>vasubu</literal>, overflow is ignored and the result wraps around.</simpara>
<note>
<simpara>For <literal>vasub</literal>, overflow occurs only when subtracting the smallest number
from the largest number under <literal>rnu</literal> or <literal>rne</literal> rounding.</simpara>
</note>
<screen># Averaging add

# Averaging adds of unsigned integers.
vaaddu.vv vd, vs2, vs1, vm   # roundoff_unsigned(vs2[i] + vs1[i], 1)
vaaddu.vx vd, vs2, rs1, vm   # roundoff_unsigned(vs2[i] + x[rs1], 1)

# Averaging adds of signed integers.
vaadd.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] + vs1[i], 1)
vaadd.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] + x[rs1], 1)

# Averaging subtract

# Averaging subtract of unsigned integers.
vasubu.vv vd, vs2, vs1, vm   # roundoff_unsigned(vs2[i] - vs1[i], 1)
vasubu.vx vd, vs2, rs1, vm   # roundoff_unsigned(vs2[i] - x[rs1], 1)

# Averaging subtract of signed integers.
vasub.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] - vs1[i], 1)
vasub.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] - x[rs1], 1)</screen>
</section>
<section xml:id="_vector_single_width_fractional_multiply_with_rounding_and_saturation">
<title>Vector Single-Width Fractional Multiply with Rounding and Saturation</title>
<simpara>The signed fractional multiply instruction produces a 2*SEW product of
the two SEW inputs, then shifts the result right by SEW-1 bits,
rounding these bits according to <literal>vxrm</literal>, then saturates the result to
fit into SEW bits.  If the result causes saturation, the <literal>vxsat</literal> bit
is set.</simpara>
<screen># Signed saturating and rounding fractional multiply
# See vxrm  description for rounding calculation
vsmul.vv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*vs1[i], SEW-1))
vsmul.vx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*x[rs1], SEW-1))</screen>
<note>
<simpara>When multiplying two N-bit signed numbers, the largest magnitude
is obtained for -2<superscript>N-1</superscript> * -2<superscript>N-1</superscript> producing a result +2<superscript>2N-2</superscript>, which
has a single (zero) sign bit when held in 2N bits.  All other products
have two sign bits in 2N bits.  To retain greater precision in N
result bits, the product is shifted right by one bit less than N,
saturating the largest magnitude result but increasing result
precision by one bit for all other products.</simpara>
</note>
<note>
<simpara>We do not provide an equivalent fractional multiply where one
input is unsigned, as these would retain all upper SEW bits and would
not need to saturate.  This operation is partly covered by the
<literal>vmulhu</literal> and <literal>vmulhsu</literal> instructions, for the case where rounding is
simply truncation (<literal>rdn</literal>).</simpara>
</note>
</section>
<section xml:id="_vector_single_width_scaling_shift_instructions">
<title>Vector Single-Width Scaling Shift Instructions</title>
<simpara>These instructions shift the input value right, and round off the
shifted out bits according to <literal>vxrm</literal>.  The scaling right shifts have
both zero-extending (<literal>vssrl</literal>) and sign-extending (<literal>vssra</literal>) forms.
The low lg2(SEW) bits of the vector or scalar shift-amount value are used;
shift-amount immediates are zero-extended.</simpara>
<screen> # Scaling shift right logical
 vssrl.vv vd, vs2, vs1, vm   # vd[i] = roundoff_unsigned(vs2[i], vs1[i])
 vssrl.vx vd, vs2, rs1, vm   # vd[i] = roundoff_unsigned(vs2[i], x[rs1])
 vssrl.vi vd, vs2, uimm, vm  # vd[i] = roundoff_unsigned(vs2[i], uimm)

 # Scaling shift right arithmetic
 vssra.vv vd, vs2, vs1, vm   # vd[i] = roundoff_signed(vs2[i],vs1[i])
 vssra.vx vd, vs2, rs1, vm   # vd[i] = roundoff_signed(vs2[i], x[rs1])
 vssra.vi vd, vs2, uimm, vm  # vd[i] = roundoff_signed(vs2[i], uimm)</screen>
</section>
<section xml:id="_vector_narrowing_fixed_point_clip_instructions">
<title>Vector Narrowing Fixed-Point Clip Instructions</title>
<simpara>The <literal>vnclip</literal> instructions are used to pack a fixed-point value into a
narrower destination.  The instructions support rounding, scaling, and
saturation into the final destination format.</simpara>
<simpara>The second argument (vector element, scalar value, immediate value)
gives the amount to right shift the source as in the narrowing shift
instructions, which provides the scaling.  The low lg2(2*SEW) bits of
the vector or scalar shift-amount value are used (e.g., the low 6 bits
for a SEW=64-bit to SEW=32-bit narrowing operation).  The immediate
forms zero-extend their shift-amount immediate operand.</simpara>
<screen># Narrowing unsigned clip
#                                SEW                            2*SEW   SEW
 vnclipu.wv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_unsigned(vs2[i], vs1[i]))
 vnclipu.wx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_unsigned(vs2[i], x[rs1]))
 vnclipu.wi vd, vs2, uimm, vm # vd[i] = clip(roundoff_unsigned(vs2[i], uimm))

# Narrowing signed clip
 vnclip.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], vs1[i]))
 vnclip.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], x[rs1]))
 vnclip.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_signed(vs2[i], uimm))</screen>
<simpara>For <literal>vnclipu</literal>/<literal>vnclip</literal>, the rounding mode is specified in the <literal>vxrm</literal>
CSR.  Rounding occurs around the least-significant bit of the
destination and before saturation.</simpara>
<simpara>For <literal>vnclipu</literal>, the shifted rounded source value is treated as an
unsigned integer and saturates if the result would overflow the
destination viewed as an unsigned integer.</simpara>
<note>
<simpara>There is no single instruction that can saturate a signed value
into an unsigned destination.  A sequence of two vector instructions
that first removes negative numbers by performing a max against 0
using <literal>vmax</literal>, then clips the resulting unsigned value into the
destination using <literal>vnclipu</literal>, can be used if setting <literal>vxsat</literal> value is
not required.  A <literal>vsetvli</literal> is required inbetween these two
instructions to change SEW.</simpara>
</note>
<simpara>For <literal>vnclip</literal>, the shifted rounded source value is treated as a signed
integer and saturates if the result would overflow the destination viewed
as a signed integer.</simpara>
<simpara>If any destination element is saturated, the <literal>vxsat</literal> bit is set in the
<literal>vxsat</literal> register.</simpara>
</section>
</section>
<section xml:id="sec-vector-float">
<title>Vector Floating-Point Instructions</title>
<simpara>The standard vector floating-point instructions treat 16-bit, 32-bit,
64-bit, and 128-bit elements as IEEE-754/2008-compatible values.  If
the EEW of a vector floating-point operand does not correspond to a
supported IEEE floating-point type, the instruction encoding is
reserved.</simpara>
<note>
<simpara>The floating-point element widths that are supported depend on
the profile.</simpara>
</note>
<simpara>Vector floating-point instructions require the presence of base scalar
floating-point extensions corresponding to the supported vector
floating-point element widths.</simpara>
<note>
<simpara>In particular, vector profiles supporting 16-bit half-precision
floating-point values will also have to implement scalar
half-precision floating-point support in the <literal>f</literal> registers.</simpara>
</note>
<simpara>If the floating-point unit status field <literal>mstatus.FS</literal> is <literal>Off</literal> then any
attempt to execute a vector floating-point instruction will raise an
illegal instruction exception.  Any vector floating-point instruction
that modifies any floating-point extension state (i.e., floating-point
CSRs or <literal>f</literal> registers) must set <literal>mstatus.FS</literal> to <literal>Dirty</literal>.</simpara>
<simpara>The vector floating-point instructions have the same behavior as the
scalar floating-point instructions with regard to NaNs.</simpara>
<simpara>Scalar values for vector-scalar operations can be sourced from the
standard scalar <literal>f</literal> registers, as described in Section
<xref linkend="sec-arithmetic-encoding"/>.</simpara>
<section xml:id="_vector_floating_point_exception_flags">
<title>Vector Floating-Point Exception Flags</title>
<simpara>A vector floating-point exception at any active floating-point element
sets the standard FP exception flags in the <literal>fflags</literal> register.  Inactive
elements do not set FP exception flags.</simpara>
</section>
<section xml:id="_vector_single_width_floating_point_addsubtract_instructions">
<title>Vector Single-Width Floating-Point Add/Subtract Instructions</title>
<screen>    # Floating-point add
    vfadd.vv vd, vs2, vs1, vm   # Vector-vector
    vfadd.vf vd, vs2, rs1, vm   # vector-scalar

    # Floating-point subtract
    vfsub.vv vd, vs2, vs1, vm   # Vector-vector
    vfsub.vf vd, vs2, rs1, vm   # Vector-scalar vd[i] = vs2[i] - f[rs1]
    vfrsub.vf vd, vs2, rs1, vm  # Scalar-vector vd[i] = f[rs1] - vs2[i]</screen>
</section>
<section xml:id="_vector_widening_floating_point_addsubtract_instructions">
<title>Vector Widening Floating-Point Add/Subtract Instructions</title>
<screen># Widening FP add/subtract, 2*SEW = SEW +/- SEW
vfwadd.vv vd, vs2, vs1, vm  # vector-vector
vfwadd.vf vd, vs2, rs1, vm  # vector-scalar
vfwsub.vv vd, vs2, vs1, vm  # vector-vector
vfwsub.vf vd, vs2, rs1, vm  # vector-scalar

# Widening FP add/subtract, 2*SEW = 2*SEW +/- SEW
vfwadd.wv  vd, vs2, vs1, vm  # vector-vector
vfwadd.wf  vd, vs2, rs1, vm  # vector-scalar
vfwsub.wv  vd, vs2, vs1, vm  # vector-vector
vfwsub.wf  vd, vs2, rs1, vm  # vector-scalar</screen>
</section>
<section xml:id="_vector_single_width_floating_point_multiplydivide_instructions">
<title>Vector Single-Width Floating-Point Multiply/Divide Instructions</title>
<screen>    # Floating-point multiply
    vfmul.vv vd, vs2, vs1, vm   # Vector-vector
    vfmul.vf vd, vs2, rs1, vm   # vector-scalar

    # Floating-point divide
    vfdiv.vv vd, vs2, vs1, vm   # Vector-vector
    vfdiv.vf vd, vs2, rs1, vm   # vector-scalar

    # Reverse floating-point divide vector = scalar / vector
    vfrdiv.vf vd, vs2, rs1, vm  # scalar-vector, vd[i] = f[rs1]/vs2[i]</screen>
</section>
<section xml:id="_vector_widening_floating_point_multiply">
<title>Vector Widening Floating-Point Multiply</title>
<screen># Widening floating-point multiply
vfwmul.vv    vd, vs2, vs1, vm # vector-vector
vfwmul.vf    vd, vs2, rs1, vm # vector-scalar</screen>
</section>
<section xml:id="_vector_single_width_floating_point_fused_multiply_add_instructions">
<title>Vector Single-Width Floating-Point Fused Multiply-Add Instructions</title>
<simpara>All four varieties of fused multiply-add are provided, and in two
destructive forms that overwrite one of the operands, either the
addend or the first multiplicand.</simpara>
<screen># FP multiply-accumulate, overwrites addend
vfmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vfmacc.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) + vd[i]

# FP negate-(multiply-accumulate), overwrites subtrahend
vfnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) - vd[i]
vfnmacc.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) - vd[i]

# FP multiply-subtract-accumulator, overwrites subtrahend
vfmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) - vd[i]
vfmsac.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) - vd[i]

# FP negate-(multiply-subtract-accumulator), overwrites minuend
vfnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
vfnmsac.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) + vd[i]

# FP multiply-add, overwrites multiplicand
vfmadd.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vd[i]) + vs2[i]
vfmadd.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vd[i]) + vs2[i]

# FP negate-(multiply-add), overwrites multiplicand
vfnmadd.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vd[i]) - vs2[i]
vfnmadd.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vd[i]) - vs2[i]

# FP multiply-sub, overwrites multiplicand
vfmsub.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vd[i]) - vs2[i]
vfmsub.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vd[i]) - vs2[i]

# FP negate-(multiply-sub), overwrites multiplicand
vfnmsub.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vd[i]) + vs2[i]
vfnmsub.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vd[i]) + vs2[i]</screen>
<note>
<simpara>It would be possible to use the two unused rounding modes in the
scalar FP FMA encoding to provide a few non-destructive FMAs.
However, this would be the only maskable operation with three inputs
and separate output.</simpara>
</note>
</section>
<section xml:id="_vector_widening_floating_point_fused_multiply_add_instructions">
<title>Vector Widening Floating-Point Fused Multiply-Add Instructions</title>
<simpara>The widening floating-point fused multiply-add instructions all
overwrite the wide addend with the result.  The multiplier inputs are
all SEW wide, while the addend and destination is 2*SEW bits wide.</simpara>
<screen># FP widening multiply-accumulate, overwrites addend
vfwmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vfwmacc.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) + vd[i]

# FP widening negate-(multiply-accumulate), overwrites addend
vfwnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) - vd[i]
vfwnmacc.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) - vd[i]

# FP widening multiply-subtract-accumulator, overwrites addend
vfwmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) - vd[i]
vfwmsac.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) - vd[i]

# FP widening negate-(multiply-subtract-accumulator), overwrites addend
vfwnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
vfwnmsac.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) + vd[i]</screen>
</section>
<section xml:id="_vector_floating_point_square_root_instruction">
<title>Vector Floating-Point Square-Root Instruction</title>
<simpara>This is a unary vector-vector instruction.</simpara>
<screen>    # Floating-point square root
    vfsqrt.v vd, vs2, vm   # Vector-vector square root</screen>
</section>
<section xml:id="_vector_floating_point_reciprocal_square_root_estimate_instruction">
<title>Vector Floating-Point Reciprocal Square-Root Estimate Instruction</title>
<screen>    # Floating-point reciprocal square-root estimate to 7 bits.
    vfrsqrt7.v vd, vs2, vm</screen>
<simpara>This is a unary vector-vector instruction that returns an estimate of
1/sqrt(x) accurate to 7 bits.</simpara>
<note>
<simpara>An earlier draft version had used the assembler name <literal>vfrsqrte7</literal>
but this was deemed to cause confusion with the <literal>e</literal><emphasis>x</emphasis> notation for element
width.  The earlier name can be retained as alias in tool chains for
backward compatibility.</simpara>
</note>
<simpara>The following table describes the instruction’s behavior for all
classes of floating-point inputs:</simpara>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Input</entry>
<entry align="left" valign="top">Output</entry>
<entry align="left" valign="top">Exceptions raised</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>-∞ ≤ <emphasis>x</emphasis> &lt; -0.0</simpara></entry>
<entry align="left" valign="top"><simpara>canonical NaN</simpara></entry>
<entry align="left" valign="top"><simpara>NV</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>-0.0</simpara></entry>
<entry align="left" valign="top"><simpara>-∞</simpara></entry>
<entry align="left" valign="top"><simpara>DZ</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>+0.0</simpara></entry>
<entry align="left" valign="top"><simpara>+∞</simpara></entry>
<entry align="left" valign="top"><simpara>DZ</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>+0.0 &lt; <emphasis>x</emphasis> &lt; +∞</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>estimate of 1/sqrt(x)</emphasis></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>+∞</simpara></entry>
<entry align="left" valign="top"><simpara>+0.0</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>qNaN</simpara></entry>
<entry align="left" valign="top"><simpara>canonical NaN</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>sNaN</simpara></entry>
<entry align="left" valign="top"><simpara>canonical NaN</simpara></entry>
<entry align="left" valign="top"><simpara>NV</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>All positive normal and subnormal inputs produce normal outputs.</simpara>
</note>
<note>
<simpara>The output value is independent of the dynamic rounding mode.</simpara>
</note>
<simpara>For the non-exceptional cases, the low bit of the exponent and the six high
bits of significand (after the leading one) are concatenated and used to
address the following table.
The output of the table becomes the seven high bits of the result significand
(after the leading one); the remainder of the result significand is zero.
Subnormal inputs are normalized and the exponent adjusted appropriately before
the lookup.
The output exponent is chosen to make the result approximate the reciprocal of
the square root of the argument.</simpara>
<simpara>More precisely, the result is computed as follows.
Let the normalized input exponent be equal to the input exponent if the input
is normal, or 0 minus the number of leading zeros in the significand
otherwise.
If the input is subnormal, the normalized input significand is given by
shifting the input significand left by 1 minus the normalized input exponent,
discarding the leading 1 bit.
The output exponent equals floor((3*B - 1 - the normalized input exponent) / 2).
The output sign equals the input sign.</simpara>
<simpara>The following table gives the seven MSBs of the output significand as a
function of the LSB of the normalized input exponent and the six MSBs of the
normalized input significand; the other bits of the output significand are zero.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>vfrsqrt7.v common-case lookup table contents</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>exp[0]</simpara></entry>
<entry align="left" valign="top"><simpara>sig[MSB -: 6]</simpara></entry>
<entry align="left" valign="top"><simpara>sig_out[MSB -: 7]</simpara></entry>
</row>
<row>
<entry align="left" morerows="63" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>52</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>51</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>48</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>47</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>46</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>44</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>43</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>42</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>41</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>40</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>39</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>38</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>14</simpara></entry>
<entry align="left" valign="top"><simpara>35</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>34</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>33</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>17</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>18</simpara></entry>
<entry align="left" valign="top"><simpara>31</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>19</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>20</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>21</simpara></entry>
<entry align="left" valign="top"><simpara>29</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>22</simpara></entry>
<entry align="left" valign="top"><simpara>28</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>23</simpara></entry>
<entry align="left" valign="top"><simpara>27</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>24</simpara></entry>
<entry align="left" valign="top"><simpara>26</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>25</simpara></entry>
<entry align="left" valign="top"><simpara>25</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>26</simpara></entry>
<entry align="left" valign="top"><simpara>24</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>27</simpara></entry>
<entry align="left" valign="top"><simpara>23</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>28</simpara></entry>
<entry align="left" valign="top"><simpara>23</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>29</simpara></entry>
<entry align="left" valign="top"><simpara>22</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"><simpara>21</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>31</simpara></entry>
<entry align="left" valign="top"><simpara>20</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>19</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>33</simpara></entry>
<entry align="left" valign="top"><simpara>19</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>34</simpara></entry>
<entry align="left" valign="top"><simpara>18</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>35</simpara></entry>
<entry align="left" valign="top"><simpara>17</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>36</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>37</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>38</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>39</simpara></entry>
<entry align="left" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>41</simpara></entry>
<entry align="left" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>42</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>43</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>44</simpara></entry>
<entry align="left" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>45</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>46</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>48</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>49</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>50</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>51</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>52</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>53</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>54</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>55</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>56</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>57</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>58</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>59</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>60</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>61</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>62</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>63</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" morerows="63" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>127</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>125</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>123</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>121</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>119</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>118</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>116</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>114</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>113</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>111</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>109</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>108</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>106</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>105</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>14</simpara></entry>
<entry align="left" valign="top"><simpara>103</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>102</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>17</simpara></entry>
<entry align="left" valign="top"><simpara>99</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>18</simpara></entry>
<entry align="left" valign="top"><simpara>97</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>19</simpara></entry>
<entry align="left" valign="top"><simpara>96</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>20</simpara></entry>
<entry align="left" valign="top"><simpara>95</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>21</simpara></entry>
<entry align="left" valign="top"><simpara>93</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>22</simpara></entry>
<entry align="left" valign="top"><simpara>92</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>23</simpara></entry>
<entry align="left" valign="top"><simpara>91</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>24</simpara></entry>
<entry align="left" valign="top"><simpara>90</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>25</simpara></entry>
<entry align="left" valign="top"><simpara>88</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>26</simpara></entry>
<entry align="left" valign="top"><simpara>87</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>27</simpara></entry>
<entry align="left" valign="top"><simpara>86</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>28</simpara></entry>
<entry align="left" valign="top"><simpara>85</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>29</simpara></entry>
<entry align="left" valign="top"><simpara>84</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"><simpara>83</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>31</simpara></entry>
<entry align="left" valign="top"><simpara>82</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>80</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>33</simpara></entry>
<entry align="left" valign="top"><simpara>79</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>34</simpara></entry>
<entry align="left" valign="top"><simpara>78</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>35</simpara></entry>
<entry align="left" valign="top"><simpara>77</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>36</simpara></entry>
<entry align="left" valign="top"><simpara>76</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>37</simpara></entry>
<entry align="left" valign="top"><simpara>75</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>38</simpara></entry>
<entry align="left" valign="top"><simpara>74</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>39</simpara></entry>
<entry align="left" valign="top"><simpara>73</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>72</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>41</simpara></entry>
<entry align="left" valign="top"><simpara>71</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>42</simpara></entry>
<entry align="left" valign="top"><simpara>70</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>43</simpara></entry>
<entry align="left" valign="top"><simpara>70</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>44</simpara></entry>
<entry align="left" valign="top"><simpara>69</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>45</simpara></entry>
<entry align="left" valign="top"><simpara>68</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>46</simpara></entry>
<entry align="left" valign="top"><simpara>67</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47</simpara></entry>
<entry align="left" valign="top"><simpara>66</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>48</simpara></entry>
<entry align="left" valign="top"><simpara>65</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>49</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>50</simpara></entry>
<entry align="left" valign="top"><simpara>63</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>51</simpara></entry>
<entry align="left" valign="top"><simpara>63</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>52</simpara></entry>
<entry align="left" valign="top"><simpara>62</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>53</simpara></entry>
<entry align="left" valign="top"><simpara>61</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>54</simpara></entry>
<entry align="left" valign="top"><simpara>60</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>55</simpara></entry>
<entry align="left" valign="top"><simpara>59</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>56</simpara></entry>
<entry align="left" valign="top"><simpara>59</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>57</simpara></entry>
<entry align="left" valign="top"><simpara>58</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>58</simpara></entry>
<entry align="left" valign="top"><simpara>57</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>59</simpara></entry>
<entry align="left" valign="top"><simpara>56</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>60</simpara></entry>
<entry align="left" valign="top"><simpara>56</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>61</simpara></entry>
<entry align="left" valign="top"><simpara>55</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>62</simpara></entry>
<entry align="left" valign="top"><simpara>54</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>63</simpara></entry>
<entry align="left" valign="top"><simpara>53</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>For example, when SEW=32, vfrsqrt7(0x00718abc (≈ 1.043e-38))
= 0x5f080000 (≈ 9.800e18), and vfrsqrt7(0x7f765432 (≈ 3.274e38))
= 0x1f820000 (≈ 5.506e-20).</simpara>
</note>
<note>
<simpara>The 7 bit accuracy was chosen as it requires 0,1,2,3
Newton-Raphson iterations to converge to close to bfloat16, FP16,
FP32, FP64 accuracy respectively.   Future instructions can be defined
with greater estimate accuracy.</simpara>
</note>
</section>
<section xml:id="_vector_floating_point_reciprocal_estimate_instruction">
<title>Vector Floating-Point Reciprocal Estimate Instruction</title>
<screen>    # Floating-point reciprocal estimate to 7 bits.
    vfrec7.v vd, vs2, vm</screen>
<note>
<simpara>An earlier draft version had used the assembler name <literal>vfrece7</literal>
but this was deemed to cause confusion with <literal>e</literal><emphasis>x</emphasis> notation for element
width.  The earlier name can be retained as alias in tool chains for
backward compatibility.</simpara>
</note>
<simpara>This is a unary vector-vector instruction that returns an estimate of
1/x accurate to 7 bits.</simpara>
<simpara>The following table describes the instruction’s behavior for all
classes of floating-point inputs, where <emphasis>B</emphasis> is the exponent bias:</simpara>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Input (<emphasis>x</emphasis>)</entry>
<entry align="left" valign="top">Rounding Mode</entry>
<entry align="left" valign="top">Output (<emphasis>y</emphasis> ≈ <emphasis>1/x</emphasis>)</entry>
<entry align="left" valign="top">Exceptions raised</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>-∞</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>-0.0</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>-2<superscript>B+1</superscript> &lt; <emphasis>x</emphasis> ≤ -2<superscript>B</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>-2<superscript>-(B+1)</superscript> ≥ <emphasis>y</emphasis> &gt; -2<superscript>-B</superscript> (subnormal, sig=01…​)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>-2<superscript>B</superscript> &lt; <emphasis>x</emphasis> ≤ -2<superscript>B-1</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>-2<superscript>-B</superscript> ≥ <emphasis>y</emphasis> &gt; -2<superscript>-B+1</superscript> (subnormal, sig=1…​)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>-2<superscript>B-1</superscript> &lt; <emphasis>x</emphasis> ≤ -2<superscript>-B+1</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>-2<superscript>-B+1</superscript> ≥ <emphasis>y</emphasis> &gt; -2<superscript>B-1</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>-2<superscript>-B+1</superscript> &lt; <emphasis>x</emphasis> ≤ -2<superscript>-B</superscript> (subnormal, sig=1…​)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>-2<superscript>B-1</superscript> ≥ <emphasis>y</emphasis> &gt; -2<superscript>B</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>-2<superscript>-B</superscript> &lt; <emphasis>x</emphasis> ≤ -2<superscript>-(B+1)</superscript> (subnormal, sig=01…​)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>-2<superscript>B</superscript> ≥ <emphasis>y</emphasis> &gt; -2<superscript>B+1</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>-2<superscript>-(B+1)</superscript> &lt; <emphasis>x</emphasis> &lt; -0.0 (subnormal, sig=00…​)</simpara></entry>
<entry align="left" valign="top"><simpara>RUP, RTZ</simpara></entry>
<entry align="left" valign="top"><simpara>greatest-mag. negative finite value</simpara></entry>
<entry align="left" valign="top"><simpara>NX, OF</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>-2<superscript>-(B+1)</superscript> &lt; <emphasis>x</emphasis> &lt; -0.0 (subnormal, sig=00…​)</simpara></entry>
<entry align="left" valign="top"><simpara>RDN, RNE, RMM</simpara></entry>
<entry align="left" valign="top"><simpara>-∞</simpara></entry>
<entry align="left" valign="top"><simpara>NX, OF</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>-0.0</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>-∞</simpara></entry>
<entry align="left" valign="top"><simpara>DZ</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>+0.0</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>+∞</simpara></entry>
<entry align="left" valign="top"><simpara>DZ</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>+0.0 &lt; <emphasis>x</emphasis> &lt; 2<superscript>-(B+1)</superscript> (subnormal, sig=00…​)</simpara></entry>
<entry align="left" valign="top"><simpara>RUP, RNE, RMM</simpara></entry>
<entry align="left" valign="top"><simpara>+∞</simpara></entry>
<entry align="left" valign="top"><simpara>NX, OF</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>+0.0 &lt; <emphasis>x</emphasis> &lt; 2<superscript>-(B+1)</superscript> (subnormal, sig=00…​)</simpara></entry>
<entry align="left" valign="top"><simpara>RDN, RTZ</simpara></entry>
<entry align="left" valign="top"><simpara>greatest finite value</simpara></entry>
<entry align="left" valign="top"><simpara>NX, OF</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2<superscript>-(B+1)</superscript> ≤ <emphasis>x</emphasis> &lt; 2<superscript>-B</superscript> (subnormal, sig=01…​)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>B+1</superscript> &gt; <emphasis>y</emphasis> ≥ 2<superscript>B</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>2<superscript>-B</superscript> ≤ <emphasis>x</emphasis> &lt; 2<superscript>-B+1</superscript> (subnormal, sig=1…​)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>B</superscript> &gt; <emphasis>y</emphasis> ≥ 2<superscript>B-1</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>2<superscript>-B+1</superscript> ≤ <emphasis>x</emphasis> &lt; 2<superscript>B-1</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>B-1</superscript> &gt; <emphasis>y</emphasis> ≥ 2<superscript>-B+1</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>2<superscript>B-1</superscript> ≤ <emphasis>x</emphasis> &lt; 2<superscript>B</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>-B+1</superscript> &gt; <emphasis>y</emphasis> ≥ 2<superscript>-B</superscript> (subnormal, sig=1…​)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>2<superscript>B</superscript> ≤ <emphasis>x</emphasis> &lt; 2<superscript>B+1</superscript> (normal)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>-B</superscript> &gt; <emphasis>y</emphasis> ≥ 2<superscript>-(B+1)</superscript> (subnormal, sig=01…​)</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>+∞</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>+0.0</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>qNaN</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>canonical NaN</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>sNaN</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>any</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>canonical NaN</simpara></entry>
<entry align="left" valign="top"><simpara>NV</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>Subnormal inputs with magnitude at least 2<superscript>-(B+1)</superscript> produce normal outputs;
other subnormal inputs produce infinite outputs.
Normal inputs with magnitude at least 2<superscript>B-1</superscript> produce subnormal outputs;
other normal inputs produce normal outputs.</simpara>
</note>
<note>
<simpara>The output value depends on the dynamic rounding mode when
the overflow exception is raised.</simpara>
</note>
<simpara>For the non-exceptional cases, the seven high bits of significand (after the
leading one) are used to address the following table.
The output of the table becomes the seven high bits of the result significand
(after the leading one); the remainder of the result significand is zero.
Subnormal inputs are normalized and the exponent adjusted appropriately before
the lookup.
The output exponent is chosen to make the result approximate the reciprocal of
the argument, and subnormal outputs are denormalized accordingly.</simpara>
<simpara>More precisely, the result is computed as follows.
Let the normalized input exponent be equal to the input exponent if the input
is normal, or 0 minus the number of leading zeros in the significand
otherwise.
The normalized output exponent equals (2*B - 1 - the normalized input exponent).
If the normalized output exponent is outside the range [-1, 2*B], the result
corresponds to one of the exceptional cases in the table above.</simpara>
<simpara>If the input is subnormal, the normalized input significand is given by
shifting the input significand left by 1 minus the normalized input exponent,
discarding the leading 1 bit.
Otherwise, the normalized input significand equals the input significand.
The following table gives the seven MSBs of the normalized output significand
as a function of the seven MSBs of the normalized input significand; the other
bits of the normalized output significand are zero.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>vfrec7.v common-case lookup table contents</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>sig[MSB -: 7]</simpara></entry>
<entry align="left" valign="top"><simpara>sig_out[MSB -: 7]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>127</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>125</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>123</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>121</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>119</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>117</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>116</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>114</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>112</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>110</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>109</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>107</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>105</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>104</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>14</simpara></entry>
<entry align="left" valign="top"><simpara>102</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>99</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>17</simpara></entry>
<entry align="left" valign="top"><simpara>97</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>18</simpara></entry>
<entry align="left" valign="top"><simpara>96</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>19</simpara></entry>
<entry align="left" valign="top"><simpara>94</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>20</simpara></entry>
<entry align="left" valign="top"><simpara>93</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>21</simpara></entry>
<entry align="left" valign="top"><simpara>91</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>22</simpara></entry>
<entry align="left" valign="top"><simpara>90</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>23</simpara></entry>
<entry align="left" valign="top"><simpara>88</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>24</simpara></entry>
<entry align="left" valign="top"><simpara>87</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>25</simpara></entry>
<entry align="left" valign="top"><simpara>85</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>26</simpara></entry>
<entry align="left" valign="top"><simpara>84</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>27</simpara></entry>
<entry align="left" valign="top"><simpara>83</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>28</simpara></entry>
<entry align="left" valign="top"><simpara>81</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>29</simpara></entry>
<entry align="left" valign="top"><simpara>80</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"><simpara>79</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>31</simpara></entry>
<entry align="left" valign="top"><simpara>77</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>76</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>33</simpara></entry>
<entry align="left" valign="top"><simpara>75</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>34</simpara></entry>
<entry align="left" valign="top"><simpara>74</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>35</simpara></entry>
<entry align="left" valign="top"><simpara>72</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>36</simpara></entry>
<entry align="left" valign="top"><simpara>71</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>37</simpara></entry>
<entry align="left" valign="top"><simpara>70</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>38</simpara></entry>
<entry align="left" valign="top"><simpara>69</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>39</simpara></entry>
<entry align="left" valign="top"><simpara>68</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>66</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>41</simpara></entry>
<entry align="left" valign="top"><simpara>65</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>42</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>43</simpara></entry>
<entry align="left" valign="top"><simpara>63</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>44</simpara></entry>
<entry align="left" valign="top"><simpara>62</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>45</simpara></entry>
<entry align="left" valign="top"><simpara>61</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>46</simpara></entry>
<entry align="left" valign="top"><simpara>60</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47</simpara></entry>
<entry align="left" valign="top"><simpara>59</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>48</simpara></entry>
<entry align="left" valign="top"><simpara>58</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>49</simpara></entry>
<entry align="left" valign="top"><simpara>57</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>50</simpara></entry>
<entry align="left" valign="top"><simpara>56</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>51</simpara></entry>
<entry align="left" valign="top"><simpara>55</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>52</simpara></entry>
<entry align="left" valign="top"><simpara>54</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>53</simpara></entry>
<entry align="left" valign="top"><simpara>53</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>54</simpara></entry>
<entry align="left" valign="top"><simpara>52</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>55</simpara></entry>
<entry align="left" valign="top"><simpara>51</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>56</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>57</simpara></entry>
<entry align="left" valign="top"><simpara>49</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>58</simpara></entry>
<entry align="left" valign="top"><simpara>48</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>59</simpara></entry>
<entry align="left" valign="top"><simpara>47</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>60</simpara></entry>
<entry align="left" valign="top"><simpara>46</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>61</simpara></entry>
<entry align="left" valign="top"><simpara>45</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>62</simpara></entry>
<entry align="left" valign="top"><simpara>44</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>63</simpara></entry>
<entry align="left" valign="top"><simpara>43</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>42</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>65</simpara></entry>
<entry align="left" valign="top"><simpara>41</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>66</simpara></entry>
<entry align="left" valign="top"><simpara>40</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>67</simpara></entry>
<entry align="left" valign="top"><simpara>40</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>68</simpara></entry>
<entry align="left" valign="top"><simpara>39</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>69</simpara></entry>
<entry align="left" valign="top"><simpara>38</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>70</simpara></entry>
<entry align="left" valign="top"><simpara>37</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>71</simpara></entry>
<entry align="left" valign="top"><simpara>36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>72</simpara></entry>
<entry align="left" valign="top"><simpara>35</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>73</simpara></entry>
<entry align="left" valign="top"><simpara>35</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>74</simpara></entry>
<entry align="left" valign="top"><simpara>34</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>75</simpara></entry>
<entry align="left" valign="top"><simpara>33</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>76</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>77</simpara></entry>
<entry align="left" valign="top"><simpara>31</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>78</simpara></entry>
<entry align="left" valign="top"><simpara>31</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>79</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>80</simpara></entry>
<entry align="left" valign="top"><simpara>29</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>81</simpara></entry>
<entry align="left" valign="top"><simpara>28</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>82</simpara></entry>
<entry align="left" valign="top"><simpara>28</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>83</simpara></entry>
<entry align="left" valign="top"><simpara>27</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>84</simpara></entry>
<entry align="left" valign="top"><simpara>26</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>85</simpara></entry>
<entry align="left" valign="top"><simpara>25</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>86</simpara></entry>
<entry align="left" valign="top"><simpara>25</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>87</simpara></entry>
<entry align="left" valign="top"><simpara>24</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>88</simpara></entry>
<entry align="left" valign="top"><simpara>23</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>89</simpara></entry>
<entry align="left" valign="top"><simpara>23</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>90</simpara></entry>
<entry align="left" valign="top"><simpara>22</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>91</simpara></entry>
<entry align="left" valign="top"><simpara>21</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>92</simpara></entry>
<entry align="left" valign="top"><simpara>21</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>93</simpara></entry>
<entry align="left" valign="top"><simpara>20</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>94</simpara></entry>
<entry align="left" valign="top"><simpara>19</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>95</simpara></entry>
<entry align="left" valign="top"><simpara>19</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>96</simpara></entry>
<entry align="left" valign="top"><simpara>18</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>97</simpara></entry>
<entry align="left" valign="top"><simpara>17</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>98</simpara></entry>
<entry align="left" valign="top"><simpara>17</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>99</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>102</simpara></entry>
<entry align="left" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>103</simpara></entry>
<entry align="left" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>104</simpara></entry>
<entry align="left" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>105</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>106</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>107</simpara></entry>
<entry align="left" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>108</simpara></entry>
<entry align="left" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>109</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>111</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>112</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>113</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>114</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>115</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>116</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>117</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>118</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>119</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>121</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>122</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>123</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>124</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>125</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>126</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>127</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>If the normalized output exponent is 0 or -1, the result is subnormal: the
output exponent is 0, and the output significand is given by concatenating
a 1 bit to the left of the normalized output significand, then shifting that
quantity right by 1 minus the normalized output exponent.
Otherwise, the output exponent equals the normalized output exponent, and the
output significand equals the normalized output significand.
The output sign equals the input sign.</simpara>
<note>
<simpara>For example, when SEW=32, vfrec7(0x00718abc (≈ 1.043e-38))
= 0x7e900000 (≈ 9.570e37), and vfrec7(0x7f765432 (≈ 3.274e38))
= 0x00214000 (≈ 3.053e-39).</simpara>
</note>
<note>
<simpara>The 7 bit accuracy was chosen as it requires 0,1,2,3
Newton-Raphson iterations to converge to close to bfloat16, FP16,
FP32, FP64 accuracy respectively.   Future instructions can be defined
with greater estimate accuracy.</simpara>
</note>
</section>
<section xml:id="_vector_floating_point_minmax_instructions">
<title>Vector Floating-Point MIN/MAX Instructions</title>
<simpara>The vector floating-point <literal>vfmin</literal> and <literal>vfmax</literal> instructions have the
same behavior as the corresponding scalar floating-point instructions
in version 2.2 of the RISC-V F/D/Q extension.</simpara>
<screen>    # Floating-point minimum
    vfmin.vv vd, vs2, vs1, vm   # Vector-vector
    vfmin.vf vd, vs2, rs1, vm   # vector-scalar

    # Floating-point maximum
    vfmax.vv vd, vs2, vs1, vm   # Vector-vector
    vfmax.vf vd, vs2, rs1, vm   # vector-scalar</screen>
</section>
<section xml:id="_vector_floating_point_sign_injection_instructions">
<title>Vector Floating-Point Sign-Injection Instructions</title>
<simpara>Vector versions of the scalar sign-injection instructions.  The result
takes all bits except the sign bit from the vector <literal>vs2</literal> operands.</simpara>
<screen>    vfsgnj.vv vd, vs2, vs1, vm   # Vector-vector
    vfsgnj.vf vd, vs2, rs1, vm   # vector-scalar

    vfsgnjn.vv vd, vs2, vs1, vm  # Vector-vector
    vfsgnjn.vf vd, vs2, rs1, vm  # vector-scalar

    vfsgnjx.vv vd, vs2, vs1, vm  # Vector-vector
    vfsgnjx.vf vd, vs2, rs1, vm  # vector-scalar</screen>
<note>
<simpara>A vector of floating-point values can be negated using a
sign-injection instruction with both source operands set to the same
vector operand.  Can define assembly pseudoinstruction <literal>vfneg.v vd,vs</literal>
= <literal>vfsgnjn.vv vd,vs,vs</literal>.</simpara>
</note>
<note>
<simpara>The absolute value of a vector of floating-point elements can be
calculated using a sign-injection instruction with both source
operands set to the same vector operand.  Can define assembly
pseudoinstruction <literal>vfabs.v vd,vs</literal> = <literal>vfsgnjx.vv vd,vs,vs</literal>.</simpara>
</note>
</section>
<section xml:id="_vector_floating_point_compare_instructions">
<title>Vector Floating-Point Compare Instructions</title>
<simpara>These vector FP compare instructions compare two source operands and
write the comparison result to a mask register.  The destination mask
vector is always held in a single vector register, with a layout of
elements as described in Section <xref linkend="sec-mask-register-layout"/>.  The
destination mask vector register may be the same as the source vector
mask register (<literal>v0</literal>).  Comparisons write mask registers, and so always
operate under a tail-agnostic policy.</simpara>
<simpara>The compare instructions follow the semantics of the scalar
floating-point compare instructions.  <literal>vmfeq</literal> and <literal>vmfne</literal> raise the invalid
operation exception only on signaling NaN inputs.  <literal>vmflt</literal>, <literal>vmfle</literal>, <literal>vmfgt</literal>,
and <literal>vmfge</literal> raise the invalid operation exception on both signaling and
quiet NaN inputs.
<literal>vmfne</literal> writes 1 to the destination element when either
operand is NaN, whereas the other comparisons write 0 when either operand
is NaN.</simpara>
<screen>    # Compare equal
    vmfeq.vv vd, vs2, vs1, vm  # Vector-vector
    vmfeq.vf vd, vs2, rs1, vm  # vector-scalar

    # Compare not equal
    vmfne.vv vd, vs2, vs1, vm  # Vector-vector
    vmfne.vf vd, vs2, rs1, vm  # vector-scalar

    # Compare less than
    vmflt.vv vd, vs2, vs1, vm  # Vector-vector
    vmflt.vf vd, vs2, rs1, vm  # vector-scalar

    # Compare less than or equal
    vmfle.vv vd, vs2, vs1, vm  # Vector-vector
    vmfle.vf vd, vs2, rs1, vm  # vector-scalar

    # Compare greater than
    vmfgt.vf vd, vs2, rs1, vm  # vector-scalar

    # Compare greater than or equal
    vmfge.vf vd, vs2, rs1, vm  # vector-scalar</screen>
<screen>Comparison      Assembler Mapping             Assembler pseudoinstruction

va &lt; vb         vmflt.vv vd, va, vb, vm
va &lt;= vb        vmfle.vv vd, va, vb, vm
va &gt; vb         vmflt.vv vd, vb, va, vm    vmfgt.vv vd, va, vb, vm
va &gt;= vb        vmfle.vv vd, vb, va, vm    vmfge.vv vd, va, vb, vm

va &lt; f          vmflt.vf vd, va, f, vm
va &lt;= f         vmfle.vf vd, va, f, vm
va &gt; f          vmfgt.vf vd, va, f, vm
va &gt;= f         vmfge.vf vd, va, f, vm

va, vb vector register groups
f      scalar floating-point register</screen>
<note>
<simpara>Providing all forms is necessary to correctly handle unordered
comparisons for NaNs.</simpara>
</note>
<note>
<simpara>C99 floating-point quiet comparisons can be implemented by masking
the signaling comparisons when either input is NaN, as follows.  When
the comparand is a non-NaN constant, the middle two instructions can be
omitted.</simpara>
</note>
<screen>    # Example of implementing isgreater()
    vmfeq.vv v0, va, va        # Only set where A is not NaN.
    vmfeq.vv v1, vb, vb        # Only set where B is not NaN.
    vmand.mm v0, v0, v1        # Only set where A and B are ordered,
    vmfgt.vv v0, va, vb, v0.t  #  so only set flags on ordered values.</screen>
<note>
<simpara>In the above sequence, it is tempting to mask the second <literal>vmfeq</literal>
instruction and remove the <literal>vmand</literal> instruction, but this more efficient
sequence incorrectly fails to raise the invalid exception when an
element of <literal>va</literal> contains a quiet NaN and the corresponding element in
<literal>vb</literal> contains a signaling NaN.</simpara>
</note>
</section>
<section xml:id="_vector_floating_point_classify_instruction">
<title>Vector Floating-Point Classify Instruction</title>
<simpara>This is a unary vector-vector instruction that operates in the same
way as the scalar classify instruction.</simpara>
<screen>    vfclass.v vd, vs2, vm   # Vector-vector</screen>
<simpara>The 10-bit mask produced by this instruction is placed in the
least-significant bits of the result elements.  The upper (SEW-10)
bits of the result are filled with zeros. The instruction is only
defined for SEW=16b and above, so the result will always fit in the
destination elements.</simpara>
</section>
<section xml:id="_vector_floating_point_merge_instruction">
<title>Vector Floating-Point Merge Instruction</title>
<simpara>A vector-scalar floating-point merge instruction is provided, which
operates on all body elements, from <literal>vstart</literal> up to the current vector
length in <literal>vl</literal> regardless of mask value.</simpara>
<simpara>The <literal>vfmerge.vfm</literal> instruction is encoded as a masked instruction (<literal>vm=0</literal>).
At elements where the mask value is zero, the first vector operand is
copied to the destination element, otherwise a scalar floating-point
register value is copied to the destination element.</simpara>
<screen>vfmerge.vfm vd, vs2, rs1, v0  # vd[i] = v0.mask[i] ? f[rs1] : vs2[i]</screen>
</section>
<section xml:id="_vector_floating_point_move_instruction">
<title>Vector Floating-Point Move Instruction</title>
<simpara>The vector floating-point move instruction <emphasis>splats</emphasis> a floating-point
scalar operand to a vector register group.  The instruction copies a
scalar <literal>f</literal> register value to all active elements of a vector register
group.  This instruction is encoded as a masked instruction (<literal>vm=1</literal>).
The instruction must have the <literal>vs2</literal> field set to <literal>v0</literal>, with all other
values for <literal>vs2</literal> reserved.</simpara>
<screen>vfmv.v.f vd, rs1  # vd[i] = f[rs1]</screen>
<note>
<simpara>The <literal>vfmv.v.f</literal> instruction shares the encoding with the <literal>vfmerge.vfm</literal>
instruction, but with <literal>vm=1</literal> and <literal>vs2=v0</literal>.</simpara>
</note>
</section>
<section xml:id="_single_width_floating_pointinteger_type_convert_instructions">
<title>Single-Width Floating-Point/Integer Type-Convert Instructions</title>
<simpara>Conversion operations are provided to convert to and from
floating-point values and unsigned and signed integers, where both
source and destination are SEW wide.</simpara>
<screen>vfcvt.xu.f.v vd, vs2, vm       # Convert float to unsigned integer.
vfcvt.x.f.v  vd, vs2, vm       # Convert float to signed integer.

vfcvt.rtz.xu.f.v vd, vs2, vm   # Convert float to unsigned integer, truncating.
vfcvt.rtz.x.f.v  vd, vs2, vm   # Convert float to signed integer, truncating.

vfcvt.f.xu.v vd, vs2, vm       # Convert unsigned integer to float.
vfcvt.f.x.v  vd, vs2, vm       # Convert signed integer to float.</screen>
<simpara>The conversions follow the same rules on exceptional conditions as the
scalar conversion instructions.
The conversions use the dynamic rounding mode in <literal>frm</literal>, except for the <literal>rtz</literal>
variants, which round towards zero.</simpara>
<note>
<simpara>The <literal>rtz</literal> variants are provided to accelerate truncating conversions
from floating-point to integer, as is common in languages like C and Java.</simpara>
</note>
</section>
<section xml:id="_widening_floating_pointinteger_type_convert_instructions">
<title>Widening Floating-Point/Integer Type-Convert Instructions</title>
<simpara>A set of conversion instructions is provided to convert between
narrower integer and floating-point datatypes to a type of twice the
width.</simpara>
<screen>vfwcvt.xu.f.v vd, vs2, vm       # Convert float to double-width unsigned integer.
vfwcvt.x.f.v  vd, vs2, vm       # Convert float to double-width signed integer.

vfwcvt.rtz.xu.f.v vd, vs2, vm   # Convert float to double-width unsigned integer, truncating.
vfwcvt.rtz.x.f.v  vd, vs2, vm   # Convert float to double-width signed integer, truncating.

vfwcvt.f.xu.v vd, vs2, vm       # Convert unsigned integer to double-width float.
vfwcvt.f.x.v  vd, vs2, vm       # Convert signed integer to double-width float.

vfwcvt.f.f.v vd, vs2, vm        # Convert single-width float to double-width float.</screen>
<simpara>These instructions have the same constraints on vector register overlap
as other widening instructions (see <xref linkend="sec-widening"/>).</simpara>
<note>
<simpara>A double-width IEEE floating-point value can always represent a
single-width integer exactly.</simpara>
</note>
<note>
<simpara>A double-width IEEE floating-point value can always represent a
single-width IEEE floating-point value exactly.</simpara>
</note>
<note>
<simpara>A full set of floating-point widening conversions is not
supported as single instructions, but any widening conversion can be
implemented as several doubling steps with equivalent results and no
additional exception flags raised.</simpara>
</note>
</section>
<section xml:id="_narrowing_floating_pointinteger_type_convert_instructions">
<title>Narrowing Floating-Point/Integer Type-Convert Instructions</title>
<simpara>A set of conversion instructions is provided to convert wider integer
and floating-point datatypes to a type of half the width.</simpara>
<screen>vfncvt.xu.f.w vd, vs2, vm       # Convert double-width float to unsigned integer.
vfncvt.x.f.w  vd, vs2, vm       # Convert double-width float to signed integer.

vfncvt.rtz.xu.f.w vd, vs2, vm   # Convert double-width float to unsigned integer, truncating.
vfncvt.rtz.x.f.w  vd, vs2, vm   # Convert double-width float to signed integer, truncating.

vfncvt.f.xu.w vd, vs2, vm       # Convert double-width unsigned integer to float.
vfncvt.f.x.w  vd, vs2, vm       # Convert double-width signed integer to float.

vfncvt.f.f.w vd, vs2, vm        # Convert double-width float to single-width float.
vfncvt.rod.f.f.w vd, vs2, vm    # Convert double-width float to single-width float,
                                #  rounding towards odd.</screen>
<simpara>These instructions have the same constraints on vector register overlap
as other narrowing instructions (see <xref linkend="sec-narrowing"/>).</simpara>
<note>
<simpara>A full set of floating-point widening conversions is not
supported as single instructions. Conversions can be implemented in
a sequence of halving steps.  Results are equivalently rounded and
the same exception flags are raised if all but the last halving step
use round-towards-odd (<literal>vfncvt.rod.f.f.w</literal>).  Only the final step
should use the desired rounding mode.</simpara>
</note>
</section>
</section>
<section xml:id="_vector_reduction_operations">
<title>Vector Reduction Operations</title>
<simpara>Vector reduction operations take a vector register group of elements
and a scalar held in element 0 of a vector register, and perform a
reduction using some binary operator, to produce a scalar result in
element 0 of a vector register.  The scalar input and output operands
are held in element 0 of a single vector register, not a vector
register group, so any vector register can be the scalar source or
destination of a vector reduction regardless of LMUL setting.</simpara>
<simpara>The destination vector register can overlap the source operands,
including the mask register.</simpara>
<note>
<simpara>Reductions read and write the scalar operand and result into
element 0 of a vector register to avoid a loss of decoupling with the
scalar processor, and to support future polymorphic use with future
types not supported in the scalar unit.</simpara>
</note>
<simpara>Inactive elements from the source vector register group are excluded
from the reduction, but the scalar operand is always included
regardless of the mask values.</simpara>
<simpara>The other elements in the destination vector register ( 0 &lt; index &lt;
VLEN/SEW) are considered the tail and are managed with the current
tail agnostic/undisturbed policy.</simpara>
<simpara>If <literal>vl</literal>=0, no operation is performed and the destination register is
not updated.</simpara>
<simpara>Traps on vector reduction instructions are always reported with a
<literal>vstart</literal> of 0.  Vector reduction operations raise an illegal
instruction exception if <literal>vstart</literal> is non-zero.</simpara>
<simpara>The assembler syntax for a reduction operation is <literal>vredop.vs</literal>, where
the <literal>.vs</literal> suffix denotes the first operand is a vector register group
and the second operand is a scalar stored in element 0 of a vector
register.</simpara>
<section xml:id="sec-vector-integer-reduce">
<title>Vector Single-Width Integer Reduction Instructions</title>
<simpara>All operands and results of single-width reduction instructions have
the same SEW width.  Overflows wrap around on arithmetic sums.</simpara>
<screen>    # Simple reductions, where [*] denotes all active elements:
    vredsum.vs  vd, vs2, vs1, vm   # vd[0] =  sum( vs1[0] , vs2[*] )
    vredmaxu.vs vd, vs2, vs1, vm   # vd[0] = maxu( vs1[0] , vs2[*] )
    vredmax.vs  vd, vs2, vs1, vm   # vd[0] =  max( vs1[0] , vs2[*] )
    vredminu.vs vd, vs2, vs1, vm   # vd[0] = minu( vs1[0] , vs2[*] )
    vredmin.vs  vd, vs2, vs1, vm   # vd[0] =  min( vs1[0] , vs2[*] )
    vredand.vs  vd, vs2, vs1, vm   # vd[0] =  and( vs1[0] , vs2[*] )
    vredor.vs   vd, vs2, vs1, vm   # vd[0] =   or( vs1[0] , vs2[*] )
    vredxor.vs  vd, vs2, vs1, vm   # vd[0] =  xor( vs1[0] , vs2[*] )</screen>
</section>
<section xml:id="sec-vector-integer-reduce-widen">
<title>Vector Widening Integer Reduction Instructions</title>
<simpara>The unsigned <literal>vwredsumu.vs</literal> instruction zero-extends the SEW-wide
vector elements before summing them, then adds the 2*SEW-width scalar
element, and stores the result in a 2*SEW-width scalar element.</simpara>
<simpara>The <literal>vwredsum.vs</literal> instruction sign-extends the SEW-wide vector
elements before summing them.</simpara>
<screen>    # Unsigned sum reduction into double-width accumulator
    vwredsumu.vs vd, vs2, vs1, vm   # 2*SEW = 2*SEW + sum(zero-extend(SEW))

    # Signed sum reduction into double-width accumulator
    vwredsum.vs  vd, vs2, vs1, vm   # 2*SEW = 2*SEW + sum(sign-extend(SEW))</screen>
</section>
<section xml:id="sec-vector-float-reduce">
<title>Vector Single-Width Floating-Point Reduction Instructions</title>
<screen>    # Simple reductions.
    vfredosum.vs vd, vs2, vs1, vm # Ordered sum
    vfredusum.vs vd, vs2, vs1, vm # Unordered sum
    vfredmax.vs  vd, vs2, vs1, vm # Maximum value
    vfredmin.vs  vd, vs2, vs1, vm # Minimum value</screen>
<note>
<simpara>Older assembler mnemonic <literal>vfredsum</literal> is retained as alias for <literal>vfredusum</literal>.</simpara>
</note>
<section xml:id="_vector_ordered_single_width_floating_point_sum_reduction">
<title>Vector Ordered Single-Width Floating-Point Sum Reduction</title>
<simpara>The <literal>vfredosum</literal> instruction must sum the floating-point values in
element order, starting with the scalar in <literal>vs1[0]</literal>--that is, it
performs the computation:</simpara>
<screen> vd[0] = `(((vs1[0] + vs2[0]) + vs2[1]) + ...) + vs2[vl-1]`</screen>
<simpara>where each addition operates identically to the scalar floating-point
instructions in terms of raising exception flags and generating or
propagating special values.</simpara>
<note>
<simpara>The ordered reduction supports compiler autovectorization, while
the unordered FP sum allows for faster implementations.</simpara>
</note>
<simpara>When the operation is masked (<literal>vm=0</literal>), the masked-off elements do not
affect the result or the exception flags.</simpara>
<note>
<simpara>If no elements are active, no additions are performed, so the scalar in
<literal>vs1[0]</literal> is simply copied to the destination register, without canonicalizing
NaN values and without setting any exception flags.  This behavior preserves
the handling of NaNs, exceptions, and rounding when autovectorizing a scalar
summation loop.</simpara>
</note>
</section>
<section xml:id="_vector_unordered_single_width_floating_point_sum_reduction">
<title>Vector Unordered Single-Width Floating-Point Sum Reduction</title>
<simpara>The unordered sum reduction instruction, <literal>vfredusum</literal>, provides an
implementation more freedom in performing the reduction.</simpara>
<simpara>The implementation must produce a result equivalent to a reduction tree
composed of binary operator nodes, with the inputs being elements from
the source vector register group (<literal>vs2</literal>) and the source scalar value
(<literal>vs1[0]</literal>).  Each operator in the tree accepts two inputs and produces
one result.
Each operator first computes an exact sum as a RISC-V scalar floating-point
addition with infinite exponent range and precision, then converts this exact
sum to a floating-point format with range and precision each at least as great
as the element floating-point format indicated by SEW, rounding using the
currently active floating-point dynamic rounding mode.
A different floating-point range and precision may be chosen for the result of
each operator.
A node where one input is derived only from elements masked-off or beyond the
active vector length may either treat that input as the additive identity of the
appropriate EEW or simply copy the other input to its output.
The rounded result from the root node in the tree is converted (rounded again,
using the dynamic rounding mode) to the standard floating-point format
indicated by SEW.
An implementation
is allowed to add an additional additive identity to the final result.</simpara>
<simpara>The additive identity is +0.0 when rounding down (towards -∞) or
-0.0 for all other rounding modes.</simpara>
<simpara>The reduction tree structure must be deterministic for a given value
in <literal>vtype</literal> and <literal>vl</literal>.</simpara>
<note>
<simpara>As a consequence of this definition, implementations need not propagate
NaN payloads through the reduction tree when no elements are active. In
particular, if no elements are active and the scalar input is NaN,
implementations are permitted to canonicalize the NaN and, if the NaN is
signaling, set the invalid exception flag.  Implementations are alternatively
permitted to pass through the original NaN and set no exception flags, as with
<literal>vfredosum</literal>.</simpara>
</note>
<note>
<simpara>The <literal>vfredosum</literal> instruction is a valid implementation of the
<literal>vfredusum</literal> instruction.</simpara>
</note>
</section>
<section xml:id="_vector_single_width_floating_point_max_and_min_reductions">
<title>Vector Single-Width Floating-Point Max and Min Reductions</title>
<note>
<simpara>Floating-point max and min reductions should return the same
final value and raise the same exception flags regardless of operation
order.</simpara>
</note>
<note>
<simpara>If no elements are active, the scalar in <literal>vs1[0]</literal> is simply copied to
the destination register, without canonicalizing NaN values and without
setting any exception flags.</simpara>
</note>
</section>
</section>
<section xml:id="sec-vector-float-reduce-widen">
<title>Vector Widening Floating-Point Reduction Instructions</title>
<simpara>Widening forms of the sum reductions are provided that
read and write a double-width reduction result.</simpara>
<screen> # Simple reductions.
 vfwredosum.vs vd, vs2, vs1, vm # Ordered sum
 vfwredusum.vs vd, vs2, vs1, vm # Unordered sum</screen>
<note>
<simpara>Older assembler mnemonic <literal>vfwredsum</literal> is retained as alias for <literal>vfwredusum</literal>.</simpara>
</note>
<simpara>The reduction of the SEW-width elements is performed as in the
single-width reduction case, with the elements in <literal>vs2</literal> promoted
to 2*SEW bits before adding to the 2*SEW-bit accumulator.</simpara>
<note>
<simpara><literal>vfwredosum.vs</literal> handles inactive elements and NaN payloads analogously
to <literal>vfredosum.vs</literal>; <literal>vfwredusum.vs</literal> does so analogously to <literal>vfredusum.vs</literal>.</simpara>
</note>
</section>
</section>
<section xml:id="sec-vector-mask">
<title>Vector Mask Instructions</title>
<simpara>Several instructions are provided to help operate on mask values held in
a vector register.</simpara>
<section xml:id="sec-mask-register-logical">
<title>Vector Mask-Register Logical Instructions</title>
<simpara>Vector mask-register logical operations operate on mask registers.
Each element in a mask register is a single bit, so these instructions
all operate on single vector registers regardless of the setting of
the <literal>vlmul</literal> field in <literal>vtype</literal>.  They do not change the value of
<literal>vlmul</literal>.  The destination vector register may be the same as either
source vector register.</simpara>
<simpara>As with other vector instructions, the elements with indices less than
<literal>vstart</literal> are unchanged, and <literal>vstart</literal> is reset to zero after execution.
Vector mask logical instructions are always unmasked, so there are no
inactive elements, and the encodings with <literal>vm=0</literal> are reserved.
Mask elements past <literal>vl</literal>, the tail elements, are
always updated with a tail-agnostic policy.</simpara>
<screen>    vmand.mm vd, vs2, vs1     # vd.mask[i] =   vs2.mask[i] &amp;&amp;  vs1.mask[i]
    vmnand.mm vd, vs2, vs1    # vd.mask[i] = !(vs2.mask[i] &amp;&amp;  vs1.mask[i])
    vmandnot.mm vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] &amp;&amp; !vs1.mask[i]
    vmxor.mm  vd, vs2, vs1    # vd.mask[i] =   vs2.mask[i] ^^  vs1.mask[i]
    vmor.mm  vd, vs2, vs1     # vd.mask[i] =   vs2.mask[i] ||  vs1.mask[i]
    vmnor.mm  vd, vs2, vs1    # vd.mask[i] = !(vs2.mask[i] ||  vs1.mask[i])
    vmornot.mm  vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] || !vs1.mask[i]
    vmxnor.mm vd, vs2, vs1    # vd.mask[i] = !(vs2.mask[i] ^^  vs1.mask[i])</screen>
<simpara>Several assembler pseudoinstructions are defined as shorthand for
common uses of mask logical operations:</simpara>
<screen>    vmmv.m vd, vs  =&gt; vmand.mm vd, vs, vs  # Copy mask register
    vmclr.m vd     =&gt; vmxor.mm vd, vd, vd   # Clear mask register
    vmset.m vd     =&gt; vmxnor.mm vd, vd, vd  # Set mask register
    vmnot.m vd, vs =&gt; vmnand.mm vd, vs, vs  # Invert bits</screen>
<note>
<simpara>The vmmv.m instruction was previously called vmcpy.m, but with
new layout it is more consistent to name as a "mv" because bits are
copied without interpretation.  The vmcpy.m assembler
pseudoinstruction can be retained for compatibility.</simpara>
</note>
<simpara>The set of eight mask logical instructions can generate any of the 16
possibly binary logical functions of the two input masks:</simpara>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="6.25*"/>
<colspec colname="col_2" colwidth="6.25*"/>
<colspec colname="col_3" colwidth="6.25*"/>
<colspec colname="col_4" colwidth="6.25*"/>
<colspec colname="col_5" colwidth="75*"/>
<thead>
<row>
<entry align="left" nameend="col_4" namest="col_1" valign="top">inputs</entry>
<entry align="left" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>src1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>src2</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="6">
<colspec colname="col_1" colwidth="6.25*"/>
<colspec colname="col_2" colwidth="6.25*"/>
<colspec colname="col_3" colwidth="6.25*"/>
<colspec colname="col_4" colwidth="6.25*"/>
<colspec colname="col_5" colwidth="37.5*"/>
<colspec colname="col_6" colwidth="37.5*"/>
<thead>
<row>
<entry align="left" nameend="col_4" namest="col_1" valign="top">output</entry>
<entry align="left" valign="top">instruction</entry>
<entry align="left" valign="top">pseudoinstruction</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vmxor.mm vd, vd, vd</simpara></entry>
<entry align="left" valign="top"><simpara>vmclr.m vd</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vmnor.mm vd, src1, src2</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vmandnot.mm vd, src2, src1</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vmnand.mm vd, src1, src1</simpara></entry>
<entry align="left" valign="top"><simpara>vmnot.m vd, src1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vmandnot.mm vd, src1, src2</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vmnand.mm vd, src2, src2</simpara></entry>
<entry align="left" valign="top"><simpara>vmnot.m vd, src2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vmxor.mm vd, src1, src2</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>vmnand.mm vd, src1, src2</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>vmand.mm vd, src1, src2</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>vmxnor.mm vd, src1, src2</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>vmand.mm vd, src2, src2</simpara></entry>
<entry align="left" valign="top"><simpara>vmmv.m vd, src2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>vmornot.mm vd, src2, src1</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>vmand.mm vd, src1, src1</simpara></entry>
<entry align="left" valign="top"><simpara>vmmv.m vd, src1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>vmornot.mm vd, src1, src2</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>vmxnor.mm vd, vd, vd</simpara></entry>
<entry align="left" valign="top"><simpara>vmset.m vd</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>The vector mask logical instructions are designed to be easily
fused with a following masked vector operation to effectively expand
the number of predicate registers by moving values into <literal>v0</literal> before
use.</simpara>
</note>
</section>
<section xml:id="_vector_mask_population_count_vpopc">
<title>Vector mask population count <literal>vpopc</literal></title>
<screen>    vpopc.m rd, vs2, vm</screen>
<simpara>The source operand is a single vector register holding mask register
values as described in Section <xref linkend="sec-mask-register-layout"/>.</simpara>
<simpara>The <literal>vpopc.m</literal> instruction counts the number of mask elements of the
active elements of the vector source mask register that have the value
1 and writes the result to a scalar <literal>x</literal> register.</simpara>
<simpara>The operation can be performed under a mask, in which case only the
masked elements are counted.</simpara>
<screen> vpopc.m rd, vs2, v0.t # x[rd] = sum_i ( vs2.mask[i] &amp;&amp; v0.mask[i] )</screen>
<simpara>Traps on <literal>vpopc.m</literal> are always reported with a <literal>vstart</literal> of 0.  The
<literal>vpopc</literal> instruction will raise an illegal instruction exception if
<literal>vstart</literal> is non-zero.</simpara>
</section>
<section xml:id="_vfirst_find_first_set_mask_bit">
<title><literal>vfirst</literal> find-first-set mask bit</title>
<screen>    vfirst.m rd, vs2, vm</screen>
<simpara>The <literal>vfirst</literal> instruction finds the lowest-numbered active element of
the source mask vector that has the value 1 and writes that element’s
index to a GPR.  If no active element has the value 1, -1 is written
to the GPR.</simpara>
<note>
<simpara>Software can assume that any negative value (highest bit set)
corresponds to no element found, as vector lengths will never exceed
2<superscript>(XLEN-1)</superscript> on any implementation.</simpara>
</note>
<simpara>Traps on <literal>vfirst</literal> are always reported with a <literal>vstart</literal> of 0.  The
<literal>vfirst</literal> instruction will raise an illegal instruction exception if
<literal>vstart</literal> is non-zero.</simpara>
</section>
<section xml:id="_vmsbf_m_set_before_first_mask_bit">
<title><literal>vmsbf.m</literal> set-before-first mask bit</title>
<screen>    vmsbf.m vd, vs2, vm

 # Example

     7 6 5 4 3 2 1 0   Element number

     1 0 0 1 0 1 0 0   v3 contents
                       vmsbf.m v2, v3
     0 0 0 0 0 0 1 1   v2 contents

     1 0 0 1 0 1 0 1   v3 contents
                       vmsbf.m v2, v3
     0 0 0 0 0 0 0 0   v2

     0 0 0 0 0 0 0 0   v3 contents
                       vmsbf.m v2, v3
     1 1 1 1 1 1 1 1   v2

     1 1 0 0 0 0 1 1   v0 vcontents
     1 0 0 1 0 1 0 0   v3 contents
                       vmsbf.m v2, v3, v0.t
     0 1 x x x x 1 1   v2 contents</screen>
<simpara>The <literal>vmsbf.m</literal> instruction takes a mask register as input and writes
results to a mask register.  The instruction writes a 1 to all active
mask elements before the first source element that is a 1, then
writes a 0 to that element and all following active elements.  If
there is no set bit in the source vector, then all active elements in
the destination are written with a 1.</simpara>
<simpara>The tail elements in the destination mask register are updated under a
tail-agnostic policy.</simpara>
<simpara>Traps on <literal>vmsbf.m</literal> are always reported with a <literal>vstart</literal> of 0.  The
<literal>vmsbf</literal> instruction will raise an illegal instruction exception if
<literal>vstart</literal> is non-zero.</simpara>
<simpara>The destination register cannot overlap the source register
and, if masked, cannot overlap the mask register ('v0').</simpara>
</section>
<section xml:id="_vmsif_m_set_including_first_mask_bit">
<title><literal>vmsif.m</literal> set-including-first mask bit</title>
<simpara>The vector mask set-including-first instruction is similar to
set-before-first, except it also includes the element with a set bit.</simpara>
<screen>    vmsif.m vd, vs2, vm

 # Example

     7 6 5 4 3 2 1 0   Element number

     1 0 0 1 0 1 0 0   v3 contents
                       vmsif.m v2, v3
     0 0 0 0 0 1 1 1   v2 contents

     1 0 0 1 0 1 0 1   v3 contents
                       vmsif.m v2, v3
     0 0 0 0 0 0 0 1   v2

     1 1 0 0 0 0 1 1   v0 vcontents
     1 0 0 1 0 1 0 0   v3 contents
                       vmsif.m v2, v3, v0.t
     1 1 x x x x 1 1   v2 contents</screen>
<simpara>The tail elements in the destination mask register are updated under a
tail-agnostic policy.</simpara>
<simpara>Traps on <literal>vmsif.m</literal> are always reported with a <literal>vstart</literal> of 0.  The
<literal>vmsif</literal> instruction will raise an illegal instruction exception if
<literal>vstart</literal> is non-zero.</simpara>
<simpara>The destination register cannot overlap the source register
and, if masked, cannot overlap the mask register ('v0').</simpara>
</section>
<section xml:id="_vmsof_m_set_only_first_mask_bit">
<title><literal>vmsof.m</literal> set-only-first mask bit</title>
<simpara>The vector mask set-only-first instruction is similar to
set-before-first, except it only sets the first element with a bit
set, if any.</simpara>
<screen>    vmsof.m vd, vs2, vm

 # Example

     7 6 5 4 3 2 1 0   Element number

     1 0 0 1 0 1 0 0   v3 contents
                       vmsof.m v2, v3
     0 0 0 0 0 1 0 0   v2 contents

     1 0 0 1 0 1 0 1   v3 contents
                       vmsof.m v2, v3
     0 0 0 0 0 0 0 1   v2

     1 1 0 0 0 0 1 1   v0 vcontents
     1 1 0 1 0 1 0 0   v3 contents
                       vmsof.m v2, v3, v0.t
     0 1 x x x x 0 0   v2 contents</screen>
<simpara>The tail elements in the destination mask register are updated under a
tail-agnostic policy.</simpara>
<simpara>Traps on <literal>vmsof.m</literal> are always reported with a <literal>vstart</literal> of 0.  The
<literal>vmsof</literal> instruction will raise an illegal instruction exception if
<literal>vstart</literal> is non-zero.</simpara>
<simpara>The destination register cannot overlap the source register
and, if masked, cannot overlap the mask register ('v0').</simpara>
</section>
<section xml:id="_example_using_vector_mask_instructions">
<title>Example using vector mask instructions</title>
<simpara>The following is an example of vectorizing a data-dependent exit loop.</simpara>
<screen>  # char* strcpy(char *dst, const char* src)
strcpy:
      mv a2, a0             # Copy dst
      li t0, -1             # Infinite AVL
loop:
    vsetvli x0, t0, e8, m8, ta, ma  # Max length vectors of bytes
    vle8ff.v v8, (a1)        # Get src bytes
      csrr t1, vl           # Get number of bytes fetched
    vmseq.vi v1, v8, 0      # Flag zero bytes
    vfirst.m a3, v1         # Zero found?
      add a1, a1, t1        # Bump pointer
    vmsif.m v0, v1          # Set mask up to and including zero byte.
    vse8.v v8, (a2), v0.t    # Write out bytes
      add a2, a2, t1        # Bump pointer
      bltz a3, loop         # Zero byte not found, so loop

      ret</screen>
<screen>  # char* strncpy(char *dst, const char* src, size_t n)
strncpy:
      mv a3, a0             # Copy dst
loop:
    vsetvli x0, a2, e8, m8, ta, ma   # Vectors of bytes.
    vle8ff.v v8, (a1)        # Get src bytes
    vmseq.vi v1, v8, 0      # Flag zero bytes
      csrr t1, vl           # Get number of bytes fetched
    vfirst.m a4, v1         # Zero found?
    vmsif.m v0, v1          # Set mask up to and including zero byte.
    vse8.v v8, (a3), v0.t    # Write out bytes
      sub a2, a2, t1        # Decrement count.
      bgez a4, zero_tail    # Zero remaining bytes.
      add a1, a1, t1        # Bump pointer
      add a3, a3, t1        # Bump pointer
      bnez a2, loop         # Anymore?

      ret

zero_tail:
    vsetvli x0, a2, e8, m8, ta, ma   # Vectors of bytes.
    vmv.v.i v0, 0           # Splat zero.

zero_loop:
    vsetvli t1, a2, e8, m8, ta, ma   # Vectors of bytes.
    vse8.v v0, (a3)          # Store zero.
      sub a2, a2, t1        # Decrement count.
      add a3, a3, t1        # Bump pointer
      bnez a2, zero_loop    # Anymore?

      ret</screen>
</section>
<section xml:id="_vector_iota_instruction">
<title>Vector Iota Instruction</title>
<simpara>The <literal>viota.m</literal> instruction reads a source vector mask register and
writes to each element of the destination vector register group the
sum of all the bits of elements in the mask register
whose index is less than the element, e.g., a parallel prefix sum of
the mask values.</simpara>
<simpara>This instruction can be masked, in which case only the enabled
elements contribute to the sum.</simpara>
<screen> viota.m vd, vs2, vm

 # Example

     7 6 5 4 3 2 1 0   Element number

     1 0 0 1 0 0 0 1   v2 contents
                       viota.m v4, v2 # Unmasked
     2 2 2 1 1 1 1 0   v4 result

     1 1 1 0 1 0 1 1   v0 contents
     1 0 0 1 0 0 0 1   v2 contents
     2 3 4 5 6 7 8 9   v4 contents
                       viota.m v4, v2, v0.t # Masked, vtype.vma=0
     1 1 1 5 1 7 1 0   v4 results</screen>
<simpara>The result value is zero-extended to fill the destination element if
SEW is wider than the result.  If the result value would overflow the
destination SEW, the least-significant SEW bits are retained.</simpara>
<simpara>Traps on <literal>viota.m</literal> are always reported with a <literal>vstart</literal> of 0, and
execution is always restarted from the beginning when resuming after a
trap handler.  An illegal instruction exception is raised if <literal>vstart</literal>
is non-zero.</simpara>
<simpara>The destination register group cannot overlap the source register
and, if masked, cannot overlap the mask register (<literal>v0</literal>).</simpara>
<note>
<simpara>These constraints exist for two reasons.  First, to simplify
avoidance of WAR hazards in implementations with temporally long vector
registers and no vector register renaming.  Second, to enable resuming
execution after a trap simpler.</simpara>
</note>
<simpara>The <literal>viota.m</literal> instruction can be combined with memory scatter
instructions (indexed stores) to perform vector compress functions.</simpara>
<screen>    # Compact non-zero elements from input memory array to output memory array
    #
    # size_t compact_non_zero(size_t n, const int* in, int* out)
    # {
    #   size_t i;
    #   size_t count = 0;
    #   int *p = out;
    #
    #   for (i=0; i&lt;n; i++)
    #   {
    #       const int v = *in++;
    #       if (v != 0)
    #           *p++ = v;
    #   }
    #
    #   return (size_t) (p - out);
    # }
    #
    # a0 = n
    # a1 = &amp;in
    # a2 = &amp;out

compact_non_zero:
    li a6, 0                      # Clear count of non-zero elements
loop:
    vsetvli a5, a0, e32, m8, ta, ma   # 32-bit integers
    vle32.v v8, (a1)               # Load input vector
      sub a0, a0, a5               # Decrement number done
      slli a5, a5, 2               # Multiply by four bytes
    vmsne.vi v0, v8, 0             # Locate non-zero values
      add a1, a1, a5               # Bump input pointer
    vpopc.m a5, v0                 # Count number of elements set in v0
    viota.m v16, v0                # Get destination offsets of active elements
      add a6, a6, a5               # Accumulate number of elements
    vsll.vi v16, v16, 2, v0.t      # Multiply offsets by four bytes
      slli a5, a5, 2               # Multiply number of non-zero elements by four bytes
    vsuxei32.v v8, (a2), v16, v0.t # Scatter using scaled viota results under mask
      add a2, a2, a5               # Bump output pointer
      bnez a0, loop                # Any more?

      mv a0, a6                    # Return count
      ret</screen>
</section>
<section xml:id="_vector_element_index_instruction">
<title>Vector Element Index Instruction</title>
<simpara>The <literal>vid.v</literal> instruction writes each element’s index to the
destination vector register group, from 0 to <literal>vl</literal>-1.</simpara>
<screen>    vid.v vd, vm  # Write element ID to destination.</screen>
<simpara>The instruction can be masked.</simpara>
<simpara>The <literal>vs2</literal> field of the instruction must be set to <literal>v0</literal>, otherwise the
encoding is <emphasis>reserved</emphasis>.</simpara>
<simpara>The result value is zero-extended to fill the destination element if
SEW is wider than the result.  If the result value would overflow the
destination SEW, the least-significant SEW bits are retained.</simpara>
<note>
<simpara>Microarchitectures can implement <literal>vid.v</literal> instruction using the
same datapath as <literal>viota.m</literal> but with an implicit set mask source.</simpara>
</note>
</section>
</section>
<section xml:id="sec-vector-permute">
<title>Vector Permutation Instructions</title>
<simpara>A range of permutation instructions are provided to move elements
around within the vector registers.</simpara>
<section xml:id="_integer_scalar_move_instructions">
<title>Integer Scalar Move Instructions</title>
<simpara>The integer scalar read/write instructions transfer a single
value between a scalar <literal>x</literal> register and element 0 of a vector
register.  The instructions ignore LMUL and vector register groups.</simpara>
<screen>vmv.x.s rd, vs2  # x[rd] = vs2[0] (vs1=0)
vmv.s.x vd, rs1  # vd[0] = x[rs1] (vs2=0)</screen>
<simpara>The <literal>vmv.x.s</literal> instruction copies a single SEW-wide element from index 0 of the
source vector register to a destination integer register.  If SEW &gt; XLEN, the
least-significant XLEN bits are transferred and the upper SEW-XLEN bits are
ignored.  If SEW &lt; XLEN, the value is sign-extended to XLEN bits.</simpara>
<simpara>The <literal>vmv.s.x</literal> instruction copies the scalar integer register to element 0 of
the destination vector register.  If SEW &lt; XLEN, the least-significant bits
are copied and the upper XLEN-SEW bits are ignored.  If SEW &gt; XLEN, the value
is sign-extended to SEW bits.  The other elements in the destination vector
register ( 0 &lt; index &lt; VLEN/SEW) are treated as tail elements using the current tail agnostic/undisturbed policy.  If <literal>vstart</literal> ≥ <literal>vl</literal>, no
operation is performed and the destination register is not updated.</simpara>
<note>
<simpara>As a consequence, when <literal>vl</literal>=0, no elements are updated in the
destination vector register group, regardless of <literal>vstart</literal>.</simpara>
</note>
<simpara>The encodings corresponding to the masked versions (<literal>vm=0</literal>) of <literal>vmv.x.s</literal>
and <literal>vmv.s.x</literal> are reserved.</simpara>
</section>
<section xml:id="_floating_point_scalar_move_instructions">
<title>Floating-Point Scalar Move Instructions</title>
<simpara>The floating-point scalar read/write instructions transfer a single
value between a scalar <literal>f</literal> register and element 0 of a vector
register.  The instructions ignore LMUL and vector register groups.</simpara>
<screen>vfmv.f.s rd, vs2  # f[rd] = vs2[0] (rs1=0)
vfmv.s.f vd, rs1  # vd[0] = f[rs1] (vs2=0)</screen>
<simpara>The <literal>vfmv.f.s</literal> instruction copies a single SEW-wide element from index
0 of the source vector register to a destination scalar floating-point
register.</simpara>
<simpara>The <literal>vfmv.s.f</literal> instruction copies the scalar floating-point register
to element 0 of the destination vector register.  The other elements
in the destination vector register ( 0 &lt; index &lt; VLEN/SEW) are treated
as tail elements using the current tail agnostic/undisturbed policy.
If <literal>vstart</literal> ≥ <literal>vl</literal>, no operation is performed and the destination
register is not updated.</simpara>
<note>
<simpara>As a consequence, when <literal>vl</literal>=0, no elements are updated in the
destination vector register group, regardless of <literal>vstart</literal>.</simpara>
</note>
<simpara>The encodings corresponding to the masked versions (<literal>vm=0</literal>) of <literal>vfmv.f.s</literal>
and <literal>vfmv.s.f</literal> are reserved.</simpara>
</section>
<section xml:id="_vector_slide_instructions">
<title>Vector Slide Instructions</title>
<simpara>The slide instructions move elements up and down a vector register
group.</simpara>
<note>
<simpara>The slide operations can be implemented much more efficiently
than using the arbitrary register gather instruction.  Implementations
may optimize certain OFFSET values for <literal>vslideup</literal> and <literal>vslidedown</literal>.
In particular, power-of-2 offsets may operate substantially faster
than other offsets.</simpara>
</note>
<simpara>For all of the <literal>vslideup</literal>, <literal>vslidedown</literal>, <literal>v[f]slide1up</literal>, and
<literal>v[f]slide1down</literal> instructions, if <literal>vstart</literal> ≥ <literal>vl</literal>, the instruction performs no
operation and leaves the destination vector register unchanged.</simpara>
<note>
<simpara>As a consequence, when <literal>vl</literal>=0, no elements are updated in the
destination vector register group, regardless of <literal>vstart</literal>.</simpara>
</note>
<simpara>The tail agnostic/undisturbed policy is followed for tail elements.</simpara>
<simpara>The slide instructions may be masked, with mask element <emphasis>i</emphasis>
controlling whether <emphasis>destination</emphasis> element <emphasis>i</emphasis> is written.  The mask
undisturbed/agnostic policy is followed for inactive elements.</simpara>
<section xml:id="_vector_slideup_instructions">
<title>Vector Slideup Instructions</title>
<screen> vslideup.vx vd, vs2, rs1, vm        # vd[i+rs1] = vs2[i]
 vslideup.vi vd, vs2, uimm, vm       # vd[i+uimm] = vs2[i]</screen>
<simpara>For <literal>vslideup</literal>, the value in <literal>vl</literal> specifies the maximum number of destination
elements that are written.  The start index (<emphasis>OFFSET</emphasis>) for the
destination can be either specified using an unsigned integer in the
<literal>x</literal> register specified by <literal>rs1</literal>, or a 5-bit immediate, zero-extended to XLEN bits.
If XLEN &gt; SEW, <emphasis>OFFSET</emphasis> is <emphasis>not</emphasis> truncated to SEW bits.
Destination elements <emphasis>OFFSET</emphasis> through <literal>vl</literal>-1 are written if unmasked and
if <emphasis>OFFSET</emphasis> &lt; <literal>vl</literal>.</simpara>
<screen>   vslideup behavior for destination elements

   OFFSET is amount to slideup, either from x register or a 5-bit immediate

                    0 &lt;  i &lt; max(vstart, OFFSET)  Unchanged
  max(vstart, OFFSET) &lt;= i &lt; vl                   vd[i] = vs2[i-OFFSET] if v0.mask[i] enabled
                   vl &lt;= i &lt; VLMAX                Follow tail policy</screen>
<simpara>The destination vector register group for <literal>vslideup</literal> cannot overlap
the source vector register group, otherwise the instruction encoding
is reserved.</simpara>
<note>
<simpara>The non-overlap constraint avoids WAR hazards on the
input vectors during execution, and enables restart with non-zero
<literal>vstart</literal>.</simpara>
</note>
</section>
<section xml:id="_vector_slidedown_instructions">
<title>Vector Slidedown Instructions</title>
<screen> vslidedown.vx vd, vs2, rs1, vm       # vd[i] = vs2[i+rs1]
 vslidedown.vi vd, vs2, uimm, vm      # vd[i] = vs2[i+uimm]</screen>
<simpara>For <literal>vslidedown</literal>, the value in <literal>vl</literal> specifies the maximum number of
destination elements that are written.  The remaining elements past
<literal>vl</literal> are handled according to the current tail policy (Section
<xref linkend="sec-agnostic"/>).</simpara>
<simpara>The start index (<emphasis>OFFSET</emphasis>) for the source can be either specified
using an unsigned integer in the <literal>x</literal> register specified by <literal>rs1</literal>, or a
5-bit immediate, zero-extended to XLEN bits.
If XLEN &gt; SEW, <emphasis>OFFSET</emphasis> is <emphasis>not</emphasis> truncated to SEW bits.</simpara>
<screen>  vslidedown behavior for source elements for element i in slide
                   0 &lt;= i+OFFSET &lt; VLMAX   src[i] = vs2[i+OFFSET]
               VLMAX &lt;= i+OFFSET           src[i] = 0

  vslidedown behavior for destination element i in slide
                   0 &lt;  i &lt; vstart         Unchanged
              vstart &lt;= i &lt; vl             vd[i] = src[i] if v0.mask[i] enabled
                  vl &lt;= i &lt; VLMAX          Follow tail policy</screen>
</section>
<section xml:id="_vector_slide1up">
<title>Vector Slide1up</title>
<simpara>Variants of slide are provided that only move by one element but which
also allow a scalar integer value to be inserted at the vacated
element position.</simpara>
<screen> vslide1up.vx  vd, vs2, rs1, vm        # vd[0]=x[rs1], vd[i+1] = vs2[i]
 vfslide1up.vf vd, vs2, rs1, vm        # vd[0]=f[rs1], vd[i+1] = vs2[i]</screen>
<simpara>The <literal>vslide1up</literal> instruction places the <literal>x</literal> register argument at
location 0 of the destination vector register group, provided that
element 0 is active, otherwise the destination element update follows the
current mask agnostic/undisturbed policy.  If XLEN &lt; SEW, the value is
sign-extended to SEW bits.  If XLEN &gt; SEW, the least-significant bits
are copied over and the high SEW-XLEN bits are ignored.</simpara>
<simpara>The remaining active <literal>vl</literal>-1 elements are copied over from index <emphasis>i</emphasis> in
the source vector register group to index <emphasis>i</emphasis>+1 in the destination
vector register group.</simpara>
<simpara>The <literal>vl</literal> register specifies the maximum number of destination vector
register elements updated with source values, and remaining elements
past <literal>vl</literal> are handled according to the current tail policy (Section
<xref linkend="sec-agnostic"/>).</simpara>
<screen>   vslide1up behavior

                    i &lt; vstart  unchanged
                0 = i = vstart  vd[i] = x[rs1] if v0.mask[i] enabled
  max(vstart, 1) &lt;= i &lt; vl      vd[i] = vs2[i-1] if v0.mask[i] enabled
              vl &lt;= i &lt; VLMAX   Follow tail policy</screen>
<simpara>The <literal>vslide1up</literal> instruction requires that the destination vector
register group does not overlap the source vector register group.
Otherwise, the instruction encoding is reserved.</simpara>
<simpara>The <literal>vfslide1up</literal> instruction is defined analogously, but sources its
scalar argument from an <literal>f</literal> register.</simpara>
</section>
<section xml:id="_vector_slide1down_instruction">
<title>Vector Slide1down Instruction</title>
<simpara>The <literal>vslide1down</literal> instruction copies the first <literal>vl</literal>-1 active elements
values from index <emphasis>i</emphasis>+1 in the source vector register group to index
<emphasis>i</emphasis> in the destination vector register group.</simpara>
<simpara>The <literal>vl</literal> register specifies the maximum number of destination vector
register elements written with source values, and remaining elements
past <literal>vl</literal> are handled according to the current tail policy (Section
<xref linkend="sec-agnostic"/>).</simpara>
<screen> vslide1down.vx  vd, vs2, rs1, vm      # vd[i] = vs2[i+1], vd[vl-1]=x[rs1]
 vfslide1down.vf vd, vs2, rs1, vm      # vd[i] = vs2[i+1], vd[vl-1]=f[rs1]</screen>
<simpara>The <literal>vslide1down</literal> instruction places the <literal>x</literal> register argument at
location <literal>vl</literal>-1 in the destination vector register, provided that
element <literal>vl-1</literal> is active, otherwise the destination element is
unchanged. If XLEN &lt; SEW, the value is sign-extended to SEW bits.  If
XLEN &gt; SEW, the least-significant bits are copied over and the high
SEW-XLEN bits are ignored.</simpara>
<screen>   vslide1down behavior

                       i &lt; vstart  unchanged
             vstart &lt;= i &lt; vl-1    vd[i] = vs2[i+1] if v0.mask[i] enabled
             vstart &lt;= i = vl-1    vd[vl-1] = x[rs1] if v0.mask[i] enabled
                 vl &lt;= i &lt; VLMAX   Follow tail policy</screen>
<simpara>The <literal>vfslide1down</literal> instruction is defined analogously, but sources its
scalar argument from an <literal>f</literal> register.</simpara>
<note>
<simpara>The <literal>vslide1down</literal> instruction can be used to load values into a
vector register without using memory and without disturbing other
vector registers.  This provides a path for debuggers to modify the
contents of a vector register, albeit slowly, with multiple repeated
<literal>vslide1down</literal> invocations.</simpara>
</note>
</section>
</section>
<section xml:id="_vector_register_gather_instructions">
<title>Vector Register Gather Instructions</title>
<simpara>The vector register gather instructions read elements from a first
source vector register group at locations given by a second source
vector register group.  The index values in the second vector are
treated as unsigned integers.  The source vector can be read at any
index &lt; VLMAX regardless of <literal>vl</literal>.  The maximum number of elements to write to
the destination register is given by <literal>vl</literal>, and the remaining elements
past <literal>vl</literal> are handled according to the current tail policy
(Section <xref linkend="sec-agnostic"/>).  The operation can be masked, and the mask
undisturbed/agnostic policy is followed for inactive elements.</simpara>
<screen>vrgather.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];
vrgatherei16.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];</screen>
<simpara>The <literal>vrgather.vv</literal> form uses SEW/LMUL for both the data and
indices. The <literal>vrgatherei16.vv</literal> form uses SEW/LMUL for the data in
<literal>vs2</literal> but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in <literal>vs1</literal>.</simpara>
<note>
<simpara>When SEW=8, <literal>vrgather.vv</literal> can only reference vector elements
0-255.  The <literal>vrgatherei16</literal> form can index 64K elements, and can also
be used to reduce the register capacity needed to hold indices when
SEW &gt; 16.</simpara>
</note>
<simpara>If an element index is out of range ( <literal>vs1[i]</literal> ≥ VLMAX )
then zero is returned for the element value.</simpara>
<simpara>Vector-scalar and vector-immediate forms of the register gather are
also provided.  These read one element from the source vector at the
given index, and write this value to the active elements at the start
of the destination vector register. The index value in the scalar
register and the immediate, zero-extended to XLEN bits, are treated as
unsigned integers.  If XLEN &gt; SEW, the index value is <emphasis>not</emphasis> truncated
to SEW bits.</simpara>
<note>
<simpara>These forms allow any vector element to be "splatted" to an entire vector.</simpara>
</note>
<screen>vrgather.vx vd, vs2, rs1, vm # vd[i] = (x[rs1] &gt;= VLMAX) ? 0 : vs2[x[rs1]]
vrgather.vi vd, vs2, uimm, vm # vd[i] = (uimm &gt;= VLMAX) ? 0 : vs2[uimm]</screen>
<simpara>For any <literal>vrgather</literal> instruction, the destination vector register group
cannot overlap with the source vector register groups, otherwise the
instruction encoding is reserved.</simpara>
</section>
<section xml:id="_vector_compress_instruction">
<title>Vector Compress Instruction</title>
<simpara>The vector compress instruction allows elements selected by a vector
mask register from a source vector register group to be packed into
contiguous elements at the start of the destination vector register
group.</simpara>
<screen>  vcompress.vm vd, vs2, vs1  # Compress into vd elements of vs2 where vs1 is enabled</screen>
<simpara>The vector mask register specified by <literal>vs1</literal> indicates which of the
first <literal>vl</literal> elements of vector register group <literal>vs2</literal> should be extracted
and packed into contiguous elements at the beginning of vector
register <literal>vd</literal>. The remaining elements of <literal>vd</literal> are treated as tail
elements according to the current tail policy (Section
<xref linkend="sec-agnostic"/>).</simpara>
<screen>    Example use of vcompress instruction

        1 1 0 1 0 0 1 0 1   v0
        8 7 6 5 4 3 2 1 0   v1
        1 2 3 4 5 6 7 8 9   v2

                                vcompress.vm v2, v1, v0
        1 2 3 4 8 7 5 2 0   v2</screen>
<simpara><literal>vcompress</literal> is encoded as an unmasked instruction (<literal>vm=1</literal>). The equivalent
masked instruction (<literal>vm=0</literal>) is reserved.</simpara>
<simpara>The destination vector register group cannot overlap the source vector
register group or the source mask register, otherwise the instruction
encoding is reserved.</simpara>
<simpara>A trap on a <literal>vcompress</literal> instruction is always reported with a
<literal>vstart</literal> of 0.  Executing a <literal>vcompress</literal> instruction with a non-zero
<literal>vstart</literal> raises an illegal instruction exception.</simpara>
<note>
<simpara>Although possible, <literal>vcompress</literal> is one of the more difficult
instructions to restart with a non-zero <literal>vstart</literal>, so assumption is
implementations will choose not do that but will instead restart from
element 0.  This does mean elements in destination register after
<literal>vstart</literal> will already have been updated.</simpara>
</note>
<section xml:id="_synthesizing_vdecompress">
<title>Synthesizing <literal>vdecompress</literal></title>
<simpara>There is no inverse <literal>vdecompress</literal> provided, as this operation can be
readily synthesized using iota and a masked vrgather:</simpara>
<screen>    Desired functionality of 'vdecompress'
      7 6 5 4 3 2 1 0     # vid

            e d c b a     # packed vector of 5 elements
      1 0 0 1 1 1 0 1     # mask vector of 8 elements
      p q r s t u v w     # destination register before vdecompress

      e q r d c b v a     # result of vdecompress</screen>
<screen>     # v0 holds mask
     # v1 holds packed data
     # v11 holds input expanded vector and result
     viota.m v10, v0                 # Calc iota from mask in v0
     vrgather.vv v11, v1, v10, v0.t  # Expand into destination</screen>
<screen>   p q r s t u v w    # v11 destination register
         e d c b a    # v1 source vector
   1 0 0 1 1 1 0 1    # v0 mask vector

   4 4 4 3 2 1 1 0    # v10 result of viota.m
   e q r d c b v a    # v11 destination after vrgather using viota.m under mask</screen>
</section>
</section>
<section xml:id="_whole_vector_register_move">
<title>Whole Vector Register Move</title>
<simpara>The <literal>vmv&lt;nr&gt;r.v</literal> instructions copy whole vector registers (i.e., all
VLEN bits) and can copy whole vector register groups.  The
instructions operate as if EEW=SEW, EMUL = <literal>nr</literal>, effective length
<literal>evl</literal>= EMUL * VLEN/SEW.</simpara>
<note>
<simpara>These instructions are intended to aid compilers to shuffle
vector registers without needing to know or change <literal>vl</literal> or <literal>vtype</literal>.</simpara>
</note>
<note>
<simpara>The usual property that no elements are written if <literal>vstart</literal> ≥ <literal>vl</literal>
does not apply to these instructions.
Instead, no elements are written if <literal>vstart</literal> ≥ <literal>evl</literal>.</simpara>
</note>
<note>
<simpara>If <literal>vd</literal> is equal to <literal>vs2</literal> the instruction is an architectural
NOP, but is treated as a hint to implementations that rearrange data
internally that the register group will next be accessed with an EEW
equal to SEW.</simpara>
</note>
<simpara>The instruction is encoded as an OPIVI instruction.  The number of
vector registers to copy is encoded in the low three bits of the
<literal>simm</literal> field using the same encoding as the <literal>nf</literal> field for memory
instructions, i.e., <literal>simm</literal> = <literal>nr-1</literal>.
The value of the <literal>nr</literal> field must be 1, 2, 4, or 8, with other values reserved.</simpara>
<note>
<simpara>A future extension may support other numbers of registers to be moved.
Values of <literal>simm</literal> other than 0, 1, 3, and 7 are currently reserved.</simpara>
</note>
<note>
<simpara>The instruction uses the same funct6 encoding as the <literal>vsmul</literal>
instruction but with an immediate operand, and only the unmasked
version (<literal>vm=1</literal>).  This encoding is chosen as it is close to the
related <literal>vmerge</literal> encoding, and it is unlikely the <literal>vsmul</literal> instruction
would benefit from an immediate form.</simpara>
</note>
<screen>    vmv&lt;nr&gt;r.v vd, vs2  # General form

    vmv1r.v v1, v2   #  Copy v1=v2
    vmv2r.v v10, v12 #  Copy v10=v12; v11=v13
    vmv4r.v v4, v8   #  Copy v4=v8; v5=v9; v6=v10; v7=v11
    vmv8r.v v0, v8   #  Copy v0=v8; v1=v9; ...;  v7=v15</screen>
<simpara>The source and destination vector register numbers must be aligned
appropriately for the vector register group size, and encodings with
other vector register numbers are reserved.</simpara>
<note>
<simpara>A future extension may relax the vector register alignment
restrictions.</simpara>
</note>
</section>
</section>
<section xml:id="_exception_handling">
<title>Exception Handling</title>
<simpara>On a trap during a vector instruction (caused by either a synchronous
exception or an asynchronous interrupt), the existing <literal>*epc</literal> CSR is
written with a pointer to the errant vector instruction, while the
<literal>vstart</literal> CSR contains the element index that caused the trap to be
taken.</simpara>
<note>
<simpara>We chose to add a <literal>vstart</literal> CSR to allow resumption of a
partially executed vector instruction to reduce interrupt latencies
and to simplify forward-progress guarantees.  This is similar to the
scheme in the IBM 3090 vector facility.  To ensure forward progress
without the <literal>vstart</literal> CSR, implementations would have to guarantee an
entire vector instruction can always complete atomically without
generating a trap.  This is particularly difficult to ensure in the
presence of strided or scatter/gather operations and demand-paged
virtual memory.</simpara>
</note>
<section xml:id="_precise_vector_traps">
<title>Precise vector traps</title>
<note>
<simpara>We assume most supervisor-mode environments with demand-paging
will require precise vector traps.</simpara>
</note>
<simpara>Precise vector traps require that:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>all instructions older than the trapping vector instruction have committed their results</simpara>
</listitem>
<listitem>
<simpara>no instructions newer than the trapping vector instruction have altered architectural state</simpara>
</listitem>
<listitem>
<simpara>any operations within the trapping vector instruction affecting result elements preceding the index in the <literal>vstart</literal> CSR have committed their results</simpara>
</listitem>
<listitem>
<simpara>no operations within the trapping vector instruction affecting elements at or following the <literal>vstart</literal> CSR have altered architectural state except if restarting and completing the affected vector instruction will nevertheless produce the correct final state.</simpara>
</listitem>
</orderedlist>
<simpara>We relax the last requirement to allow elements following <literal>vstart</literal> to
have been updated at the time the trap is reported, provided that
re-executing the instruction from the given <literal>vstart</literal> will correctly
overwrite those elements.</simpara>
<simpara>In idempotent memory regions, vector store instructions may have
updated elements in memory past the element causing a synchronous
trap.  Non-idempotent memory regions must not have been updated for
indices equal to or greater than the element that caused a synchronous
trap during a vector store instruction.</simpara>
<simpara>Except where noted above, vector instructions are allowed to overwrite
their inputs, and so in most cases, the vector instruction restart
must be from the <literal>vstart</literal> location. However, there are a number of
cases where this overwrite is prohibited to enable execution of the
vector instructions to be idempotent and hence restartable from any
location.</simpara>
<simpara>Implementations must ensure forward progress can be eventually
guaranteed for the element or segment reported by <literal>vstart</literal>.</simpara>
</section>
<section xml:id="_imprecise_vector_traps">
<title>Imprecise vector traps</title>
<simpara>Imprecise vector traps are traps that are not precise.  In particular,
instructions newer than <literal>*epc</literal> may have committed results, and
instructions older than <literal>*epc</literal> may have not completed execution.
Imprecise traps are primarily intended to be used in situations where
reporting an error and terminating execution is the appropriate
response.</simpara>
<note>
<simpara>A profile might specify that interrupts are precise while other
traps are imprecise.  We assume many embedded implementations will
generate only imprecise traps for vector instructions on fatal errors,
as they will not require resumable traps.</simpara>
</note>
<simpara>Imprecise traps shall report the faulting element in <literal>vstart</literal> for
traps caused by synchronous vector exceptions.</simpara>
</section>
<section xml:id="_selectable_preciseimprecise_traps">
<title>Selectable precise/imprecise traps</title>
<simpara>Some profiles may choose to provide a privileged mode bit to select
between precise and imprecise vector traps.  Imprecise mode would run
at high-performance but possibly make it difficult to discern error
causes, while precise mode would run more slowly, but support
debugging of errors albeit with a possibility of not experiencing the
same errors as in imprecise mode.</simpara>
</section>
<section xml:id="_swappable_traps">
<title>Swappable traps</title>
<simpara>Another trap mode can support swappable state in the vector unit,
where on a trap, special instructions can save and restore the vector
unit microarchitectural state, to allow execution to continue
correctly around imprecise traps.</simpara>
<simpara>This mechanism is not defined in the current standard extensions.</simpara>
<note>
<simpara>A future extension might define a standard way of saving and
restoring opaque microarchitectural state from a vector unit
implementation to support context switching with imprecise traps.</simpara>
</note>
</section>
</section>
<section xml:id="sec-vector-extensions">
<title>Standard Vector Extensions</title>
<simpara>This section describes the standard vector extensions to be proposed
for public review.  A set of smaller extensions intended for embedded
use are named with a "Zve" prefix, while a larger vector extension
designed for application processors is named as a single-letter V
extension.</simpara>
<simpara>The initial vector extensions are designed to act as a base for
additional vector extensions in various domains, including
cryptography and machine learning.</simpara>
<section xml:id="_zve_vector_extensions_for_embedded_processors">
<title>Zve*: Vector extensions for Embedded Processors</title>
<simpara>The following five standard extensions are defined to provide varying
degrees of vector support and are intended for use with embedded
processors.  Any of these extensions can be added to base ISAs with
XLEN=32 or XLEN=64.  The table lists the minimum VLEN and supported
EEWs for each extension as well as what floating-point types are
supported.</simpara>
<table colsep="1" frame="all" rowsep="1">
<title>Embedded vector extensions</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="16.6666*"/>
<colspec colname="col_5" colwidth="16.6669*"/>
<thead>
<row>
<entry align="left" valign="top">Extension</entry>
<entry align="left" valign="top">Minimum VLEN</entry>
<entry align="left" valign="top">Supported EEW</entry>
<entry align="left" valign="top">FP32</entry>
<entry align="left" valign="top">FP64</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Zve32x</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>8, 16, 32</simpara></entry>
<entry align="left" valign="top"><simpara>N</simpara></entry>
<entry align="left" valign="top"><simpara>N</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Zve32f</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>8, 16, 32</simpara></entry>
<entry align="left" valign="top"><simpara>Y</simpara></entry>
<entry align="left" valign="top"><simpara>N</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Zve64x</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>8, 16, 32, 64</simpara></entry>
<entry align="left" valign="top"><simpara>N</simpara></entry>
<entry align="left" valign="top"><simpara>N</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Zve64f</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>8, 16, 32, 64</simpara></entry>
<entry align="left" valign="top"><simpara>Y</simpara></entry>
<entry align="left" valign="top"><simpara>N</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Zve64d</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>8, 16, 32, 64</simpara></entry>
<entry align="left" valign="top"><simpara>Y</simpara></entry>
<entry align="left" valign="top"><simpara>Y</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>All Zve* extensions have precise traps.</simpara>
<note>
<simpara>There is currently no standard support for handling imprecise
traps, so standard extensions have to provide precise traps.</simpara>
</note>
<simpara>All Zve* extensions provide support for EEW of 8, 16, and 32, and
Zve64* extensions also support EEW of 64.</simpara>
<simpara>All Zve* extensions support the vector configuration instructions
(Section <xref linkend="sec-vector-config"/>).</simpara>
<simpara>All Zve* extensions support all vector load and store instructions
(Section <xref linkend="sec-vector-memory"/>), except Zve64* extensions do not
support EEW=64 for index values when XLEN=32.</simpara>
<simpara>All Zve* extensions support all vector integer instructions (Section
<xref linkend="sec-vector-integer"/>), except that the <literal>vmulh</literal> integer multiply
variants that return the high word of the product (<literal>vmulh.vv</literal>,
<literal>vmulh.vx</literal>, <literal>vmulhu.vv</literal>, <literal>vmulhu.vx</literal>, <literal>vmulhsu.vv</literal>, <literal>vmulhsu.vx</literal>) are
not included for EEW=64 in Zve64*.</simpara>
<note>
<simpara>Producing the high-word of a product can take substantial
additional gates for large EEW.</simpara>
</note>
<simpara>All Zve* extensions support all vector fixed-point arithmetic
instructions (<xref linkend="sec-vector-fixed-point"/>), except that <literal>vsmul.vv</literal> and
<literal>vsmul.vx</literal> are not supported for EEW=64 in Zve64*.</simpara>
<note>
<simpara>As with <literal>vmulh</literal>, <literal>vsmul</literal> requires a large amount of additional
logic, and 64-bit fixed-point multiplies are relatively rare.</simpara>
</note>
<simpara>All Zve* extensions support all vector integer single-width and
widening reduction operations (Sections <xref linkend="sec-vector-integer-reduce"/>,
<xref linkend="sec-vector-integer-reduce-widen"/>).</simpara>
<simpara>All Zve* extensions support all vector mask instructions (Section
<xref linkend="sec-vector-mask"/>).</simpara>
<simpara>All Zve* extensions support all vector permutation instructions
(Section <xref linkend="sec-vector-permute"/>), except that Zve32x and Zve64x do not
implement the floating-point scalar move instructions.</simpara>
<simpara>The Zve32f and Zve64f extensions require the scalar processor to
implement the F extension, and implement all vector floating-point
instructions (Section <xref linkend="sec-vector-float"/>) for floating-point
operands with EEW=32 (i.e., no widening floating-point operations),
and conversion instructions are provided to and from all supported
integer EEWs.  Vector single-width floating-point reduction operations
(<xref linkend="sec-vector-float-reduce"/>) for EEW=32 are supported.</simpara>
<simpara>The Zve32d and Zve64d extensions require the scalar processor to
implement the D extension, and implement all vector floating-point
instructions (Section <xref linkend="sec-vector-float"/>) for floating-point
operands with EEW=32 or EEW=64 (including widening instructions and
conversions between FP32 and FP64). Vector single-width floating-point
reductions (<xref linkend="sec-vector-float-reduce"/>) for EEW=32 and EEW=64 are
supported as well as widening reductions from FP32 to FP64.</simpara>
</section>
<section xml:id="_v_vector_extension_for_application_processor">
<title>V: Vector Extension for Application Processor</title>
<simpara>The single-letter V extension is intended for use in application
processor profiles.</simpara>
<simpara>The V vector extension has precise traps.</simpara>
<simpara>The V vector extension requires that VLEN ≥ 128.</simpara>
<note>
<simpara>The value of 128 was chosen as a compromise for application
processors. Providing a larger VLEN allows stripmining code to be
elided in some cases for short vectors, but also increases the size of
the minimum implementation.  Note that larger LMUL can be used to
avoid stripmining for longer known-size application vectors at the
cost of having fewer available vector register groups. For example, an
LMUL of 8 allows vectors of up to sixteen 64-bit elements to be
processed without stripmining using four vector register groups.</simpara>
</note>
<simpara>The V extension supports EEW of 8, 16, and 32, and 64.</simpara>
<simpara>The V extension supports the vector configuration instructions
(Section <xref linkend="sec-vector-config"/>).</simpara>
<simpara>The V extension supports all vector load and store instructions
(Section <xref linkend="sec-vector-memory"/>), except the V extension does not
support EEW=64 for index values when XLEN=32.</simpara>
<simpara>The V extension supports all vector integer instructions (Section
<xref linkend="sec-vector-integer"/>).</simpara>
<simpara>The V extension supports all vector fixed-point arithmetic
instructions (<xref linkend="sec-vector-fixed-point"/>).</simpara>
<simpara>The V extension supports all vector integer single-width and
widening reduction operations (Sections <xref linkend="sec-vector-integer-reduce"/>,
<xref linkend="sec-vector-integer-reduce-widen"/>).</simpara>
<simpara>The V extension supports all vector mask instructions (Section
<xref linkend="sec-vector-mask"/>).</simpara>
<simpara>The V extension supports all vector permutation instructions (Section
<xref linkend="sec-vector-permute"/>).</simpara>
<simpara>The V extension requires the scalar processor to implement the F and D
extensions, and implements all vector floating-point instructions
(Section <xref linkend="sec-vector-float"/>) for floating-point operands with EEW=32
or EEW=64 (including widening instructions and conversions between
FP32 and FP64). Vector single-width floating-point reductions
(<xref linkend="sec-vector-float-reduce"/>) for EEW=32 and EEW=64 are supported as
well as widening reductions from FP32 to FP64.</simpara>
</section>
</section>
<section xml:id="_vector_instruction_listing">
<title>Vector Instruction Listing</title>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="13">
<colspec colname="col_1" colwidth="7.6923*"/>
<colspec colname="col_2" colwidth="7.6923*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="7.6923*"/>
<colspec colname="col_5" colwidth="7.6923*"/>
<colspec colname="col_6" colwidth="7.6923*"/>
<colspec colname="col_7" colwidth="7.6923*"/>
<colspec colname="col_8" colwidth="7.6923*"/>
<colspec colname="col_9" colwidth="7.6923*"/>
<colspec colname="col_10" colwidth="7.6923*"/>
<colspec colname="col_11" colwidth="7.6923*"/>
<colspec colname="col_12" colwidth="7.6923*"/>
<colspec colname="col_13" colwidth="7.6924*"/>
<thead>
<row>
<entry align="left" nameend="col_5" namest="col_1" valign="top">Integer</entry>
<entry align="left" nameend="col_9" namest="col_6" valign="top">Integer</entry>
<entry align="left" nameend="col_13" namest="col_10" valign="top">FP</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>funct3</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>funct3</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>funct3</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>OPIVV</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>OPMVV</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>OPFVV</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>OPIVX</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>OPMVX</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>OPFVF</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>OPIVI</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
</tbody>
</tgroup>
</informaltable>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="13">
<colspec colname="col_1" colwidth="7.6923*"/>
<colspec colname="col_2" colwidth="7.6923*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="7.6923*"/>
<colspec colname="col_5" colwidth="7.6923*"/>
<colspec colname="col_6" colwidth="7.6923*"/>
<colspec colname="col_7" colwidth="7.6923*"/>
<colspec colname="col_8" colwidth="7.6923*"/>
<colspec colname="col_9" colwidth="7.6923*"/>
<colspec colname="col_10" colwidth="7.6923*"/>
<colspec colname="col_11" colwidth="7.6923*"/>
<colspec colname="col_12" colwidth="7.6923*"/>
<colspec colname="col_13" colwidth="7.6924*"/>
<thead>
<row>
<entry align="left" nameend="col_5" namest="col_1" valign="top">funct6</entry>
<entry align="left" nameend="col_9" namest="col_6" valign="top">funct6</entry>
<entry align="left" nameend="col_13" namest="col_10" valign="top">funct6</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>000000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vadd</simpara></entry>
<entry align="left" valign="top"><simpara>000000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vredsum</simpara></entry>
<entry align="left" valign="top"><simpara>000000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfadd</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>000001</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>000001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vredand</simpara></entry>
<entry align="left" valign="top"><simpara>000001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vfredsum</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>000010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vsub</simpara></entry>
<entry align="left" valign="top"><simpara>000010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vredor</simpara></entry>
<entry align="left" valign="top"><simpara>000010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfsub</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>000011</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vrsub</simpara></entry>
<entry align="left" valign="top"><simpara>000011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vredxor</simpara></entry>
<entry align="left" valign="top"><simpara>000011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vfredosum</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>000100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vminu</simpara></entry>
<entry align="left" valign="top"><simpara>000100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vredminu</simpara></entry>
<entry align="left" valign="top"><simpara>000100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfmin</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>000101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmin</simpara></entry>
<entry align="left" valign="top"><simpara>000101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vredmin</simpara></entry>
<entry align="left" valign="top"><simpara>000101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vfredmin</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>000110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmaxu</simpara></entry>
<entry align="left" valign="top"><simpara>000110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vredmaxu</simpara></entry>
<entry align="left" valign="top"><simpara>000110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfmax</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>000111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmax</simpara></entry>
<entry align="left" valign="top"><simpara>000111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vredmax</simpara></entry>
<entry align="left" valign="top"><simpara>000111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vfredmax</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>001000</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>001000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vaaddu</simpara></entry>
<entry align="left" valign="top"><simpara>001000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfsgnj</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>001001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vand</simpara></entry>
<entry align="left" valign="top"><simpara>001001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vaadd</simpara></entry>
<entry align="left" valign="top"><simpara>001001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfsgnjn</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>001010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vor</simpara></entry>
<entry align="left" valign="top"><simpara>001010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vasubu</simpara></entry>
<entry align="left" valign="top"><simpara>001010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfsgnjx</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>001011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vxor</simpara></entry>
<entry align="left" valign="top"><simpara>001011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vasub</simpara></entry>
<entry align="left" valign="top"><simpara>001011</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>001100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vrgather</simpara></entry>
<entry align="left" valign="top"><simpara>001100</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>001100</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>001101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>001101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>001101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>001110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vslideup</simpara></entry>
<entry align="left" valign="top"><simpara>001110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vslide1up</simpara></entry>
<entry align="left" valign="top"><simpara>001110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfslide1up</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>001110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vrgatherei16</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>001111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vslidedown</simpara></entry>
<entry align="left" valign="top"><simpara>001111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vslide1down</simpara></entry>
<entry align="left" valign="top"><simpara>001111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfslide1down</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="13">
<colspec colname="col_1" colwidth="7.6923*"/>
<colspec colname="col_2" colwidth="7.6923*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="7.6923*"/>
<colspec colname="col_5" colwidth="7.6923*"/>
<colspec colname="col_6" colwidth="7.6923*"/>
<colspec colname="col_7" colwidth="7.6923*"/>
<colspec colname="col_8" colwidth="7.6923*"/>
<colspec colname="col_9" colwidth="7.6923*"/>
<colspec colname="col_10" colwidth="7.6923*"/>
<colspec colname="col_11" colwidth="7.6923*"/>
<colspec colname="col_12" colwidth="7.6923*"/>
<colspec colname="col_13" colwidth="7.6924*"/>
<thead>
<row>
<entry align="left" nameend="col_5" namest="col_1" valign="top">funct6</entry>
<entry align="left" nameend="col_9" namest="col_6" valign="top">funct6</entry>
<entry align="left" nameend="col_13" namest="col_10" valign="top">funct6</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>010000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vadc</simpara></entry>
<entry align="left" valign="top"><simpara>010000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>VWXUNARY0</simpara></entry>
<entry align="left" valign="top"><simpara>010000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>VWFUNARY0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>010000</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>VRXUNARY0</simpara></entry>
<entry align="left" valign="top"><simpara>010000</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>VRFUNARY0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>010001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmadc</simpara></entry>
<entry align="left" valign="top"><simpara>010001</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>010001</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>010010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vsbc</simpara></entry>
<entry align="left" valign="top"><simpara>010010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>VXUNARY0</simpara></entry>
<entry align="left" valign="top"><simpara>010010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>VFUNARY0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>010011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmsbc</simpara></entry>
<entry align="left" valign="top"><simpara>010011</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>010011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>VFUNARY1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>010100</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>010100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>VMUNARY0</simpara></entry>
<entry align="left" valign="top"><simpara>010100</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>010101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>010101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>010101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>010110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>010110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>010110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>010111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmerge/vmv</simpara></entry>
<entry align="left" valign="top"><simpara>010111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vcompress</simpara></entry>
<entry align="left" valign="top"><simpara>010111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfmerge.vf/vfmv</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>011000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmseq</simpara></entry>
<entry align="left" valign="top"><simpara>011000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmandnot</simpara></entry>
<entry align="left" valign="top"><simpara>011000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vmfeq</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>011001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmsne</simpara></entry>
<entry align="left" valign="top"><simpara>011001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmand</simpara></entry>
<entry align="left" valign="top"><simpara>011001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vmfle</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>011010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmsltu</simpara></entry>
<entry align="left" valign="top"><simpara>011010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmor</simpara></entry>
<entry align="left" valign="top"><simpara>011010</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>011011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmslt</simpara></entry>
<entry align="left" valign="top"><simpara>011011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmxor</simpara></entry>
<entry align="left" valign="top"><simpara>011011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vmflt</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>011100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmsleu</simpara></entry>
<entry align="left" valign="top"><simpara>011100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmornot</simpara></entry>
<entry align="left" valign="top"><simpara>011100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vmfne</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>011101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmsle</simpara></entry>
<entry align="left" valign="top"><simpara>011101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmnand</simpara></entry>
<entry align="left" valign="top"><simpara>011101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vmfgt</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>011110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmsgtu</simpara></entry>
<entry align="left" valign="top"><simpara>011110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmnor</simpara></entry>
<entry align="left" valign="top"><simpara>011110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>011111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmsgt</simpara></entry>
<entry align="left" valign="top"><simpara>011111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vmxnor</simpara></entry>
<entry align="left" valign="top"><simpara>011111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vmfge</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="13">
<colspec colname="col_1" colwidth="7.6923*"/>
<colspec colname="col_2" colwidth="7.6923*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="7.6923*"/>
<colspec colname="col_5" colwidth="7.6923*"/>
<colspec colname="col_6" colwidth="7.6923*"/>
<colspec colname="col_7" colwidth="7.6923*"/>
<colspec colname="col_8" colwidth="7.6923*"/>
<colspec colname="col_9" colwidth="7.6923*"/>
<colspec colname="col_10" colwidth="7.6923*"/>
<colspec colname="col_11" colwidth="7.6923*"/>
<colspec colname="col_12" colwidth="7.6923*"/>
<colspec colname="col_13" colwidth="7.6924*"/>
<thead>
<row>
<entry align="left" nameend="col_5" namest="col_1" valign="top">funct6</entry>
<entry align="left" nameend="col_9" namest="col_6" valign="top">funct6</entry>
<entry align="left" nameend="col_13" namest="col_10" valign="top">funct6</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>100000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vsaddu</simpara></entry>
<entry align="left" valign="top"><simpara>100000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vdivu</simpara></entry>
<entry align="left" valign="top"><simpara>100000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfdiv</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vsadd</simpara></entry>
<entry align="left" valign="top"><simpara>100001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vdiv</simpara></entry>
<entry align="left" valign="top"><simpara>100001</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfrdiv</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vssubu</simpara></entry>
<entry align="left" valign="top"><simpara>100010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vremu</simpara></entry>
<entry align="left" valign="top"><simpara>100010</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>100011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vssub</simpara></entry>
<entry align="left" valign="top"><simpara>100011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vrem</simpara></entry>
<entry align="left" valign="top"><simpara>100011</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>100100</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>100100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vmulhu</simpara></entry>
<entry align="left" valign="top"><simpara>100100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfmul</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vsll</simpara></entry>
<entry align="left" valign="top"><simpara>100101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vmul</simpara></entry>
<entry align="left" valign="top"><simpara>100101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>100110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>100110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vmulhsu</simpara></entry>
<entry align="left" valign="top"><simpara>100110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>100111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vsmul</simpara></entry>
<entry align="left" valign="top"><simpara>100111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vmulh</simpara></entry>
<entry align="left" valign="top"><simpara>100111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfrsub</simpara></entry>
</row>
<row>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vmv&lt;nf&gt;r</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>101000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vsrl</simpara></entry>
<entry align="left" valign="top"><simpara>101000</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>101000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfmadd</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vsra</simpara></entry>
<entry align="left" valign="top"><simpara>101001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vmadd</simpara></entry>
<entry align="left" valign="top"><simpara>101001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfnmadd</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vssrl</simpara></entry>
<entry align="left" valign="top"><simpara>101010</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>101010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfmsub</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vssra</simpara></entry>
<entry align="left" valign="top"><simpara>101011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vnmsub</simpara></entry>
<entry align="left" valign="top"><simpara>101011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfnmsub</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vnsrl</simpara></entry>
<entry align="left" valign="top"><simpara>101100</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>101100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfmacc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vnsra</simpara></entry>
<entry align="left" valign="top"><simpara>101101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vmacc</simpara></entry>
<entry align="left" valign="top"><simpara>101101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfnmacc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vnclipu</simpara></entry>
<entry align="left" valign="top"><simpara>101110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>101110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfmsac</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>vnclip</simpara></entry>
<entry align="left" valign="top"><simpara>101111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vnmsac</simpara></entry>
<entry align="left" valign="top"><simpara>101111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfnmsac</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informaltable colsep="1" frame="all" rowsep="1">
<tgroup cols="13">
<colspec colname="col_1" colwidth="7.6923*"/>
<colspec colname="col_2" colwidth="7.6923*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="7.6923*"/>
<colspec colname="col_5" colwidth="7.6923*"/>
<colspec colname="col_6" colwidth="7.6923*"/>
<colspec colname="col_7" colwidth="7.6923*"/>
<colspec colname="col_8" colwidth="7.6923*"/>
<colspec colname="col_9" colwidth="7.6923*"/>
<colspec colname="col_10" colwidth="7.6923*"/>
<colspec colname="col_11" colwidth="7.6923*"/>
<colspec colname="col_12" colwidth="7.6923*"/>
<colspec colname="col_13" colwidth="7.6924*"/>
<thead>
<row>
<entry align="left" nameend="col_5" namest="col_1" valign="top">funct6</entry>
<entry align="left" nameend="col_9" namest="col_6" valign="top">funct6</entry>
<entry align="left" nameend="col_13" namest="col_10" valign="top">funct6</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>110000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vwredsumu</simpara></entry>
<entry align="left" valign="top"><simpara>110000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwaddu</simpara></entry>
<entry align="left" valign="top"><simpara>110000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwadd</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vwredsum</simpara></entry>
<entry align="left" valign="top"><simpara>110001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwadd</simpara></entry>
<entry align="left" valign="top"><simpara>110001</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vfwredsum</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110010</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>110010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwsubu</simpara></entry>
<entry align="left" valign="top"><simpara>110010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwsub</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110011</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>110011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwsub</simpara></entry>
<entry align="left" valign="top"><simpara>110011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>vfwredosum</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110100</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>110100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwaddu.w</simpara></entry>
<entry align="left" valign="top"><simpara>110100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwadd.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>110101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwadd.w</simpara></entry>
<entry align="left" valign="top"><simpara>110101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>110110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>110110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwsubu.w</simpara></entry>
<entry align="left" valign="top"><simpara>110110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwsub.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>110111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwsub.w</simpara></entry>
<entry align="left" valign="top"><simpara>110111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>111000</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwmulu</simpara></entry>
<entry align="left" valign="top"><simpara>111000</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwmul</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>111001</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111001</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111001</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>111010</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111010</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwmulsu</simpara></entry>
<entry align="left" valign="top"><simpara>111010</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>111011</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111011</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwmul</simpara></entry>
<entry align="left" valign="top"><simpara>111011</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>111100</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwmaccu</simpara></entry>
<entry align="left" valign="top"><simpara>111100</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwmacc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>111101</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwmacc</simpara></entry>
<entry align="left" valign="top"><simpara>111101</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwnmacc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>111110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111110</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwmaccus</simpara></entry>
<entry align="left" valign="top"><simpara>111110</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwmsac</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>111111</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>111111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>vwmaccsu</simpara></entry>
<entry align="left" valign="top"><simpara>111111</simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>vfwnmsac</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-pagebreak?></simpara>
<table colsep="1" frame="all" rowsep="1">
<title>VRXUNARY0 encoding space</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="87.5*"/>
<thead>
<row>
<entry align="left" valign="top">vs2</entry>
<entry align="left" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>00000</simpara></entry>
<entry align="left" valign="top"><simpara>vmv.s.x</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>VWXUNARY0 encoding space</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="87.5*"/>
<thead>
<row>
<entry align="left" valign="top">vs1</entry>
<entry align="left" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>00000</simpara></entry>
<entry align="left" valign="top"><simpara>vmv.x.s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>vpopc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10001</simpara></entry>
<entry align="left" valign="top"><simpara>vfirst</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>VXUNARY0 encoding space</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="87.5*"/>
<thead>
<row>
<entry align="left" valign="top">vs1</entry>
<entry align="left" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>00010</simpara></entry>
<entry align="left" valign="top"><simpara>vzext.vf8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00011</simpara></entry>
<entry align="left" valign="top"><simpara>vsext.vf8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00100</simpara></entry>
<entry align="left" valign="top"><simpara>vzext.vf4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00101</simpara></entry>
<entry align="left" valign="top"><simpara>vsext.vf4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00110</simpara></entry>
<entry align="left" valign="top"><simpara>vzext.vf2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00111</simpara></entry>
<entry align="left" valign="top"><simpara>vsext.vf2</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>VRFUNARY0 encoding space</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="87.5*"/>
<thead>
<row>
<entry align="left" valign="top">vs2</entry>
<entry align="left" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>00000</simpara></entry>
<entry align="left" valign="top"><simpara>vfmv.s.f</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>VWFUNARY0 encoding space</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="87.5*"/>
<thead>
<row>
<entry align="left" valign="top">vs1</entry>
<entry align="left" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>00000</simpara></entry>
<entry align="left" valign="top"><simpara>vfmv.f.s</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>VFUNARY0 encoding space</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="87.5*"/>
<thead>
<row>
<entry align="left" valign="top">vs1</entry>
<entry align="left" valign="top">name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" nameend="col_2" namest="col_1" valign="top"><simpara>single-width converts</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00000</simpara></entry>
<entry align="left" valign="top"><simpara>vfcvt.xu.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00001</simpara></entry>
<entry align="left" valign="top"><simpara>vfcvt.x.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00010</simpara></entry>
<entry align="left" valign="top"><simpara>vfcvt.f.xu.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00011</simpara></entry>
<entry align="left" valign="top"><simpara>vfcvt.f.x.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00110</simpara></entry>
<entry align="left" valign="top"><simpara>vfcvt.rtz.xu.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00111</simpara></entry>
<entry align="left" valign="top"><simpara>vfcvt.rtz.x.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" nameend="col_2" namest="col_1" valign="top"><simpara>widening converts</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>01000</simpara></entry>
<entry align="left" valign="top"><simpara>vfwcvt.xu.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>01001</simpara></entry>
<entry align="left" valign="top"><simpara>vfwcvt.x.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>01010</simpara></entry>
<entry align="left" valign="top"><simpara>vfwcvt.f.xu.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>01011</simpara></entry>
<entry align="left" valign="top"><simpara>vfwcvt.f.x.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>01100</simpara></entry>
<entry align="left" valign="top"><simpara>vfwcvt.f.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>01110</simpara></entry>
<entry align="left" valign="top"><simpara>vfwcvt.rtz.xu.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>01111</simpara></entry>
<entry align="left" valign="top"><simpara>vfwcvt.rtz.x.f.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"/>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" nameend="col_2" namest="col_1" valign="top"><simpara>narrowing converts</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>vfncvt.xu.f.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10001</simpara></entry>
<entry align="left" valign="top"><simpara>vfncvt.x.f.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10010</simpara></entry>
<entry align="left" valign="top"><simpara>vfncvt.f.xu.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10011</simpara></entry>
<entry align="left" valign="top"><simpara>vfncvt.f.x.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10100</simpara></entry>
<entry align="left" valign="top"><simpara>vfncvt.f.f.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10101</simpara></entry>
<entry align="left" valign="top"><simpara>vfncvt.rod.f.f.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10110</simpara></entry>
<entry align="left" valign="top"><simpara>vfncvt.rtz.xu.f.w</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10111</simpara></entry>
<entry align="left" valign="top"><simpara>vfncvt.rtz.x.f.w</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>VFUNARY1 encoding space</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="87.5*"/>
<thead>
<row>
<entry align="left" valign="top">vs1</entry>
<entry align="left" valign="top">name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>00000</simpara></entry>
<entry align="left" valign="top"><simpara>vfsqrt.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00100</simpara></entry>
<entry align="left" valign="top"><simpara>vfrsqrt7.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00101</simpara></entry>
<entry align="left" valign="top"><simpara>vfrec7.v</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>vfclass.v</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table colsep="1" frame="all" rowsep="1">
<title>VMUNARY0 encoding space</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="87.5*"/>
<thead>
<row>
<entry align="left" valign="top">vs1</entry>
<entry align="left" valign="top"/>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>00001</simpara></entry>
<entry align="left" valign="top"><simpara>vmsbf</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00010</simpara></entry>
<entry align="left" valign="top"><simpara>vmsof</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>00011</simpara></entry>
<entry align="left" valign="top"><simpara>vmsif</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>viota</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10001</simpara></entry>
<entry align="left" valign="top"><simpara>vid</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<appendix xml:id="_vector_assembly_code_examples">
<title>Vector Assembly Code Examples</title>
<simpara>The following are provided as non-normative text to help explain the vector ISA.</simpara>
<section xml:id="_vector_vector_add_example">
<title>Vector-vector add example</title>
<screen>    # vector-vector add routine of 32-bit integers
    # void vvaddint32(size_t n, const int*x, const int*y, int*z)
    # { for (size_t i=0; i&lt;n; i++) { z[i]=x[i]+y[i]; } }
    #
    # a0 = n, a1 = x, a2 = y, a3 = z
    # Non-vector instructions are indented
vvaddint32:
    vsetvli t0, a0, e32, ta, ma  # Set vector length based on 32-bit vectors
    vle32.v v0, (a1)         # Get first vector
      sub a0, a0, t0         # Decrement number done
      slli t0, t0, 2         # Multiply number done by 4 bytes
      add a1, a1, t0         # Bump pointer
    vle32.v v1, (a2)         # Get second vector
      add a2, a2, t0         # Bump pointer
    vadd.vv v2, v0, v1       # Sum vectors
    vse32.v v2, (a3)         # Store result
      add a3, a3, t0         # Bump pointer
      bnez a0, vvaddint32    # Loop back
      ret                    # Finished</screen>
</section>
<section xml:id="_example_with_mixed_width_mask_and_compute">
<title>Example with mixed-width mask and compute.</title>
<screen># Code using one width for predicate and different width for masked
# compute.
#   int8_t a[]; int32_t b[], c[];
#   for (i=0;  i&lt;n; i++) { b[i] =  (a[i] &lt; 5) ? c[i] : 1; }
#
# Mixed-width code that keeps SEW/LMUL=8
  loop:
    vsetvli a4, a0, e8, m1, ta, ma   # Byte vector for predicate calc
    vle8.v v1, (a1)               # Load a[i]
      add a1, a1, a4              # Bump pointer.
    vmslt.vi v0, v1, 5            # a[i] &lt; 5?

    vsetvli x0, a0, e32, m4, ta, mu  # Vector of 32-bit values.
      sub a0, a0, a4              # Decrement count
    vmv.v.i v4, 1                 # Splat immediate to destination
    vle32.v v4, (a3), v0.t        # Load requested elements of C, others undisturbed
      sll t1, a4, 2
      add a3, a3, t1              # Bump pointer.
    vse32.v v4, (a2)              # Store b[i].
      add a2, a2, t1              # Bump pointer.
      bnez a0, loop               # Any more?</screen>
</section>
<section xml:id="_memcpy_example">
<title>Memcpy example</title>
<screen>    # void *memcpy(void* dest, const void* src, size_t n)
    # a0=dest, a1=src, a2=n
    #
  memcpy:
      mv a3, a0 # Copy destination
  loop:
    vsetvli t0, a2, e8, m8, ta, ma   # Vectors of 8b
    vle8.v v0, (a1)               # Load bytes
      add a1, a1, t0              # Bump pointer
      sub a2, a2, t0              # Decrement count
    vse8.v v0, (a3)               # Store bytes
      add a3, a3, t0              # Bump pointer
      bnez a2, loop               # Any more?
      ret                         # Return</screen>
</section>
<section xml:id="_conditional_example">
<title>Conditional example</title>
<screen># (int16) z[i] = ((int8) x[i] &lt; 5) ? (int16) a[i] : (int16) b[i];
#

loop:
    vsetvli t0, a0, e8, m1, ta, ma # Use 8b elements.
    vle8.v v0, (a1)         # Get x[i]
      sub a0, a0, t0        # Decrement element count
      add a1, a1, t0        # x[i] Bump pointer
    vmslt.vi v0, v0, 5      # Set mask in v0
    vsetvli t0, a0, e16, m2, ta, mu  # Use 16b elements.
      slli t0, t0, 1        # Multiply by 2 bytes
    vle16.v v2, (a2), v0.t  # z[i] = a[i] case
    vmnot.m v0, v0          # Invert v0
      add a2, a2, t0        # a[i] bump pointer
    vle16.v v2, (a3), v0.t  # z[i] = b[i] case
      add a3, a3, t0        # b[i] bump pointer
    vse16.v v2, (a4)        # Store z
      add a4, a4, t0        # z[i] bump pointer
      bnez a0, loop</screen>
</section>
<section xml:id="_saxpy_example">
<title>SAXPY example</title>
<screen># void
# saxpy(size_t n, const float a, const float *x, float *y)
# {
#   size_t i;
#   for (i=0; i&lt;n; i++)
#     y[i] = a * x[i] + y[i];
# }
#
# register arguments:
#     a0      n
#     fa0     a
#     a1      x
#     a2      y

saxpy:
    vsetvli a4, a0, e32, m8, ta, ma
    vle32.v v0, (a1)
    sub a0, a0, a4
    slli a4, a4, 2
    add a1, a1, a4
    vle32.v v8, (a2)
    vfmacc.vf v8, fa0, v0
    vse32.v v8, (a2)
    add a2, a2, a4
    bnez a0, saxpy
    ret</screen>
</section>
<section xml:id="_sgemm_example">
<title>SGEMM example</title>
<screen># RV64IDV system
#
# void
# sgemm_nn(size_t n,
#          size_t m,
#          size_t k,
#          const float*a,   // m * k matrix
#          size_t lda,
#          const float*b,   // k * n matrix
#          size_t ldb,
#          float*c,         // m * n matrix
#          size_t ldc)
#
#  c += a*b (alpha=1, no transpose on input matrices)
#  matrices stored in C row-major order

#define n a0
#define m a1
#define k a2
#define ap a3
#define astride a4
#define bp a5
#define bstride a6
#define cp a7
#define cstride t0
#define kt t1
#define nt t2
#define bnp t3
#define cnp t4
#define akp t5
#define bkp s0
#define nvl s1
#define ccp s2
#define amp s3

# Use args as additional temporaries
#define ft12 fa0
#define ft13 fa1
#define ft14 fa2
#define ft15 fa3

# This version holds a 16*VLMAX block of C matrix in vector registers
# in inner loop, but otherwise does not cache or TLB tiling.

sgemm_nn:
    addi sp, sp, -FRAMESIZE
    sd s0, OFFSET(sp)
    sd s1, OFFSET(sp)
    sd s2, OFFSET(sp)

    # Check for zero size matrices
    beqz n, exit
    beqz m, exit
    beqz k, exit

    # Convert elements strides to byte strides.
    ld cstride, OFFSET(sp)   # Get arg from stack frame
    slli astride, astride, 2
    slli bstride, bstride, 2
    slli cstride, cstride, 2

    slti t6, m, 16
    bnez t6, end_rows

c_row_loop: # Loop across rows of C blocks

    mv nt, n  # Initialize n counter for next row of C blocks

    mv bnp, bp # Initialize B n-loop pointer to start
    mv cnp, cp # Initialize C n-loop pointer

c_col_loop: # Loop across one row of C blocks
    vsetvli nvl, nt, e32, ta, ma  # 32-bit vectors, LMUL=1

    mv akp, ap   # reset pointer into A to beginning
    mv bkp, bnp # step to next column in B matrix

    # Initalize current C submatrix block from memory.
    vle32.v  v0, (cnp); add ccp, cnp, cstride;
    vle32.v  v1, (ccp); add ccp, ccp, cstride;
    vle32.v  v2, (ccp); add ccp, ccp, cstride;
    vle32.v  v3, (ccp); add ccp, ccp, cstride;
    vle32.v  v4, (ccp); add ccp, ccp, cstride;
    vle32.v  v5, (ccp); add ccp, ccp, cstride;
    vle32.v  v6, (ccp); add ccp, ccp, cstride;
    vle32.v  v7, (ccp); add ccp, ccp, cstride;
    vle32.v  v8, (ccp); add ccp, ccp, cstride;
    vle32.v  v9, (ccp); add ccp, ccp, cstride;
    vle32.v v10, (ccp); add ccp, ccp, cstride;
    vle32.v v11, (ccp); add ccp, ccp, cstride;
    vle32.v v12, (ccp); add ccp, ccp, cstride;
    vle32.v v13, (ccp); add ccp, ccp, cstride;
    vle32.v v14, (ccp); add ccp, ccp, cstride;
    vle32.v v15, (ccp)


    mv kt, k # Initialize inner loop counter

    # Inner loop scheduled assuming 4-clock occupancy of vfmacc instruction and single-issue pipeline
    # Software pipeline loads
    flw ft0, (akp); add amp, akp, astride;
    flw ft1, (amp); add amp, amp, astride;
    flw ft2, (amp); add amp, amp, astride;
    flw ft3, (amp); add amp, amp, astride;
    # Get vector from B matrix
    vle32.v v16, (bkp)

    # Loop on inner dimension for current C block
 k_loop:
    vfmacc.vf v0, ft0, v16
    add bkp, bkp, bstride
    flw ft4, (amp)
    add amp, amp, astride
    vfmacc.vf v1, ft1, v16
    addi kt, kt, -1    # Decrement k counter
    flw ft5, (amp)
    add amp, amp, astride
    vfmacc.vf v2, ft2, v16
    flw ft6, (amp)
    add amp, amp, astride
    flw ft7, (amp)
    vfmacc.vf v3, ft3, v16
    add amp, amp, astride
    flw ft8, (amp)
    add amp, amp, astride
    vfmacc.vf v4, ft4, v16
    flw ft9, (amp)
    add amp, amp, astride
    vfmacc.vf v5, ft5, v16
    flw ft10, (amp)
    add amp, amp, astride
    vfmacc.vf v6, ft6, v16
    flw ft11, (amp)
    add amp, amp, astride
    vfmacc.vf v7, ft7, v16
    flw ft12, (amp)
    add amp, amp, astride
    vfmacc.vf v8, ft8, v16
    flw ft13, (amp)
    add amp, amp, astride
    vfmacc.vf v9, ft9, v16
    flw ft14, (amp)
    add amp, amp, astride
    vfmacc.vf v10, ft10, v16
    flw ft15, (amp)
    add amp, amp, astride
    addi akp, akp, 4            # Move to next column of a
    vfmacc.vf v11, ft11, v16
    beqz kt, 1f                 # Don't load past end of matrix
    flw ft0, (akp)
    add amp, akp, astride
1:  vfmacc.vf v12, ft12, v16
    beqz kt, 1f
    flw ft1, (amp)
    add amp, amp, astride
1:  vfmacc.vf v13, ft13, v16
    beqz kt, 1f
    flw ft2, (amp)
    add amp, amp, astride
1:  vfmacc.vf v14, ft14, v16
    beqz kt, 1f                 # Exit out of loop
    flw ft3, (amp)
    add amp, amp, astride
    vfmacc.vf v15, ft15, v16
    vle32.v v16, (bkp)            # Get next vector from B matrix, overlap loads with jump stalls
    j k_loop

1:  vfmacc.vf v15, ft15, v16

    # Save C matrix block back to memory
    vse32.v  v0, (cnp); add ccp, cnp, cstride;
    vse32.v  v1, (ccp); add ccp, ccp, cstride;
    vse32.v  v2, (ccp); add ccp, ccp, cstride;
    vse32.v  v3, (ccp); add ccp, ccp, cstride;
    vse32.v  v4, (ccp); add ccp, ccp, cstride;
    vse32.v  v5, (ccp); add ccp, ccp, cstride;
    vse32.v  v6, (ccp); add ccp, ccp, cstride;
    vse32.v  v7, (ccp); add ccp, ccp, cstride;
    vse32.v  v8, (ccp); add ccp, ccp, cstride;
    vse32.v  v9, (ccp); add ccp, ccp, cstride;
    vse32.v v10, (ccp); add ccp, ccp, cstride;
    vse32.v v11, (ccp); add ccp, ccp, cstride;
    vse32.v v12, (ccp); add ccp, ccp, cstride;
    vse32.v v13, (ccp); add ccp, ccp, cstride;
    vse32.v v14, (ccp); add ccp, ccp, cstride;
    vse32.v v15, (ccp)

    # Following tail instructions should be scheduled earlier in free slots during C block save.
    # Leaving here for clarity.

    # Bump pointers for loop across blocks in one row
    slli t6, nvl, 2
    add cnp, cnp, t6                         # Move C block pointer over
    add bnp, bnp, t6                         # Move B block pointer over
    sub nt, nt, nvl                          # Decrement element count in n dimension
    bnez nt, c_col_loop                      # Any more to do?

    # Move to next set of rows
    addi m, m, -16  # Did 16 rows above
    slli t6, astride, 4  # Multiply astride by 16
    add ap, ap, t6         # Move A matrix pointer down 16 rows
    slli t6, cstride, 4  # Multiply cstride by 16
    add cp, cp, t6         # Move C matrix pointer down 16 rows

    slti t6, m, 16
    beqz t6, c_row_loop

    # Handle end of matrix with fewer than 16 rows.
    # Can use smaller versions of above decreasing in powers-of-2 depending on code-size concerns.
end_rows:
    # Not done.

exit:
    ld s0, OFFSET(sp)
    ld s1, OFFSET(sp)
    ld s2, OFFSET(sp)
    addi sp, sp, FRAMESIZE
    ret</screen>
</section>
<section xml:id="_division_approximation_example">
<title>Division approximation example</title>
<screen># v1 = v1 / v2 to almost 23 bits of precision.

vfrec7.v v3, v2             # Estimate 1/v2
  li t0, 0x40000000
vmv.v.x v4, t0              # Splat 2.0
vfnmsac.vv v4, v2, v3       # 2.0 - v2 * est(1/v2)
vfmul.vv v3, v3, v4         # Better estimate of 1/v2
vmv.v.x v4, t0              # Splat 2.0
vfnmsac.vv v4, v2, v3       # 2.0 - v2 * est(1/v2)
vfmul.vv v3, v3, v4         # Better estimate of 1/v2
vfmul.vv v1, v1, v3         # Estimate of v1/v2</screen>
</section>
<section xml:id="_square_root_approximation_example">
<title>Square root approximation example</title>
<screen># v1 = sqrt(v1) to almost 23 bits of precision.

  fmv.w.x ft0, x0           # Mask off zero inputs
vmfne.vf v0, v1, ft0        #   to avoid div by zero
vfrsqrt7.v v2, v1, v0.t     # Estimate 1/sqrt(x)
vmfne.vf v0, v2, ft0, v0.t  # Additionally mask off +inf inputs
  li t0, 0xbf000000
  fmv.w.x ft0, t0           # -0.5
vfmul.vf v3, v1, ft0, v0.t  # -0.5 * x
vfmul.vv v4, v2, v2, v0.t   # est * est
  li t0, 0x3fc00000
vmv.v.x v5, t0, v0.t        # Splat 1.5
vfmadd.vv v4, v3, v5, v0.t  # 1.5 - 0.5 * x * est * est
vfmul.vv v1, v1, v4, v0.t   # estimate to 14 bits
vfmul.vv v4, v1, v1, v0.t   # est * est
vfmadd.vv v4, v3, v5, v0.t  # 1.5 - 0.5 * x * est * est
vfmul.vv v1, v1, v4, v0.t   # estimate to 23 bits</screen>
</section>
</appendix>
<appendix xml:id="_calling_convention">
<title>Calling Convention</title>
<simpara>In the RISC-V psABI, the vector registers <literal>v0</literal>-<literal>v31</literal> are all caller-saved.
The <literal>vl</literal> and <literal>vtype</literal> CSRs are also caller-saved.</simpara>
<simpara>Procedures may assume that <literal>vstart</literal> is zero upon entry.  Procedures may
assume that <literal>vstart</literal> is zero upon return from a procedure call.</simpara>
<note>
<simpara>Application software should normally not write <literal>vstart</literal> explicitly.
Any procedure that does explicitly write <literal>vstart</literal> to a nonzero value must
zero <literal>vstart</literal> before either returning or calling another procedure.</simpara>
</note>
<simpara>The <literal>vxrm</literal> and <literal>vxsat</literal> fields of <literal>vcsr</literal> have thread storage duration.</simpara>
<simpara>Executing a system call causes all caller-saved vector registers
(<literal>v0</literal>-<literal>v31</literal>, <literal>vl</literal>, <literal>vtype</literal>) and <literal>vstart</literal> to become unspecified.</simpara>
<note>
<simpara>This scheme allows system calls that cause context switches to avoid
saving and later restoring the vector registers.</simpara>
</note>
<note>
<simpara>Most OSes will choose to either leave these registers intact or reset
them to their initial state to avoid leaking information across process
boundaries.</simpara>
</note>
</appendix>
</article>